! function(e) {
    function t(r) {
        if (n[r]) return n[r].exports;
        var i = n[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return e[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports
    }
    var n = {};
    t.m = e, t.c = n, t.d = function(e, n, r) {
        t.o(e, n) || Object.defineProperty(e, n, {
            configurable: !1,
            enumerable: !0,
            get: r
        })
    }, t.n = function(e) {
        var n = e && e.__esModule ? function() {
            return e.default
        } : function() {
            return e
        };
        return t.d(n, "a", n), n
    }, t.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, t.p = "", t(t.s = 64)
}([function(e, t, n) {
    "use strict";

    function r() {}

    function i(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function o(e, t, n, r, a, s, c, l, h, u) {
        Object.defineProperty(this, "id", {
            value: Es++
        }), this.uuid = Ms.generateUUID(), this.name = "", this.image = void 0 !== e ? e : o.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : o.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : ya, this.wrapT = void 0 !== r ? r : ya, this.magFilter = void 0 !== a ? a : Ma, this.minFilter = void 0 !== s ? s : Ta, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== c ? c : za, this.type = void 0 !== l ? l : Sa, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : ps, this.version = 0, this.onUpdate = null
    }

    function a(e, t, n, r) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
    }

    function s(e, t, n) {
        this.uuid = Ms.generateUUID(), this.width = e, this.height = t, this.scissor = new a(0, 0, e, t), this.scissorTest = !1, this.viewport = new a(0, 0, e, t), n = n || {}, void 0 === n.minFilter && (n.minFilter = Ma), this.texture = new o(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function c(e, t, n) {
        s.call(this, e, t, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
    }

    function l(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
    }

    function h(e, t, n) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0
    }

    function u() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function d(e, t, n, r, i, a, s, c, l, h, u, d) {
        o.call(this, null, a, s, c, l, h, r, i, u, d), this.image = {
            data: e,
            width: t,
            height: n
        }, this.magFilter = void 0 !== l ? l : xa, this.minFilter = void 0 !== h ? h : xa, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }

    function p(e, t, n, r, i, a, s, c, l, h) {
        e = void 0 !== e ? e : [], t = void 0 !== t ? t : ha, o.call(this, e, t, n, r, i, a, s, c, l, h), this.flipY = !1
    }

    function f() {
        this.seq = [], this.map = {}
    }

    function m(e, t, n) {
        var r = e[0];
        if (r <= 0 || r > 0) return e;
        var i = t * n,
            o = As[i];
        if (void 0 === o && (o = new Float32Array(i), As[i] = o), 0 !== t) {
            r.toArray(o, 0);
            for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
        }
        return o
    }

    function g(e, t) {
        var n = Ps[t];
        void 0 === n && (n = new Int32Array(t), Ps[t] = n);
        for (var r = 0; r !== t; ++r) n[r] = e.allocTextureUnit();
        return n
    }

    function v(e, t) {
        e.uniform1f(this.addr, t)
    }

    function y(e, t) {
        e.uniform1i(this.addr, t)
    }

    function b(e, t) {
        void 0 === t.x ? e.uniform2fv(this.addr, t) : e.uniform2f(this.addr, t.x, t.y)
    }

    function x(e, t) {
        void 0 !== t.x ? e.uniform3f(this.addr, t.x, t.y, t.z) : void 0 !== t.r ? e.uniform3f(this.addr, t.r, t.g, t.b) : e.uniform3fv(this.addr, t)
    }

    function w(e, t) {
        void 0 === t.x ? e.uniform4fv(this.addr, t) : e.uniform4f(this.addr, t.x, t.y, t.z, t.w)
    }

    function _(e, t) {
        e.uniformMatrix2fv(this.addr, !1, t.elements || t)
    }

    function M(e, t) {
        void 0 === t.elements ? e.uniformMatrix3fv(this.addr, !1, t) : (Ls.set(t.elements), e.uniformMatrix3fv(this.addr, !1, Ls))
    }

    function E(e, t) {
        void 0 === t.elements ? e.uniformMatrix4fv(this.addr, !1, t) : (Cs.set(t.elements), e.uniformMatrix4fv(this.addr, !1, Cs))
    }

    function T(e, t, n) {
        var r = n.allocTextureUnit();
        e.uniform1i(this.addr, r), n.setTexture2D(t || Ts, r)
    }

    function S(e, t, n) {
        var r = n.allocTextureUnit();
        e.uniform1i(this.addr, r), n.setTextureCube(t || Ss, r)
    }

    function A(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function P(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function C(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function L(e) {
        switch (e) {
            case 5126:
                return v;
            case 35664:
                return b;
            case 35665:
                return x;
            case 35666:
                return w;
            case 35674:
                return _;
            case 35675:
                return M;
            case 35676:
                return E;
            case 35678:
                return T;
            case 35680:
                return S;
            case 5124:
            case 35670:
                return y;
            case 35667:
            case 35671:
                return A;
            case 35668:
            case 35672:
                return P;
            case 35669:
            case 35673:
                return C
        }
    }

    function R(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function I(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function O(e, t) {
        e.uniform2fv(this.addr, m(t, this.size, 2))
    }

    function k(e, t) {
        e.uniform3fv(this.addr, m(t, this.size, 3))
    }

    function D(e, t) {
        e.uniform4fv(this.addr, m(t, this.size, 4))
    }

    function N(e, t) {
        e.uniformMatrix2fv(this.addr, !1, m(t, this.size, 4))
    }

    function B(e, t) {
        e.uniformMatrix3fv(this.addr, !1, m(t, this.size, 9))
    }

    function U(e, t) {
        e.uniformMatrix4fv(this.addr, !1, m(t, this.size, 16))
    }

    function F(e, t, n) {
        var r = t.length,
            i = g(n, r);
        e.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.setTexture2D(t[o] || Ts, i[o])
    }

    function z(e, t, n) {
        var r = t.length,
            i = g(n, r);
        e.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.setTextureCube(t[o] || Ss, i[o])
    }

    function j(e) {
        switch (e) {
            case 5126:
                return R;
            case 35664:
                return O;
            case 35665:
                return k;
            case 35666:
                return D;
            case 35674:
                return N;
            case 35675:
                return B;
            case 35676:
                return U;
            case 35678:
                return F;
            case 35680:
                return z;
            case 5124:
            case 35670:
                return I;
            case 35667:
            case 35671:
                return A;
            case 35668:
            case 35672:
                return P;
            case 35669:
            case 35673:
                return C
        }
    }

    function H(e, t, n) {
        this.id = e, this.addr = n, this.setValue = L(t.type)
    }

    function V(e, t, n) {
        this.id = e, this.addr = n, this.size = t.size, this.setValue = j(t.type)
    }

    function G(e) {
        this.id = e, f.call(this)
    }

    function W(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function $(e, t, n) {
        var r = e.name,
            i = r.length;
        for (Rs.lastIndex = 0;;) {
            var o = Rs.exec(r),
                a = Rs.lastIndex,
                s = o[1],
                c = "]" === o[2],
                l = o[3];
            if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === i) {
                W(n, void 0 === l ? new H(s, e, t) : new V(s, e, t));
                break
            }
            var h = n.map,
                u = h[s];
            void 0 === u && (u = new G(s), W(n, u)), n = u
        }
    }

    function X(e, t, n) {
        f.call(this), this.renderer = n;
        for (var r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), i = 0; i < r; ++i) {
            var o = e.getActiveUniform(t, i),
                a = o.name;
            $(o, e.getUniformLocation(t, a), this)
        }
    }

    function q(e, t, n) {
        return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
    }

    function Y(e, t) {
        this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
    }

    function Z(e, t) {
        function n() {
            var e = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                t = new Uint16Array([0, 1, 2, 0, 2, 3]);
            o = f.createBuffer(), a = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, o), f.bufferData(f.ARRAY_BUFFER, e, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), f.bufferData(f.ELEMENT_ARRAY_BUFFER, t, f.STATIC_DRAW), d = f.createTexture(), p = f.createTexture(), m.bindTexture(f.TEXTURE_2D, d), f.texImage2D(f.TEXTURE_2D, 0, f.RGB, 16, 16, 0, f.RGB, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), m.bindTexture(f.TEXTURE_2D, p), f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, 16, 16, 0, f.RGBA, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), s = {
                vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
            }, c = r(s), l = {
                vertex: f.getAttribLocation(c, "position"),
                uv: f.getAttribLocation(c, "uv")
            }, u = {
                renderType: f.getUniformLocation(c, "renderType"),
                map: f.getUniformLocation(c, "map"),
                occlusionMap: f.getUniformLocation(c, "occlusionMap"),
                opacity: f.getUniformLocation(c, "opacity"),
                color: f.getUniformLocation(c, "color"),
                scale: f.getUniformLocation(c, "scale"),
                rotation: f.getUniformLocation(c, "rotation"),
                screenPosition: f.getUniformLocation(c, "screenPosition")
            }
        }

        function r(t) {
            var n = f.createProgram(),
                r = f.createShader(f.FRAGMENT_SHADER),
                i = f.createShader(f.VERTEX_SHADER),
                o = "precision " + e.getPrecision() + " float;\n";
            return f.shaderSource(r, o + t.fragmentShader), f.shaderSource(i, o + t.vertexShader), f.compileShader(r), f.compileShader(i), f.attachShader(n, r), f.attachShader(n, i), f.linkProgram(n), n
        }
        var o, a, s, c, l, u, d, p, f = e.context,
            m = e.state;
        this.render = function(r, s, g) {
            if (0 !== t.length) {
                var v = new h,
                    y = g.w / g.z,
                    b = .5 * g.z,
                    x = .5 * g.w,
                    w = 16 / g.w,
                    _ = new i(w * y, w),
                    M = new h(1, 1, 0),
                    E = new i(1, 1),
                    T = new Y;
                T.min.set(g.x, g.y), T.max.set(g.x + (g.z - 16), g.y + (g.w - 16)), void 0 === c && n(), f.useProgram(c), m.initAttributes(), m.enableAttribute(l.vertex), m.enableAttribute(l.uv), m.disableUnusedAttributes(), f.uniform1i(u.occlusionMap, 0), f.uniform1i(u.map, 1), f.bindBuffer(f.ARRAY_BUFFER, o), f.vertexAttribPointer(l.vertex, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(l.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), m.disable(f.CULL_FACE), m.buffers.depth.setMask(!1);
                for (var S = 0, A = t.length; S < A; S++) {
                    w = 16 / g.w, _.set(w * y, w);
                    var P = t[S];
                    if (v.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), v.applyMatrix4(s.matrixWorldInverse), v.applyMatrix4(s.projectionMatrix), M.copy(v), E.x = g.x + M.x * b + b - 8, E.y = g.y + M.y * x + x - 8, !0 === T.containsPoint(E)) {
                        m.activeTexture(f.TEXTURE0), m.bindTexture(f.TEXTURE_2D, null), m.activeTexture(f.TEXTURE1), m.bindTexture(f.TEXTURE_2D, d), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGB, E.x, E.y, 16, 16, 0), f.uniform1i(u.renderType, 0), f.uniform2f(u.scale, _.x, _.y), f.uniform3f(u.screenPosition, M.x, M.y, M.z), m.disable(f.BLEND), m.enable(f.DEPTH_TEST), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), m.activeTexture(f.TEXTURE0), m.bindTexture(f.TEXTURE_2D, p), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGBA, E.x, E.y, 16, 16, 0), f.uniform1i(u.renderType, 1), m.disable(f.DEPTH_TEST), m.activeTexture(f.TEXTURE1), m.bindTexture(f.TEXTURE_2D, d), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), P.positionScreen.copy(M), P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares(), f.uniform1i(u.renderType, 2), m.enable(f.BLEND);
                        for (var C = 0, L = P.lensFlares.length; C < L; C++) {
                            var R = P.lensFlares[C];
                            R.opacity > .001 && R.scale > .001 && (M.x = R.x, M.y = R.y, M.z = R.z, w = R.size * R.scale / g.w, _.x = w * y, _.y = w, f.uniform3f(u.screenPosition, M.x, M.y, M.z), f.uniform2f(u.scale, _.x, _.y), f.uniform1f(u.rotation, R.rotation), f.uniform1f(u.opacity, R.opacity), f.uniform3f(u.color, R.color.r, R.color.g, R.color.b), m.setBlending(R.blending, R.blendEquation, R.blendSrc, R.blendDst), e.setTexture2D(R.texture, 1), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0))
                        }
                    }
                }
                m.enable(f.CULL_FACE), m.enable(f.DEPTH_TEST), m.buffers.depth.setMask(!0), e.resetGLState()
            }
        }
    }

    function J(e, t) {
        function n() {
            var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                t = new Uint16Array([0, 1, 2, 0, 2, 3]);
            a = f.createBuffer(), s = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, a), f.bufferData(f.ARRAY_BUFFER, e, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, s), f.bufferData(f.ELEMENT_ARRAY_BUFFER, t, f.STATIC_DRAW), c = r(), u = {
                position: f.getAttribLocation(c, "position"),
                uv: f.getAttribLocation(c, "uv")
            }, d = {
                uvOffset: f.getUniformLocation(c, "uvOffset"),
                uvScale: f.getUniformLocation(c, "uvScale"),
                rotation: f.getUniformLocation(c, "rotation"),
                scale: f.getUniformLocation(c, "scale"),
                color: f.getUniformLocation(c, "color"),
                map: f.getUniformLocation(c, "map"),
                opacity: f.getUniformLocation(c, "opacity"),
                modelViewMatrix: f.getUniformLocation(c, "modelViewMatrix"),
                projectionMatrix: f.getUniformLocation(c, "projectionMatrix"),
                fogType: f.getUniformLocation(c, "fogType"),
                fogDensity: f.getUniformLocation(c, "fogDensity"),
                fogNear: f.getUniformLocation(c, "fogNear"),
                fogFar: f.getUniformLocation(c, "fogFar"),
                fogColor: f.getUniformLocation(c, "fogColor"),
                alphaTest: f.getUniformLocation(c, "alphaTest")
            };
            var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            n.id = "canvas";
            n.width = 8, n.height = 8;
            var i = n.getContext("2d");
            i.fillStyle = "white", i.fillRect(0, 0, 8, 8), p = new o(n), p.needsUpdate = !0
        }

        function r() {
            var t = f.createProgram(),
                n = f.createShader(f.VERTEX_SHADER),
                r = f.createShader(f.FRAGMENT_SHADER);
            return f.shaderSource(n, ["precision " + e.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), f.shaderSource(r, ["precision " + e.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), f.compileShader(n), f.compileShader(r), f.attachShader(t, n), f.attachShader(t, r), f.linkProgram(t), t
        }

        function i(e, t) {
            return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : t.id - e.id
        }
        var a, s, c, u, d, p, f = e.context,
            m = e.state,
            g = new h,
            v = new l,
            y = new h;
        this.render = function(r, o) {
            if (0 !== t.length) {
                void 0 === c && n(), f.useProgram(c), m.initAttributes(), m.enableAttribute(u.position), m.enableAttribute(u.uv), m.disableUnusedAttributes(), m.disable(f.CULL_FACE), m.enable(f.BLEND), f.bindBuffer(f.ARRAY_BUFFER, a), f.vertexAttribPointer(u.position, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(u.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, s), f.uniformMatrix4fv(d.projectionMatrix, !1, o.projectionMatrix.elements), m.activeTexture(f.TEXTURE0), f.uniform1i(d.map, 0);
                var l = 0,
                    h = 0,
                    b = r.fog;
                b ? (f.uniform3f(d.fogColor, b.color.r, b.color.g, b.color.b), b.isFog ? (f.uniform1f(d.fogNear, b.near), f.uniform1f(d.fogFar, b.far), f.uniform1i(d.fogType, 1), l = 1, h = 1) : b.isFogExp2 && (f.uniform1f(d.fogDensity, b.density), f.uniform1i(d.fogType, 2), l = 2, h = 2)) : (f.uniform1i(d.fogType, 0), l = 0, h = 0);
                for (var x = 0, w = t.length; x < w; x++) {
                    var _ = t[x];
                    _.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, _.matrixWorld), _.z = -_.modelViewMatrix.elements[14]
                }
                t.sort(i);
                for (var M = [], x = 0, w = t.length; x < w; x++) {
                    var _ = t[x],
                        E = _.material;
                    if (!1 !== E.visible) {
                        f.uniform1f(d.alphaTest, E.alphaTest), f.uniformMatrix4fv(d.modelViewMatrix, !1, _.modelViewMatrix.elements), _.matrixWorld.decompose(g, v, y), M[0] = y.x, M[1] = y.y;
                        var T = 0;
                        r.fog && E.fog && (T = h), l !== T && (f.uniform1i(d.fogType, T), l = T), null !== E.map ? (f.uniform2f(d.uvOffset, E.map.offset.x, E.map.offset.y), f.uniform2f(d.uvScale, E.map.repeat.x, E.map.repeat.y)) : (f.uniform2f(d.uvOffset, 0, 0), f.uniform2f(d.uvScale, 1, 1)), f.uniform1f(d.opacity, E.opacity), f.uniform3f(d.color, E.color.r, E.color.g, E.color.b), f.uniform1f(d.rotation, E.rotation), f.uniform2fv(d.scale, M), m.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), m.buffers.depth.setTest(E.depthTest), m.buffers.depth.setMask(E.depthWrite), E.map ? e.setTexture2D(E.map, 0) : e.setTexture2D(p, 0), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0)
                    }
                }
                m.enable(f.CULL_FACE), e.resetGLState()
            }
        }
    }

    function K() {
        Object.defineProperty(this, "id", {
            value: Bs++
        }), this.uuid = Ms.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = So, this.side = vo, this.shading = wo, this.vertexColors = _o, this.opacity = 1, this.transparent = !1, this.blendSrc = zo, this.blendDst = jo, this.blendEquation = Ro, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Zo, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.needsUpdate = !0
    }

    function Q(e) {
        K.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function ee(e) {
        K.call(this), this.type = "MeshDepthMaterial", this.depthPacking = ws, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
    }

    function te(e, t) {
        this.min = void 0 !== e ? e : new h(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new h(-1 / 0, -1 / 0, -1 / 0)
    }

    function ne(e, t) {
        this.center = void 0 !== e ? e : new h, this.radius = void 0 !== t ? t : 0
    }

    function re() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function ie(e, t) {
        this.normal = void 0 !== e ? e : new h(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function oe(e, t, n, r, i, o) {
        this.planes = [void 0 !== e ? e : new ie, void 0 !== t ? t : new ie, void 0 !== n ? n : new ie, void 0 !== r ? r : new ie, void 0 !== i ? i : new ie, void 0 !== o ? o : new ie]
    }

    function ae(e, t, n, r) {
        function o(t, n, r, i) {
            var o = t.geometry,
                a = null,
                s = M,
                c = t.customDepthMaterial;
            if (r && (s = E, c = t.customDistanceMaterial), c) a = c;
            else {
                var l = !1;
                n.morphTargets && (o && o.isBufferGeometry ? l = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (l = o.morphTargets && o.morphTargets.length > 0)), t.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                var h = t.isSkinnedMesh && n.skinning,
                    u = 0;
                l && (u |= x), h && (u |= w), a = s[u]
            }
            if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                var d = a.uuid,
                    p = n.uuid,
                    f = T[d];
                void 0 === f && (f = {}, T[d] = f);
                var m = f[p];
                void 0 === m && (m = a.clone(), f[p] = m), a = m
            }
            a.visible = n.visible, a.wireframe = n.wireframe;
            var g = n.side;
            return B.renderSingleSided && g == bo && (g = vo), B.renderReverseSided && (g === vo ? g = yo : g === yo && (g = vo)), a.side = g, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, r && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(i), a
        }

        function c(t, r, i, a) {
            if (!1 !== t.visible) {
                if (t.layers.test(r.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (!t.frustumCulled || p.intersectsObject(t))) {
                    t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
                    var s = n.update(t),
                        l = t.material;
                    if (Array.isArray(l))
                        for (var h = s.groups, u = 0, d = h.length; u < d; u++) {
                            var f = h[u],
                                m = l[f.materialIndex];
                            if (m && m.visible) {
                                var g = o(t, m, a, b);
                                e.renderBufferDirect(i, null, s, g, t, f)
                            }
                        } else if (l.visible) {
                            var g = o(t, l, a, b);
                            e.renderBufferDirect(i, null, s, g, t, null)
                        }
                }
                for (var v = t.children, y = 0, x = v.length; y < x; y++) c(v[y], r, i, a)
            }
        }
        var l = e.context,
            d = e.state,
            p = new oe,
            f = new u,
            m = t.shadows,
            g = new i,
            v = new i(r.maxTextureSize, r.maxTextureSize),
            y = new h,
            b = new h,
            x = 1,
            w = 2,
            _ = 1 + (x | w),
            M = new Array(_),
            E = new Array(_),
            T = {},
            S = [new h(1, 0, 0), new h(-1, 0, 0), new h(0, 0, 1), new h(0, 0, -1), new h(0, 1, 0), new h(0, -1, 0)],
            A = [new h(0, 1, 0), new h(0, 1, 0), new h(0, 1, 0), new h(0, 1, 0), new h(0, 0, 1), new h(0, 0, -1)],
            P = [new a, new a, new a, new a, new a, new a],
            C = new ee;
        C.depthPacking = _s, C.clipping = !0;
        for (var L = Ns.distanceRGBA, R = ks.clone(L.uniforms), I = 0; I !== _; ++I) {
            var O = 0 != (I & x),
                k = 0 != (I & w),
                D = C.clone();
            D.morphTargets = O, D.skinning = k, M[I] = D;
            var N = new Q({
                defines: {
                    USE_SHADOWMAP: ""
                },
                uniforms: R,
                vertexShader: L.vertexShader,
                fragmentShader: L.fragmentShader,
                morphTargets: O,
                skinning: k,
                clipping: !0
            });
            E[I] = N
        }
        var B = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = mo, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(t, n) {
            if (!1 !== B.enabled && (!1 !== B.autoUpdate || !1 !== B.needsUpdate) && 0 !== m.length) {
                d.disable(l.BLEND), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (var r, i, o = 0, a = m.length; o < a; o++) {
                    var h = m[o],
                        u = h.shadow;
                    if (void 0 !== u) {
                        var x = u.camera,
                            w = u.matrix;
                        if (b.setFromMatrixPosition(h.matrixWorld), x.position.copy(b), g.copy(u.mapSize), g.min(v), h && h.isPointLight) {
                            r = 6, i = !0;
                            var _ = g.x,
                                M = g.y;
                            P[0].set(2 * _, M, _, M), P[1].set(0, M, _, M), P[2].set(3 * _, M, _, M), P[3].set(_, M, _, M), P[4].set(3 * _, 0, _, M), P[5].set(_, 0, _, M), g.x *= 4, g.y *= 2, w.makeTranslation(-b.x, -b.y, -b.z)
                        } else r = 1, i = !1, y.setFromMatrixPosition(h.target.matrixWorld), x.lookAt(y), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld), w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), w.multiply(x.projectionMatrix), w.multiply(x.matrixWorldInverse);
                        if (null === u.map) {
                            var E = {
                                minFilter: xa,
                                magFilter: xa,
                                format: za
                            };
                            u.map = new s(g.x, g.y, E), u.map.texture.name = h.name + ".shadowMap", x.updateProjectionMatrix()
                        }
                        u.isSpotLightShadow && u.update(h);
                        var T = u.map;
                        e.setRenderTarget(T), e.clear();
                        for (var C = 0; C < r; C++) {
                            if (i) {
                                y.copy(x.position), y.add(S[C]), x.up.copy(A[C]), x.lookAt(y), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld);
                                var L = P[C];
                                d.viewport(L)
                            }
                            f.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), p.setFromMatrix(f), c(t, n, x, i)
                        }
                    } else console.warn("THREE.WebGLShadowMap:", h, "has no shadow.")
                }
                var R = e.getClearColor(),
                    I = e.getClearAlpha();
                e.setClearColor(R, I), B.needsUpdate = !1
            }
        }
    }

    function se(e, t) {
        this.origin = void 0 !== e ? e : new h, this.direction = void 0 !== t ? t : new h
    }

    function ce(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || ce.DefaultOrder
    }

    function le() {
        this.mask = 1
    }

    function he() {
        function e() {
            i.setFromEuler(r, !1)
        }

        function t() {
            r.setFromQuaternion(i, void 0, !1)
        }
        Object.defineProperty(this, "id", {
            value: Us++
        }), this.uuid = Ms.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = he.DefaultUp.clone();
        var n = new h,
            r = new ce,
            i = new l,
            o = new h(1, 1, 1);
        r.onChange(e), i.onChange(t), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: n
            },
            rotation: {
                enumerable: !0,
                value: r
            },
            quaternion: {
                enumerable: !0,
                value: i
            },
            scale: {
                enumerable: !0,
                value: o
            },
            modelViewMatrix: {
                value: new u
            },
            normalMatrix: {
                value: new re
            }
        }), this.matrix = new u, this.matrixWorld = new u, this.matrixAutoUpdate = he.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new le, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function() {}, this.onAfterRender = function() {}
    }

    function ue(e, t) {
        this.start = void 0 !== e ? e : new h, this.end = void 0 !== t ? t : new h
    }

    function de(e, t, n) {
        this.a = void 0 !== e ? e : new h, this.b = void 0 !== t ? t : new h, this.c = void 0 !== n ? n : new h
    }

    function pe(e, t, n, r, i, o) {
        this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new h, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new q, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
    }

    function fe(e) {
        K.call(this), this.type = "MeshBasicMaterial", this.color = new q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
    }

    function me(e, t, n) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = Ms.generateUUID(), this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0
    }

    function ge(e, t) {
        me.call(this, new Int8Array(e), t)
    }

    function ve(e, t) {
        me.call(this, new Uint8Array(e), t)
    }

    function ye(e, t) {
        me.call(this, new Uint8ClampedArray(e), t)
    }

    function be(e, t) {
        me.call(this, new Int16Array(e), t)
    }

    function xe(e, t) {
        me.call(this, new Uint16Array(e), t)
    }

    function we(e, t) {
        me.call(this, new Int32Array(e), t)
    }

    function _e(e, t) {
        me.call(this, new Uint32Array(e), t)
    }

    function Me(e, t) {
        me.call(this, new Float32Array(e), t)
    }

    function Ee(e, t) {
        me.call(this, new Float64Array(e), t)
    }

    function Te() {
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Se(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
        return t
    }

    function Ae() {
        return Fs++
    }

    function Pe() {
        Object.defineProperty(this, "id", {
            value: Ae()
        }), this.uuid = Ms.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Ce() {
        Object.defineProperty(this, "id", {
            value: Ae()
        }), this.uuid = Ms.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }

    function Le(e, t) {
        he.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Ce, this.material = void 0 !== t ? t : new fe({
            color: 16777215 * Math.random()
        }), this.drawMode = hs, this.updateMorphTargets()
    }

    function Re(e, t, n, r, i, o) {
        Pe.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        }, this.fromBufferGeometry(new Ie(e, t, n, r, i, o)), this.mergeVertices()
    }

    function Ie(e, t, n, r, i, o) {
        function a(e, t, n, r, i, o, a, m, g, v, y) {
            var b, x, w = o / g,
                _ = a / v,
                M = o / 2,
                E = a / 2,
                T = m / 2,
                S = g + 1,
                A = v + 1,
                P = 0,
                C = 0,
                L = new h;
            for (x = 0; x < A; x++) {
                var R = x * _ - E;
                for (b = 0; b < S; b++) {
                    var I = b * w - M;
                    L[e] = I * r, L[t] = R * i, L[n] = T, l.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[n] = m > 0 ? 1 : -1, u.push(L.x, L.y, L.z), d.push(b / g), d.push(1 - x / v), P += 1
                }
            }
            for (x = 0; x < v; x++)
                for (b = 0; b < g; b++) {
                    var O = p + b + S * x,
                        k = p + b + S * (x + 1),
                        D = p + (b + 1) + S * (x + 1),
                        N = p + (b + 1) + S * x;
                    c.push(O, k, N), c.push(k, D, N), C += 6
                }
            s.addGroup(f, C, y), f += C, p += P
        }
        Ce.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        };
        var s = this;
        r = Math.floor(r) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1;
        var c = [],
            l = [],
            u = [],
            d = [],
            p = 0,
            f = 0;
        a("z", "y", "x", -1, -1, n, t, e, o, i, 0), a("z", "y", "x", 1, -1, n, t, -e, o, i, 1), a("x", "z", "y", 1, 1, e, n, t, r, o, 2), a("x", "z", "y", 1, -1, e, n, -t, r, o, 3), a("x", "y", "z", 1, -1, e, t, n, r, i, 4), a("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(c), this.addAttribute("position", new Me(l, 3)), this.addAttribute("normal", new Me(u, 3)), this.addAttribute("uv", new Me(d, 2))
    }

    function Oe(e, t, n, r) {
        Pe.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        }, this.fromBufferGeometry(new ke(e, t, n, r)), this.mergeVertices()
    }

    function ke(e, t, n, r) {
        Ce.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        };
        var i, o, a = e / 2,
            s = t / 2,
            c = Math.floor(n) || 1,
            l = Math.floor(r) || 1,
            h = c + 1,
            u = l + 1,
            d = e / c,
            p = t / l,
            f = [],
            m = [],
            g = [],
            v = [];
        for (o = 0; o < u; o++) {
            var y = o * p - s;
            for (i = 0; i < h; i++) {
                var b = i * d - a;
                m.push(b, -y, 0), g.push(0, 0, 1), v.push(i / c), v.push(1 - o / l)
            }
        }
        for (o = 0; o < l; o++)
            for (i = 0; i < c; i++) {
                var x = i + h * o,
                    w = i + h * (o + 1),
                    _ = i + 1 + h * (o + 1),
                    M = i + 1 + h * o;
                f.push(x, w, M), f.push(w, _, M)
            }
        this.setIndex(f), this.addAttribute("position", new Me(m, 3)), this.addAttribute("normal", new Me(g, 3)), this.addAttribute("uv", new Me(v, 2))
    }

    function De() {
        he.call(this), this.type = "Camera", this.matrixWorldInverse = new u, this.projectionMatrix = new u
    }

    function Ne(e, t, n, r) {
        De.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function Be(e, t, n, r, i, o) {
        De.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function Ue(e) {
        function t(t, n) {
            var r = t.array,
                i = t.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW,
                o = e.createBuffer();
            e.bindBuffer(n, o), e.bufferData(n, r, i), t.onUploadCallback();
            var a = e.FLOAT;
            return r instanceof Float32Array ? a = e.FLOAT : r instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : r instanceof Uint16Array ? a = e.UNSIGNED_SHORT : r instanceof Int16Array ? a = e.SHORT : r instanceof Uint32Array ? a = e.UNSIGNED_INT : r instanceof Int32Array ? a = e.INT : r instanceof Int8Array ? a = e.BYTE : r instanceof Uint8Array && (a = e.UNSIGNED_BYTE), {
                buffer: o,
                type: a,
                bytesPerElement: r.BYTES_PER_ELEMENT,
                version: t.version
            }
        }

        function n(t, n, r) {
            var i = n.array,
                o = n.updateRange;
            e.bindBuffer(r, t), !1 === n.dynamic ? e.bufferData(r, i, e.STATIC_DRAW) : -1 === o.count ? e.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = 0)
        }

        function r(e) {
            return e.isInterleavedBufferAttribute && (e = e.data), a[e.uuid]
        }

        function i(t) {
            var n = a[t.uuid];
            n && (e.deleteBuffer(n.buffer), delete a[t.uuid])
        }

        function o(e, r) {
            e.isInterleavedBufferAttribute && (e = e.data);
            var i = a[e.uuid];
            void 0 === i ? a[e.uuid] = t(e, r) : i.version < e.version && (n(i.buffer, e, r), i.version = e.version)
        }
        var a = {};
        return {
            get: r,
            remove: i,
            update: o
        }
    }

    function Fe(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function ze(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function je() {
        function e() {
            o = -1, s = -1
        }

        function t(e, t, n, r, c) {
            var l, h;
            n.transparent ? (l = a, h = ++s) : (l = i, h = ++o);
            var u = l[h];
            u ? (u.id = e.id, u.object = e, u.geometry = t, u.material = n, u.program = n.program, u.renderOrder = e.renderOrder, u.z = r, u.group = c) : (u = {
                id: e.id,
                object: e,
                geometry: t,
                material: n,
                program: n.program,
                renderOrder: e.renderOrder,
                z: r,
                group: c
            }, l.push(u))
        }

        function n() {
            i.length = o + 1, a.length = s + 1
        }

        function r() {
            i.sort(Fe), a.sort(ze)
        }
        var i = [],
            o = -1,
            a = [],
            s = -1;
        return {
            opaque: i,
            transparent: a,
            init: e,
            push: t,
            finish: n,
            sort: r
        }
    }

    function He() {
        function e(e, t) {
            var r = e.id + "," + t.id,
                i = n[r];
            return void 0 === i && (i = new je, n[r] = i), i
        }

        function t() {
            n = {}
        }
        var n = {};
        return {
            get: e,
            dispose: t
        }
    }

    function Ve(e, t, n) {
        function r(e) {
            s = e
        }

        function i(n) {
            n.array instanceof Uint32Array && t.get("OES_element_index_uint") ? (c = e.UNSIGNED_INT, l = 4) : n.array instanceof Uint16Array ? (c = e.UNSIGNED_SHORT, l = 2) : (c = e.UNSIGNED_BYTE, l = 1)
        }

        function o(t, r) {
            e.drawElements(s, r, c, t * l), n.calls++, n.vertices += r, s === e.TRIANGLES && (n.faces += r / 3)
        }

        function a(r, i, o) {
            var a = t.get("ANGLE_instanced_arrays");
            if (null === a) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            a.drawElementsInstancedANGLE(s, o, c, i * l, r.maxInstancedCount), n.calls++, n.vertices += o * r.maxInstancedCount, s === e.TRIANGLES && (n.faces += r.maxInstancedCount * o / 3)
        }
        var s, c, l;
        this.setMode = r, this.setIndex = i, this.render = o, this.renderInstances = a
    }

    function Ge(e, t, n) {
        function r(e) {
            a = e
        }

        function i(t, r) {
            e.drawArrays(a, t, r), n.calls++, n.vertices += r, a === e.TRIANGLES && (n.faces += r / 3)
        }

        function o(r, i, o) {
            var s = t.get("ANGLE_instanced_arrays");
            if (null === s) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var c = r.attributes.position;
            c.isInterleavedBufferAttribute ? (o = c.data.count, s.drawArraysInstancedANGLE(a, 0, o, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(a, i, o, r.maxInstancedCount), n.calls++, n.vertices += o * r.maxInstancedCount, a === e.TRIANGLES && (n.faces += r.maxInstancedCount * o / 3)
        }
        var a;
        this.setMode = r, this.render = i, this.renderInstances = o
    }

    function We(e, t, n) {
        function r(e) {
            var i = e.target,
                o = s[i.id];
            null !== o.index && t.remove(o.index);
            for (var a in o.attributes) t.remove(o.attributes[a]);
            i.removeEventListener("dispose", r), delete s[i.id];
            var l = c[i.id];
            l && (t.remove(l), delete c[i.id]), l = c[o.id], l && (t.remove(l), delete c[o.id]), n.geometries--
        }

        function i(e, t) {
            var i = s[t.id];
            return i || (t.addEventListener("dispose", r), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Ce).setFromObject(e)), i = t._bufferGeometry), s[t.id] = i, n.geometries++, i)
        }

        function o(n) {
            var r = n.index,
                i = n.attributes;
            null !== r && t.update(r, e.ELEMENT_ARRAY_BUFFER);
            for (var o in i) t.update(i[o], e.ARRAY_BUFFER);
            var a = n.morphAttributes;
            for (var o in a)
                for (var s = a[o], c = 0, l = s.length; c < l; c++) t.update(s[c], e.ARRAY_BUFFER)
        }

        function a(n) {
            var r = c[n.id];
            if (r) return r;
            var i = [],
                o = n.index,
                a = n.attributes;
            if (null !== o)
                for (var s = o.array, l = 0, h = s.length; l < h; l += 3) {
                    var u = s[l + 0],
                        d = s[l + 1],
                        p = s[l + 2];
                    i.push(u, d, d, p, p, u)
                } else
                    for (var s = a.position.array, l = 0, h = s.length / 3 - 1; l < h; l += 3) {
                        var u = l + 0,
                            d = l + 1,
                            p = l + 2;
                        i.push(u, d, d, p, p, u)
                    }
            return r = new(Se(i) > 65535 ? _e : xe)(i, 1), t.update(r, e.ELEMENT_ARRAY_BUFFER), c[n.id] = r, r
        }
        var s = {},
            c = {};
        return {
            get: i,
            update: o,
            getWireframeAttribute: a
        }
    }

    function $e() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                var n;
                switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new h,
                            color: new q,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new h,
                            direction: new h,
                            color: new q,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new h,
                            color: new q,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new h,
                            skyColor: new q,
                            groundColor: new q
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new q,
                            position: new h,
                            halfWidth: new h,
                            halfHeight: new h
                        }
                }
                return e[t.id] = n, n
            }
        }
    }

    function Xe(e, t, n) {
        function r(e) {
            var r = n.frame,
                i = e.geometry,
                a = t.get(e, i);
            return o[a.id] !== r && (i.isGeometry && a.updateFromObject(e), t.update(a), o[a.id] = r), a
        }

        function i() {
            o = {}
        }
        var o = {};
        return {
            update: r,
            clear: i
        }
    }

    function qe(e) {
        for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
        return t.join("\n")
    }

    function Ye(e, t, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, n), e.compileShader(r), !1 === e.getShaderParameter(r, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(r), qe(n)), r
    }

    function Ze(e) {
        switch (e) {
            case ps:
                return ["Linear", "( value )"];
            case fs:
                return ["sRGB", "( value )"];
            case gs:
                return ["RGBE", "( value )"];
            case ys:
                return ["RGBM", "( value, 7.0 )"];
            case bs:
                return ["RGBM", "( value, 16.0 )"];
            case xs:
                return ["RGBD", "( value, 256.0 )"];
            case ms:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw new Error("unsupported encoding: " + e)
        }
    }

    function Je(e, t) {
        var n = Ze(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Ke(e, t) {
        var n = Ze(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function Qe(e, t) {
        var n;
        switch (t) {
            case oa:
                n = "Linear";
                break;
            case aa:
                n = "Reinhard";
                break;
            case sa:
                n = "Uncharted2";
                break;
            case ca:
                n = "OptimizedCineon";
                break;
            default:
                throw new Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function et(e, t, n) {
        return e = e || {}, [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(rt).join("\n")
    }

    function tt(e) {
        var t = [];
        for (var n in e) {
            var r = e[n];
            !1 !== r && t.push("#define " + n + " " + r)
        }
        return t.join("\n")
    }

    function nt(e, t, n) {
        for (var r = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; o < i; o++) {
            var a = e.getActiveAttrib(t, o),
                s = a.name;
            r[s] = e.getAttribLocation(t, s)
        }
        return r
    }

    function rt(e) {
        return "" !== e
    }

    function it(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function ot(e) {
        function t(e, t) {
            var n = Ds[t];
            if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
            return ot(n)
        }
        var n = /^[ \t]*#include +<([\w\d.]+)>/gm;
        return e.replace(n, t)
    }

    function at(e) {
        function t(e, t, n, r) {
            for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]");
            return i
        }
        var n = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return e.replace(n, t)
    }

    function st(e, t, n, r) {
        var i = e.context,
            o = n.extensions,
            a = n.defines,
            s = n.__webglShader.vertexShader,
            c = n.__webglShader.fragmentShader,
            l = "SHADOWMAP_TYPE_BASIC";
        r.shadowMapType === mo ? l = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === go && (l = "SHADOWMAP_TYPE_PCF_SOFT");
        var h = "ENVMAP_TYPE_CUBE",
            u = "ENVMAP_MODE_REFLECTION",
            d = "ENVMAP_BLENDING_MULTIPLY";
        if (r.envMap) {
            switch (n.envMap.mapping) {
                case ha:
                case ua:
                    h = "ENVMAP_TYPE_CUBE";
                    break;
                case ma:
                case ga:
                    h = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case da:
                case pa:
                    h = "ENVMAP_TYPE_EQUIREC";
                    break;
                case fa:
                    h = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case ua:
                case pa:
                    u = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case ta:
                    d = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case na:
                    d = "ENVMAP_BLENDING_MIX";
                    break;
                case ra:
                    d = "ENVMAP_BLENDING_ADD"
            }
        }
        var p, f, m = e.gammaFactor > 0 ? e.gammaFactor : 1,
            g = et(o, r, e.extensions),
            v = tt(a),
            y = i.createProgram();
        n.isRawShaderMaterial ? (p = [v, "\n"].filter(rt).join("\n"), f = [g, v, "\n"].filter(rt).join("\n")) : (p = ["precision " + r.precision + " float;", "precision " + r.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, v, r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + u : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.vertexColors ? "#define USE_COLOR" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + r.numClippingPlanes, r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(rt).join("\n"), f = [g, "precision " + r.precision + " float;", "precision " + r.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, v, r.alphaTest ? "#define ALPHATEST " + r.alphaTest : "", "#define GAMMA_FACTOR " + m, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + h : "", r.envMap ? "#define " + u : "", r.envMap ? "#define " + d : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.vertexColors ? "#define USE_COLOR" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + r.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (r.numClippingPlanes - r.numClipIntersection), r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + l : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", r.envMap && e.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", r.toneMapping !== ia ? "#define TONE_MAPPING" : "", r.toneMapping !== ia ? Ds.tonemapping_pars_fragment : "", r.toneMapping !== ia ? Qe("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.outputEncoding || r.mapEncoding || r.envMapEncoding || r.emissiveMapEncoding ? Ds.encodings_pars_fragment : "", r.mapEncoding ? Je("mapTexelToLinear", r.mapEncoding) : "", r.envMapEncoding ? Je("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMapEncoding ? Je("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.outputEncoding ? Ke("linearToOutputTexel", r.outputEncoding) : "", r.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(rt).join("\n")), s = ot(s, r), s = it(s, r), c = ot(c, r), c = it(c, r), n.isShaderMaterial || (s = at(s), c = at(c));
        var b = p + s,
            x = f + c,
            w = Ye(i, i.VERTEX_SHADER, b),
            _ = Ye(i, i.FRAGMENT_SHADER, x);
        i.attachShader(y, w), i.attachShader(y, _), void 0 !== n.index0AttributeName ? i.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === r.morphTargets && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y);
        var M = i.getProgramInfoLog(y),
            E = i.getShaderInfoLog(w),
            T = i.getShaderInfoLog(_),
            S = !0,
            A = !0;
        !1 === i.getProgramParameter(y, i.LINK_STATUS) ? (S = !1, console.error("THREE.WebGLProgram: shader error: ", i.getError(), "gl.VALIDATE_STATUS", i.getProgramParameter(y, i.VALIDATE_STATUS), "gl.getProgramInfoLog", M, E, T)) : "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== E && "" !== T || (A = !1), A && (this.diagnostics = {
            runnable: S,
            material: n,
            programLog: M,
            vertexShader: {
                log: E,
                prefix: p
            },
            fragmentShader: {
                log: T,
                prefix: f
            }
        }), i.deleteShader(w), i.deleteShader(_);
        var P;
        this.getUniforms = function() {
            return void 0 === P && (P = new X(i, y, e)), P
        };
        var C;
        return this.getAttributes = function() {
            return void 0 === C && (C = nt(i, y)), C
        }, this.destroy = function() {
            i.deleteProgram(y), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.id = zs++, this.code = t, this.usedTimes = 1, this.program = y, this.vertexShader = w, this.fragmentShader = _, this
    }

    function ct(e, t) {
        function n(e) {
            var n = e.skeleton,
                r = n.bones;
            if (t.floatVertexTextures) return 1024;
            var i = t.maxVertexUniforms,
                o = Math.floor((i - 20) / 4),
                a = Math.min(o, r.length);
            return a < r.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + r.length + " bones. This GPU supports " + a + "."), 0) : a
        }

        function r(e, t) {
            var n;
            return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = ps, n === ps && t && (n = ms), n
        }
        var i = [],
            o = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            },
            a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        this.getParameters = function(i, a, s, c, l, h) {
            var u = o[i.type],
                d = h.isSkinnedMesh ? n(h) : 0,
                p = e.getPrecision();
            null !== i.precision && (p = t.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", p, "instead.");
            var f = e.getRenderTarget();
            return {
                shaderID: u,
                precision: p,
                supportsVertexTextures: t.vertexTextures,
                outputEncoding: r(f ? f.texture : null, e.gammaOutput),
                map: !!i.map,
                mapEncoding: r(i.map, e.gammaInput),
                envMap: !!i.envMap,
                envMapMode: i.envMap && i.envMap.mapping,
                envMapEncoding: r(i.envMap, e.gammaInput),
                envMapCubeUV: !!i.envMap && (i.envMap.mapping === ma || i.envMap.mapping === ga),
                lightMap: !!i.lightMap,
                aoMap: !!i.aoMap,
                emissiveMap: !!i.emissiveMap,
                emissiveMapEncoding: r(i.emissiveMap, e.gammaInput),
                bumpMap: !!i.bumpMap,
                normalMap: !!i.normalMap,
                displacementMap: !!i.displacementMap,
                roughnessMap: !!i.roughnessMap,
                metalnessMap: !!i.metalnessMap,
                specularMap: !!i.specularMap,
                alphaMap: !!i.alphaMap,
                gradientMap: !!i.gradientMap,
                combine: i.combine,
                vertexColors: i.vertexColors,
                fog: !!s,
                useFog: i.fog,
                fogExp: s && s.isFogExp2,
                flatShading: i.shading === xo,
                sizeAttenuation: i.sizeAttenuation,
                logarithmicDepthBuffer: t.logarithmicDepthBuffer,
                skinning: i.skinning && d > 0,
                maxBones: d,
                useVertexTexture: t.floatVertexTextures,
                morphTargets: i.morphTargets,
                morphNormals: i.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: a.directional.length,
                numPointLights: a.point.length,
                numSpotLights: a.spot.length,
                numRectAreaLights: a.rectArea.length,
                numHemiLights: a.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: l,
                dithering: i.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && a.shadows.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: i.premultipliedAlpha,
                alphaTest: i.alphaTest,
                doubleSided: i.side === bo,
                flipSided: i.side === yo,
                depthPacking: void 0 !== i.depthPacking && i.depthPacking
            }
        }, this.getProgramCode = function(e, t) {
            var n = [];
            if (t.shaderID ? n.push(t.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                for (var r in e.defines) n.push(r), n.push(e.defines[r]);
            for (var i = 0; i < a.length; i++) n.push(t[a[i]]);
            return n.join()
        }, this.acquireProgram = function(t, n, r) {
            for (var o, a = 0, s = i.length; a < s; a++) {
                var c = i[a];
                if (c.code === r) {
                    o = c, ++o.usedTimes;
                    break
                }
            }
            return void 0 === o && (o = new st(e, r, t, n), i.push(o)), o
        }, this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = i.indexOf(e);
                i[t] = i[i.length - 1], i.pop(), e.destroy()
            }
        }, this.programs = i
    }

    function lt(e, t, n, r, i, o, a) {
        function s(e, t) {
            if (e.width > t || e.height > t) {
                var n = t / Math.max(e.width, e.height),
                    r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                r.width = Math.floor(e.width * n), r.height = Math.floor(e.height * n);
                return r.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e), r
            }
            return e
        }

        function c(e) {
            return Ms.isPowerOfTwo(e.width) && Ms.isPowerOfTwo(e.height)
        }

        function l(e) {
            if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) {
                var t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                t.width = Ms.nearestPowerOfTwo(e.width), t.height = Ms.nearestPowerOfTwo(e.height);
                return t.getContext("2d").drawImage(e, 0, 0, t.width, t.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + t.width + "x" + t.height, e), t
            }
            return e
        }

        function h(e) {
            return e.wrapS !== ya || e.wrapT !== ya || e.minFilter !== xa && e.minFilter !== Ma
        }

        function u(t) {
            return t === xa || t === wa || t === _a ? e.NEAREST : e.LINEAR
        }

        function d(e) {
            var t = e.target;
            t.removeEventListener("dispose", d), f(t), a.textures--
        }

        function p(e) {
            var t = e.target;
            t.removeEventListener("dispose", p), m(t), a.textures--
        }

        function f(t) {
            var n = r.get(t);
            if (t.image && n.__image__webglTextureCube) e.deleteTexture(n.__image__webglTextureCube);
            else {
                if (void 0 === n.__webglInit) return;
                e.deleteTexture(n.__webglTexture)
            }
            r.remove(t)
        }

        function m(t) {
            var n = r.get(t),
                i = r.get(t.texture);
            if (t) {
                if (void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                    for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                r.remove(t.texture), r.remove(t)
            }
        }

        function g(t, i) {
            var o = r.get(t);
            if (t.version > 0 && o.__version !== t.version) {
                var a = t.image;
                if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", t);
                else {
                    if (!1 !== a.complete) return void x(o, t, i);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", t)
                }
            }
            n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_2D, o.__webglTexture)
        }

        function v(t, l) {
            var h = r.get(t);
            if (6 === t.image.length)
                if (t.version > 0 && h.__version !== t.version) {
                    h.__image__webglTextureCube || (t.addEventListener("dispose", d), h.__image__webglTextureCube = e.createTexture(), a.textures++), n.activeTexture(e.TEXTURE0 + l), n.bindTexture(e.TEXTURE_CUBE_MAP, h.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY);
                    for (var u = t && t.isCompressedTexture, p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; m < 6; m++) f[m] = u || p ? p ? t.image[m].image : t.image[m] : s(t.image[m], i.maxCubemapSize);
                    var g = f[0],
                        v = c(g),
                        y = o(t.format),
                        x = o(t.type);
                    b(e.TEXTURE_CUBE_MAP, t, v);
                    for (var m = 0; m < 6; m++)
                        if (u)
                            for (var w, _ = f[m].mipmaps, M = 0, E = _.length; M < E; M++) w = _[M], t.format !== za && t.format !== Fa ? n.getCompressedTextureFormats().indexOf(y) > -1 ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, M, y, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, M, y, w.width, w.height, 0, y, x, w.data);
                        else p ? n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, f[m].width, f[m].height, 0, y, x, f[m].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, y, x, f[m]);
                    t.generateMipmaps && v && e.generateMipmap(e.TEXTURE_CUBE_MAP), h.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else n.activeTexture(e.TEXTURE0 + l), n.bindTexture(e.TEXTURE_CUBE_MAP, h.__image__webglTextureCube)
        }

        function y(t, i) {
            n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, r.get(t).__webglTexture)
        }

        function b(n, a, s) {
            var c;
            if (s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, o(a.wrapS)), e.texParameteri(n, e.TEXTURE_WRAP_T, o(a.wrapT)), e.texParameteri(n, e.TEXTURE_MAG_FILTER, o(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, o(a.minFilter))) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), a.wrapS === ya && a.wrapT === ya || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), e.texParameteri(n, e.TEXTURE_MAG_FILTER, u(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, u(a.minFilter)), a.minFilter !== xa && a.minFilter !== Ma && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), c = t.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Ia && null === t.get("OES_texture_float_linear")) return;
                if (a.type === Oa && null === t.get("OES_texture_half_float_linear")) return;
                (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function x(t, r, u) {
            void 0 === t.__webglInit && (t.__webglInit = !0, r.addEventListener("dispose", d), t.__webglTexture = e.createTexture(), a.textures++), n.activeTexture(e.TEXTURE0 + u), n.bindTexture(e.TEXTURE_2D, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment);
            var p = s(r.image, i.maxTextureSize);
            h(r) && !1 === c(p) && (p = l(p));
            var f = c(p),
                m = o(r.format),
                g = o(r.type);
            b(e.TEXTURE_2D, r, f);
            var v, y = r.mipmaps;
            if (r.isDepthTexture) {
                var x = e.DEPTH_COMPONENT;
                if (r.type === Ia) {
                    if (!A) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    x = e.DEPTH_COMPONENT32F
                } else A && (x = e.DEPTH_COMPONENT16);
                r.format === Ga && x === e.DEPTH_COMPONENT && r.type !== Ca && r.type !== Ra && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Ca, g = o(r.type)), r.format === Wa && (x = e.DEPTH_STENCIL, r.type !== Ba && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Ba, g = o(r.type))), n.texImage2D(e.TEXTURE_2D, 0, x, p.width, p.height, 0, m, g, null)
            } else if (r.isDataTexture)
                if (y.length > 0 && f) {
                    for (var w = 0, _ = y.length; w < _; w++) v = y[w], n.texImage2D(e.TEXTURE_2D, w, m, v.width, v.height, 0, m, g, v.data);
                    r.generateMipmaps = !1
                } else n.texImage2D(e.TEXTURE_2D, 0, m, p.width, p.height, 0, m, g, p.data);
            else if (r.isCompressedTexture)
                for (var w = 0, _ = y.length; w < _; w++) v = y[w], r.format !== za && r.format !== Fa ? n.getCompressedTextureFormats().indexOf(m) > -1 ? n.compressedTexImage2D(e.TEXTURE_2D, w, m, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, w, m, v.width, v.height, 0, m, g, v.data);
            else if (y.length > 0 && f) {
                for (var w = 0, _ = y.length; w < _; w++) v = y[w], n.texImage2D(e.TEXTURE_2D, w, m, m, g, v);
                r.generateMipmaps = !1
            } else n.texImage2D(e.TEXTURE_2D, 0, m, m, g, p);
            r.generateMipmaps && f && e.generateMipmap(e.TEXTURE_2D), t.__version = r.version, r.onUpdate && r.onUpdate(r)
        }

        function w(t, i, a, s) {
            var c = o(i.texture.format),
                l = o(i.texture.type);
            n.texImage2D(s, 0, c, i.width, i.height, 0, c, l, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function _(t, n) {
            e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : n.depthBuffer && n.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, n.width, n.height), e.bindRenderbuffer(e.RENDERBUFFER, null)
        }

        function M(t, n) {
            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported!");
            if (e.bindFramebuffer(e.FRAMEBUFFER, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
            var i = r.get(n.depthTexture).__webglTexture;
            if (n.depthTexture.format === Ga) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, i, 0);
            else {
                if (n.depthTexture.format !== Wa) throw new Error("Unknown depthTexture format");
                e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, i, 0)
            }
        }

        function E(t) {
            var n = r.get(t),
                i = !0 === t.isWebGLRenderTargetCube;
            if (t.depthTexture) {
                if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                M(n.__webglFramebuffer, t)
            } else if (i) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++) e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = e.createRenderbuffer(), _(n.__webglDepthbuffer[o], t)
            } else e.bindFramebuffer(e.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), _(n.__webglDepthbuffer, t);
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }

        function T(t) {
            var i = r.get(t),
                o = r.get(t.texture);
            t.addEventListener("dispose", p), o.__webglTexture = e.createTexture(), a.textures++;
            var s = !0 === t.isWebGLRenderTargetCube,
                l = c(t);
            if (s) {
                i.__webglFramebuffer = [];
                for (var h = 0; h < 6; h++) i.__webglFramebuffer[h] = e.createFramebuffer()
            } else i.__webglFramebuffer = e.createFramebuffer();
            if (s) {
                n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture), b(e.TEXTURE_CUBE_MAP, t.texture, l);
                for (var h = 0; h < 6; h++) w(i.__webglFramebuffer[h], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + h);
                t.texture.generateMipmaps && l && e.generateMipmap(e.TEXTURE_CUBE_MAP), n.bindTexture(e.TEXTURE_CUBE_MAP, null)
            } else n.bindTexture(e.TEXTURE_2D, o.__webglTexture), b(e.TEXTURE_2D, t.texture, l), w(i.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), t.texture.generateMipmaps && l && e.generateMipmap(e.TEXTURE_2D), n.bindTexture(e.TEXTURE_2D, null);
            t.depthBuffer && E(t)
        }

        function S(t) {
            var i = t.texture;
            if (i.generateMipmaps && c(t) && i.minFilter !== xa && i.minFilter !== Ma) {
                var o = t && t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                    a = r.get(i).__webglTexture;
                n.bindTexture(o, a), e.generateMipmap(o), n.bindTexture(o, null)
            }
        }
        var A = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext;
        this.setTexture2D = g, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = T, this.updateRenderTargetMipmap = S
    }

    function ht() {
        function e(e) {
            var t = e.uuid,
                n = r[t];
            return void 0 === n && (n = {}, r[t] = n), n
        }

        function t(e) {
            delete r[e.uuid]
        }

        function n() {
            r = {}
        }
        var r = {};
        return {
            get: e,
            remove: t,
            clear: n
        }
    }

    function ut(e, t, n) {
        function r() {
            var t = !1,
                n = new a,
                r = null,
                i = new a;
            return {
                setMask: function(n) {
                    r === n || t || (e.colorMask(n, n, n, n), r = n)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, r, o, a, s) {
                    !0 === s && (t *= a, r *= a, o *= a), n.set(t, r, o, a), !1 === i.equals(n) && (e.clearColor(t, r, o, a), i.copy(n))
                },
                reset: function() {
                    t = !1, r = null, i.set(0, 0, 0, 1)
                }
            }
        }

        function i() {
            var t = !1,
                n = null,
                r = null,
                i = null;
            return {
                setTest: function(t) {
                    t ? p(e.DEPTH_TEST) : f(e.DEPTH_TEST)
                },
                setMask: function(r) {
                    n === r || t || (e.depthMask(r), n = r)
                },
                setFunc: function(t) {
                    if (r !== t) {
                        if (t) switch (t) {
                            case Xo:
                                e.depthFunc(e.NEVER);
                                break;
                            case qo:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case Yo:
                                e.depthFunc(e.LESS);
                                break;
                            case Zo:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case Jo:
                                e.depthFunc(e.EQUAL);
                                break;
                            case Ko:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case Qo:
                                e.depthFunc(e.GREATER);
                                break;
                            case ea:
                                e.depthFunc(e.NOTEQUAL);
                                break;
                            default:
                                e.depthFunc(e.LEQUAL)
                        } else e.depthFunc(e.LEQUAL);
                        r = t
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    i !== t && (e.clearDepth(t), i = t)
                },
                reset: function() {
                    t = !1, n = null, r = null, i = null
                }
            }
        }

        function o() {
            var t = !1,
                n = null,
                r = null,
                i = null,
                o = null,
                a = null,
                s = null,
                c = null,
                l = null;
            return {
                setTest: function(t) {
                    t ? p(e.STENCIL_TEST) : f(e.STENCIL_TEST)
                },
                setMask: function(r) {
                    n === r || t || (e.stencilMask(r), n = r)
                },
                setFunc: function(t, n, a) {
                    r === t && i === n && o === a || (e.stencilFunc(t, n, a), r = t, i = n, o = a)
                },
                setOp: function(t, n, r) {
                    a === t && s === n && c === r || (e.stencilOp(t, n, r), a = t, s = n, c = r)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    l !== t && (e.clearStencil(t), l = t)
                },
                reset: function() {
                    t = !1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, l = null
                }
            }
        }

        function s(t, n, r) {
            var i = new Uint8Array(4),
                o = e.createTexture();
            e.bindTexture(t, o), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
            for (var a = 0; a < r; a++) e.texImage2D(n + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, i);
            return o
        }

        function c() {
            R.setClear(0, 0, 0, 1), I.setClear(1), O.setClear(0), p(e.DEPTH_TEST), I.setFunc(Zo), y(!1), b(co), p(e.CULL_FACE), p(e.BLEND), g(So)
        }

        function l() {
            for (var e = 0, t = D.length; e < t; e++) D[e] = 0
        }

        function h(n) {
            if (D[n] = 1, 0 === N[n] && (e.enableVertexAttribArray(n), N[n] = 1), 0 !== B[n]) {
                t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0), B[n] = 0
            }
        }

        function u(n, r) {
            if (D[n] = 1, 0 === N[n] && (e.enableVertexAttribArray(n), N[n] = 1), B[n] !== r) {
                t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, r), B[n] = r
            }
        }

        function d() {
            for (var t = 0, n = N.length; t !== n; ++t) N[t] !== D[t] && (e.disableVertexAttribArray(t), N[t] = 0)
        }

        function p(t) {
            !0 !== U[t] && (e.enable(t), U[t] = !0)
        }

        function f(t) {
            !1 !== U[t] && (e.disable(t), U[t] = !1)
        }

        function m() {
            if (null === F && (F = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1")))
                for (var n = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++) F.push(n[r]);
            return F
        }

        function g(t, r, i, o, a, s, c, l) {
            t !== To ? p(e.BLEND) : f(e.BLEND), t === z && l === X || (t === Ao ? l ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : t === Po ? l ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : t === Co ? l ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : l ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)), z = t, X = l), t === Lo ? (a = a || r, s = s || i, c = c || o, r === j && a === G || (e.blendEquationSeparate(n(r), n(a)), j = r, G = a), i === H && o === V && s === W && c === $ || (e.blendFuncSeparate(n(i), n(o), n(s), n(c)), H = i, V = o, W = s, $ = c)) : (j = null, H = null, V = null, G = null, W = null, $ = null)
        }

        function v(t) {
            t.side === bo ? f(e.CULL_FACE) : p(e.CULL_FACE), y(t.side === yo), !0 === t.transparent ? g(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : g(To), I.setFunc(t.depthFunc), I.setTest(t.depthTest), I.setMask(t.depthWrite), R.setMask(t.colorWrite), w(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
        }

        function y(t) {
            q !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), q = t)
        }

        function b(t) {
            t !== so ? (p(e.CULL_FACE), t !== Y && (t === co ? e.cullFace(e.BACK) : t === lo ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : f(e.CULL_FACE), Y = t
        }

        function x(t) {
            t !== Z && (ne && e.lineWidth(t), Z = t)
        }

        function w(t, n, r) {
            t ? (p(e.POLYGON_OFFSET_FILL), J === n && K === r || (e.polygonOffset(n, r), J = n, K = r)) : f(e.POLYGON_OFFSET_FILL)
        }

        function _() {
            return Q
        }

        function M(t) {
            Q = t, t ? p(e.SCISSOR_TEST) : f(e.SCISSOR_TEST)
        }

        function E(t) {
            void 0 === t && (t = e.TEXTURE0 + ee - 1), re !== t && (e.activeTexture(t), re = t)
        }

        function T(t, n) {
            null === re && E();
            var r = ie[re];
            void 0 === r && (r = {
                type: void 0,
                texture: void 0
            }, ie[re] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || se[t]), r.type = t, r.texture = n)
        }

        function S() {
            try {
                e.compressedTexImage2D.apply(e, arguments)
            } catch (e) {
                console.error(e)
            }
        }

        function A() {
            try {
                e.texImage2D.apply(e, arguments)
            } catch (e) {
                console.error(e)
            }
        }

        function P(t) {
            !1 === oe.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), oe.copy(t))
        }

        function C(t) {
            !1 === ae.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ae.copy(t))
        }

        function L() {
            for (var t = 0; t < N.length; t++) 1 === N[t] && (e.disableVertexAttribArray(t), N[t] = 0);
            U = {}, F = null, re = null, ie = {}, z = null, q = null, Y = null, R.reset(), I.reset(), O.reset()
        }
        var R = new r,
            I = new i,
            O = new o,
            k = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            D = new Uint8Array(k),
            N = new Uint8Array(k),
            B = new Uint8Array(k),
            U = {},
            F = null,
            z = null,
            j = null,
            H = null,
            V = null,
            G = null,
            W = null,
            $ = null,
            X = !1,
            q = null,
            Y = null,
            Z = null,
            J = null,
            K = null,
            Q = null,
            ee = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            te = parseFloat(/^WebGL\ ([0-9])/.exec(e.getParameter(e.VERSION))[1]),
            ne = parseFloat(te) >= 1,
            re = null,
            ie = {},
            oe = new a,
            ae = new a,
            se = {};
        return se[e.TEXTURE_2D] = s(e.TEXTURE_2D, e.TEXTURE_2D, 1), se[e.TEXTURE_CUBE_MAP] = s(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
            buffers: {
                color: R,
                depth: I,
                stencil: O
            },
            init: c,
            initAttributes: l,
            enableAttribute: h,
            enableAttributeAndDivisor: u,
            disableUnusedAttributes: d,
            enable: p,
            disable: f,
            getCompressedTextureFormats: m,
            setBlending: g,
            setMaterial: v,
            setFlipSided: y,
            setCullFace: b,
            setLineWidth: x,
            setPolygonOffset: w,
            getScissorTest: _,
            setScissorTest: M,
            activeTexture: E,
            bindTexture: T,
            compressedTexImage2D: S,
            texImage2D: A,
            scissor: P,
            viewport: C,
            reset: L
        }
    }

    function dt(e, t, n) {
        function r() {
            if (void 0 !== o) return o;
            var n = t.get("EXT_texture_filter_anisotropic");
            return o = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        }

        function i(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        var o, a = void 0 !== n.precision ? n.precision : "highp",
            s = i(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
        var c = !0 === n.logarithmicDepthBuffer && !!t.get("EXT_frag_depth"),
            l = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            u = e.getParameter(e.MAX_TEXTURE_SIZE),
            d = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = e.getParameter(e.MAX_VERTEX_ATTRIBS),
            f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
            m = e.getParameter(e.MAX_VARYING_VECTORS),
            g = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = h > 0,
            y = !!t.get("OES_texture_float");
        return {
            getMaxAnisotropy: r,
            getMaxPrecision: i,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: l,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y
        }
    }

    function pt(e) {
        var t = {};
        return {
            get: function(n) {
                if (void 0 !== t[n]) return t[n];
                var r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    case "WEBGL_compressed_texture_etc1":
                        r = e.getExtension("WEBGL_compressed_texture_etc1");
                        break;
                    default:
                        r = e.getExtension(n)
                }
                return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = r, r
            }
        }
    }

    function ft() {
        function e() {
            l.value !== r && (l.value = r, l.needsUpdate = i > 0), n.numPlanes = i, n.numIntersection = 0
        }

        function t(e, t, r, i) {
            var o = null !== e ? e.length : 0,
                a = null;
            if (0 !== o) {
                if (a = l.value, !0 !== i || null === a) {
                    var h = r + 4 * o,
                        u = t.matrixWorldInverse;
                    c.getNormalMatrix(u), (null === a || a.length < h) && (a = new Float32Array(h));
                    for (var d = 0, p = r; d !== o; ++d, p += 4) s.copy(e[d]).applyMatrix4(u, c), s.normal.toArray(a, p), a[p + 3] = s.constant
                }
                l.value = a, l.needsUpdate = !0
            }
            return n.numPlanes = o, a
        }
        var n = this,
            r = null,
            i = 0,
            o = !1,
            a = !1,
            s = new ie,
            c = new re,
            l = {
                value: null,
                needsUpdate: !1
            };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, n, a) {
            var s = 0 !== e.length || n || 0 !== i || o;
            return o = n, r = t(e, a, 0), i = e.length, s
        }, this.beginShadows = function() {
            a = !0, t(null)
        }, this.endShadows = function() {
            a = !1, e()
        }, this.setState = function(n, s, c, h, u, d) {
            if (!o || null === n || 0 === n.length || a && !c) a ? t(null) : e();
            else {
                var p = a ? 0 : i,
                    f = 4 * p,
                    m = u.clippingState || null;
                l.value = m, m = t(n, h, f, d);
                for (var g = 0; g !== f; ++g) m[g] = r[g];
                u.clippingState = m, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += p
            }
        }
    }

    function mt(e) {
        function t() {
            return null === ne ? ye : 1
        }

        function n() {
            Ze.init(), Ze.scissor(le.copy(be).multiplyScalar(ye)), Ze.viewport(ue.copy(we).multiplyScalar(ye)), Ze.buffers.color.setClear(pe.r, pe.g, pe.b, me, H)
        }

        function r() {
            te = null, ce = null, se = "", ie = -1, Ze.reset()
        }

        function i(e) {
            e.preventDefault(), r(), n(), Je.clear(), tt.clear()
        }

        function o(e) {
            var t = e.target;
            t.removeEventListener("dispose", o), s(t)
        }

        function s(e) {
            c(e), Je.remove(e)
        }

        function c(e) {
            var t = Je.get(e).program;
            e.program = void 0, void 0 !== t && nt.releaseProgram(t)
        }

        function l(e, t, n) {
            e.render(function(e) {
                ee.renderBufferImmediate(e, t, n)
            })
        }

        function p(e, t) {
            return Math.abs(t[0]) - Math.abs(e[0])
        }

        function f(e, t, n, r) {
            if (n && n.isInstancedBufferGeometry && null === qe.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === r && (r = 0), Ze.initAttributes();
            var i = n.attributes,
                o = t.getAttributes(),
                a = e.defaultAttributeValues;
            for (var s in o) {
                var c = o[s];
                if (c >= 0) {
                    var l = i[s];
                    if (void 0 !== l) {
                        var h = l.normalized,
                            u = l.itemSize,
                            d = Qe.get(l),
                            p = d.buffer,
                            f = d.type,
                            m = d.bytesPerElement;
                        if (l.isInterleavedBufferAttribute) {
                            var g = l.data,
                                v = g.stride,
                                y = l.offset;
                            g && g.isInstancedInterleavedBuffer ? (Ze.enableAttributeAndDivisor(c, g.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = g.meshPerAttribute * g.count)) : Ze.enableAttribute(c), ze.bindBuffer(ze.ARRAY_BUFFER, p), ze.vertexAttribPointer(c, u, f, h, v * m, (r * v + y) * m)
                        } else l.isInstancedBufferAttribute ? (Ze.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = l.meshPerAttribute * l.count)) : Ze.enableAttribute(c), ze.bindBuffer(ze.ARRAY_BUFFER, p), ze.vertexAttribPointer(c, u, f, h, 0, r * u * m)
                    } else if (void 0 !== a) {
                        var b = a[s];
                        if (void 0 !== b) switch (b.length) {
                            case 2:
                                ze.vertexAttrib2fv(c, b);
                                break;
                            case 3:
                                ze.vertexAttrib3fv(c, b);
                                break;
                            case 4:
                                ze.vertexAttrib4fv(c, b);
                                break;
                            default:
                                ze.vertexAttrib1fv(c, b)
                        }
                    }
                }
            }
            Ze.disableUnusedAttributes()
        }

        function m(e, t, n) {
            if (e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isLight) G.push(e);
                    else if (e.isSprite) e.frustumCulled && !_e.intersectsSprite(e) || Y.push(e);
                else if (e.isLensFlare) K.push(e);
                else if (e.isImmediateRenderObject) n && Ae.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Se), W.push(e, null, e.material, Ae.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || _e.intersectsObject(e))) {
                    n && Ae.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Se);
                    var r = tt.update(e),
                        i = e.material;
                    if (Array.isArray(i))
                        for (var o = r.groups, a = 0, s = o.length; a < s; a++) {
                            var c = o[a],
                                l = i[c.materialIndex];
                            l && l.visible && W.push(e, r, l, Ae.z, c)
                        } else i.visible && W.push(e, r, i, Ae.z, null)
                }
                for (var h = e.children, a = 0, s = h.length; a < s; a++) m(h[a], t, n)
            }
        }

        function g(e, t, n, r) {
            for (var i = 0, o = e.length; i < o; i++) {
                var a = e[i],
                    s = a.object,
                    c = a.geometry,
                    l = void 0 === r ? a.material : r,
                    h = a.group;
                if (s.onBeforeRender(ee, t, n, c, l, h), n.isArrayCamera && n.enabled)
                    for (var u = n.cameras, d = 0, p = u.length; d < p; d++) {
                        var f = u[d],
                            m = f.bounds;
                        ee.setViewport(m.x * ge * ye, m.y * ve * ye, m.z * ge * ye, m.w * ve * ye), ee.setScissor(m.x * ge * ye, m.y * ve * ye, m.z * ge * ye, m.w * ve * ye), ee.setScissorTest(!0), v(s, t, f, c, l, h)
                    } else v(s, t, n, c, l, h);
                s.onAfterRender(ee, t, n, c, l, h)
            }
        }

        function v(e, t, n, r, i, o) {
            if (e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                Ze.setMaterial(i);
                var a = b(n, t.fog, i, e);
                se = "", l(e, a, i)
            } else ee.renderBufferDirect(n, t.fog, r, i, e, o)
        }

        function y(e, t, n) {
            var r = Je.get(e),
                i = nt.getParameters(e, Oe, t, Me.numPlanes, Me.numIntersection, n),
                a = nt.getProgramCode(e, i),
                s = r.program,
                l = !0;
            if (void 0 === s) e.addEventListener("dispose", o);
            else if (s.code !== a) c(e);
            else {
                if (void 0 !== i.shaderID) return;
                l = !1
            }
            if (l) {
                if (i.shaderID) {
                    var h = Ns[i.shaderID];
                    r.__webglShader = {
                        name: e.type,
                        uniforms: ks.clone(h.uniforms),
                        vertexShader: h.vertexShader,
                        fragmentShader: h.fragmentShader
                    }
                } else r.__webglShader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                };
                e.__webglShader = r.__webglShader, s = nt.acquireProgram(e, i, a), r.program = s, e.program = s
            }
            var u = s.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var d = 0; d < ee.maxMorphTargets; d++) u["morphTarget" + d] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (var d = 0; d < ee.maxMorphNormals; d++) u["morphNormal" + d] >= 0 && e.numSupportedMorphNormals++
            }
            var p = r.__webglShader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = Me.numPlanes, r.numIntersection = Me.numIntersection, p.clippingPlanes = Me.uniform), r.fog = t, r.lightsHash = Oe.hash, e.lights && (p.ambientLightColor.value = Oe.ambient, p.directionalLights.value = Oe.directional, p.spotLights.value = Oe.spot, p.rectAreaLights.value = Oe.rectArea, p.pointLights.value = Oe.point, p.hemisphereLights.value = Oe.hemi, p.directionalShadowMap.value = Oe.directionalShadowMap, p.directionalShadowMatrix.value = Oe.directionalShadowMatrix, p.spotShadowMap.value = Oe.spotShadowMap, p.spotShadowMatrix.value = Oe.spotShadowMatrix, p.pointShadowMap.value = Oe.pointShadowMap, p.pointShadowMatrix.value = Oe.pointShadowMatrix);
            var f = r.program.getUniforms(),
                m = X.seqWithValue(f.seq, p);
            r.uniformsList = m
        }

        function b(e, t, n, r) {
            de = 0;
            var i = Je.get(n);
            if (Ee && (Te || e !== ce)) {
                var o = e === ce && n.id === ie;
                Me.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, i, o)
            }!1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== t ? n.needsUpdate = !0 : n.lights && i.lightsHash !== Oe.hash ? n.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === Me.numPlanes && i.numIntersection === Me.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (y(n, t, r), n.needsUpdate = !1);
            var a = !1,
                s = !1,
                c = !1,
                l = i.program,
                h = l.getUniforms(),
                u = i.__webglShader.uniforms;
            if (l.id !== te && (ze.useProgram(l.program), te = l.id, a = !0, s = !0, c = !0), n.id !== ie && (ie = n.id, s = !0), a || e !== ce) {
                if (h.setValue(ze, "projectionMatrix", e.projectionMatrix), Ye.logarithmicDepthBuffer && h.setValue(ze, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), e !== ce && (ce = e, s = !0, c = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var p = h.map.cameraPosition;
                    void 0 !== p && p.setValue(ze, Ae.setFromMatrixPosition(e.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && h.setValue(ze, "viewMatrix", e.matrixWorldInverse), h.setValue(ze, "toneMappingExposure", ee.toneMappingExposure), h.setValue(ze, "toneMappingWhitePoint", ee.toneMappingWhitePoint)
            }
            if (n.skinning) {
                h.setOptional(ze, r, "bindMatrix"), h.setOptional(ze, r, "bindMatrixInverse");
                var f = r.skeleton;
                if (f) {
                    var m = f.bones;
                    if (Ye.floatVertexTextures) {
                        if (void 0 === f.boneTexture) {
                            var g = Math.sqrt(4 * m.length);
                            g = Ms.nextPowerOfTwo(Math.ceil(g)), g = Math.max(g, 4);
                            var v = new Float32Array(g * g * 4);
                            v.set(f.boneMatrices);
                            var b = new d(v, g, g, za, Ia);
                            f.boneMatrices = v, f.boneTexture = b, f.boneTextureSize = g
                        }
                        h.setValue(ze, "boneTexture", f.boneTexture), h.setValue(ze, "boneTextureSize", f.boneTextureSize)
                    } else h.setOptional(ze, f, "boneMatrices")
                }
            }
            return s && (n.lights && R(u, c), t && n.fog && E(u, t), (n.isMeshBasicMaterial || n.isMeshLambertMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.isMeshNormalMaterial || n.isMeshDepthMaterial) && x(u, n), n.isLineBasicMaterial ? w(u, n) : n.isLineDashedMaterial ? (w(u, n), _(u, n)) : n.isPointsMaterial ? M(u, n) : n.isMeshLambertMaterial ? T(u, n) : n.isMeshToonMaterial ? A(u, n) : n.isMeshPhongMaterial ? S(u, n) : n.isMeshPhysicalMaterial ? C(u, n) : n.isMeshStandardMaterial ? P(u, n) : n.isMeshDepthMaterial ? n.displacementMap && (u.displacementMap.value = n.displacementMap, u.displacementScale.value = n.displacementScale, u.displacementBias.value = n.displacementBias) : n.isMeshNormalMaterial && L(u, n), void 0 !== u.ltcMat && (u.ltcMat.value = Os.LTC_MAT_TEXTURE), void 0 !== u.ltcMag && (u.ltcMag.value = Os.LTC_MAG_TEXTURE), X.upload(ze, i.uniformsList, u, ee)), h.setValue(ze, "modelViewMatrix", r.modelViewMatrix), h.setValue(ze, "normalMatrix", r.normalMatrix), h.setValue(ze, "modelMatrix", r.matrixWorld), l
        }

        function x(e, t) {
            e.opacity.value = t.opacity, e.diffuse.value = t.color, t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), e.map.value = t.map, e.specularMap.value = t.specularMap, e.alphaMap.value = t.alphaMap, t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity);
            var n;
            if (t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n) {
                n.isWebGLRenderTarget && (n = n.texture);
                var r = n.offset,
                    i = n.repeat;
                e.offsetRepeat.value.set(r.x, r.y, i.x, i.y)
            }
            e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio
        }

        function w(e, t) {
            e.diffuse.value = t.color, e.opacity.value = t.opacity
        }

        function _(e, t) {
            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
        }

        function M(e, t) {
            if (e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * ye, e.scale.value = .5 * ve, e.map.value = t.map, null !== t.map) {
                var n = t.map.offset,
                    r = t.map.repeat;
                e.offsetRepeat.value.set(n.x, n.y, r.x, r.y)
            }
        }

        function E(e, t) {
            e.fogColor.value = t.color, t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
        }

        function T(e, t) {
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
        }

        function S(e, t) {
            e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function A(e, t) {
            S(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap)
        }

        function P(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }

        function C(e, t) {
            e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness, P(e, t)
        }

        function L(e, t) {
            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function R(e, t) {
            e.ambientLightColor.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
        }

        function I(e) {
            for (var t = 0, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                i.castShadow && (Oe.shadows[t] = i, t++)
            }
            Oe.shadows.length = t
        }

        function O(e, t) {
            var n, r, i, o, a, s, c, l, h = 0,
                u = 0,
                d = 0,
                p = t.matrixWorldInverse,
                f = 0,
                m = 0,
                g = 0,
                v = 0,
                y = 0;
            for (n = 0, r = e.length; n < r; n++)
                if (i = e[n], a = i.color, s = i.intensity, c = i.distance, l = i.shadow && i.shadow.map ? i.shadow.map.texture : null, i.isAmbientLight) h += a.r * s, u += a.g * s, d += a.b * s;
                else if (i.isDirectionalLight) {
                var b = rt.get(i);
                b.color.copy(i.color).multiplyScalar(i.intensity), b.direction.setFromMatrixPosition(i.matrixWorld), Ae.setFromMatrixPosition(i.target.matrixWorld), b.direction.sub(Ae), b.direction.transformDirection(p), b.shadow = i.castShadow, i.castShadow && (o = i.shadow, b.shadowBias = o.bias, b.shadowRadius = o.radius, b.shadowMapSize = o.mapSize), Oe.directionalShadowMap[f] = l, Oe.directionalShadowMatrix[f] = i.shadow.matrix, Oe.directional[f] = b, f++
            } else if (i.isSpotLight) {
                var b = rt.get(i);
                b.position.setFromMatrixPosition(i.matrixWorld), b.position.applyMatrix4(p), b.color.copy(a).multiplyScalar(s), b.distance = c, b.direction.setFromMatrixPosition(i.matrixWorld), Ae.setFromMatrixPosition(i.target.matrixWorld), b.direction.sub(Ae), b.direction.transformDirection(p), b.coneCos = Math.cos(i.angle), b.penumbraCos = Math.cos(i.angle * (1 - i.penumbra)), b.decay = 0 === i.distance ? 0 : i.decay, b.shadow = i.castShadow, i.castShadow && (o = i.shadow, b.shadowBias = o.bias, b.shadowRadius = o.radius, b.shadowMapSize = o.mapSize), Oe.spotShadowMap[g] = l, Oe.spotShadowMatrix[g] = i.shadow.matrix, Oe.spot[g] = b, g++
            } else if (i.isRectAreaLight) {
                var b = rt.get(i);
                b.color.copy(a).multiplyScalar(s / (i.width * i.height)), b.position.setFromMatrixPosition(i.matrixWorld), b.position.applyMatrix4(p), Re.identity(), Pe.copy(i.matrixWorld), Pe.premultiply(p), Re.extractRotation(Pe), b.halfWidth.set(.5 * i.width, 0, 0), b.halfHeight.set(0, .5 * i.height, 0), b.halfWidth.applyMatrix4(Re), b.halfHeight.applyMatrix4(Re), Oe.rectArea[v] = b, v++
            } else if (i.isPointLight) {
                var b = rt.get(i);
                b.position.setFromMatrixPosition(i.matrixWorld), b.position.applyMatrix4(p), b.color.copy(i.color).multiplyScalar(i.intensity), b.distance = i.distance, b.decay = 0 === i.distance ? 0 : i.decay, b.shadow = i.castShadow, i.castShadow && (o = i.shadow, b.shadowBias = o.bias, b.shadowRadius = o.radius, b.shadowMapSize = o.mapSize), Oe.pointShadowMap[m] = l, Oe.pointShadowMatrix[m] = i.shadow.matrix, Oe.point[m] = b, m++
            } else if (i.isHemisphereLight) {
                var b = rt.get(i);
                b.direction.setFromMatrixPosition(i.matrixWorld), b.direction.transformDirection(p), b.direction.normalize(), b.skyColor.copy(i.color).multiplyScalar(s), b.groundColor.copy(i.groundColor).multiplyScalar(s), Oe.hemi[y] = b, y++
            }
            Oe.ambient[0] = h, Oe.ambient[1] = u, Oe.ambient[2] = d, Oe.directional.length = f, Oe.spot.length = g, Oe.rectArea.length = v, Oe.point.length = m, Oe.hemi.length = y, Oe.hash = f + "," + m + "," + g + "," + v + "," + y + "," + Oe.shadows.length
        }

        function k() {
            var e = de;
            return e >= Ye.maxTextures && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Ye.maxTextures), de += 1, e
        }

        function D(e) {
            var t;
            if (e === va) return ze.REPEAT;
            if (e === ya) return ze.CLAMP_TO_EDGE;
            if (e === ba) return ze.MIRRORED_REPEAT;
            if (e === xa) return ze.NEAREST;
            if (e === wa) return ze.NEAREST_MIPMAP_NEAREST;
            if (e === _a) return ze.NEAREST_MIPMAP_LINEAR;
            if (e === Ma) return ze.LINEAR;
            if (e === Ea) return ze.LINEAR_MIPMAP_NEAREST;
            if (e === Ta) return ze.LINEAR_MIPMAP_LINEAR;
            if (e === Sa) return ze.UNSIGNED_BYTE;
            if (e === ka) return ze.UNSIGNED_SHORT_4_4_4_4;
            if (e === Da) return ze.UNSIGNED_SHORT_5_5_5_1;
            if (e === Na) return ze.UNSIGNED_SHORT_5_6_5;
            if (e === Aa) return ze.BYTE;
            if (e === Pa) return ze.SHORT;
            if (e === Ca) return ze.UNSIGNED_SHORT;
            if (e === La) return ze.INT;
            if (e === Ra) return ze.UNSIGNED_INT;
            if (e === Ia) return ze.FLOAT;
            if (e === Oa && null !== (t = qe.get("OES_texture_half_float"))) return t.HALF_FLOAT_OES;
            if (e === Ua) return ze.ALPHA;
            if (e === Fa) return ze.RGB;
            if (e === za) return ze.RGBA;
            if (e === ja) return ze.LUMINANCE;
            if (e === Ha) return ze.LUMINANCE_ALPHA;
            if (e === Ga) return ze.DEPTH_COMPONENT;
            if (e === Wa) return ze.DEPTH_STENCIL;
            if (e === Ro) return ze.FUNC_ADD;
            if (e === Io) return ze.FUNC_SUBTRACT;
            if (e === Oo) return ze.FUNC_REVERSE_SUBTRACT;
            if (e === No) return ze.ZERO;
            if (e === Bo) return ze.ONE;
            if (e === Uo) return ze.SRC_COLOR;
            if (e === Fo) return ze.ONE_MINUS_SRC_COLOR;
            if (e === zo) return ze.SRC_ALPHA;
            if (e === jo) return ze.ONE_MINUS_SRC_ALPHA;
            if (e === Ho) return ze.DST_ALPHA;
            if (e === Vo) return ze.ONE_MINUS_DST_ALPHA;
            if (e === Go) return ze.DST_COLOR;
            if (e === Wo) return ze.ONE_MINUS_DST_COLOR;
            if (e === $o) return ze.SRC_ALPHA_SATURATE;
            if ((e === $a || e === Xa || e === qa || e === Ya) && null !== (t = qe.get("WEBGL_compressed_texture_s3tc"))) {
                if (e === $a) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (e === Xa) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (e === qa) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (e === Ya) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if ((e === Za || e === Ja || e === Ka || e === Qa) && null !== (t = qe.get("WEBGL_compressed_texture_pvrtc"))) {
                if (e === Za) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (e === Ja) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (e === Ka) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (e === Qa) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (e === es && null !== (t = qe.get("WEBGL_compressed_texture_etc1"))) return t.COMPRESSED_RGB_ETC1_WEBGL;
            if ((e === ko || e === Do) && null !== (t = qe.get("EXT_blend_minmax"))) {
                if (e === ko) return t.MIN_EXT;
                if (e === Do) return t.MAX_EXT
            }
            return e === Ba && null !== (t = qe.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : 0
        }
        console.log("THREE.WebGLRenderer", oo), e = e || {};
        var N = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            B = void 0 !== e.context ? e.context : null,
            U = void 0 !== e.alpha && e.alpha,
            F = void 0 === e.depth || e.depth,
            z = void 0 === e.stencil || e.stencil,
            j = void 0 !== e.antialias && e.antialias,
            H = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            V = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            G = [],
            W = null,
            $ = new Float32Array(8),
            Y = [],
            K = [];
        this.domElement = N, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = oa, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var ee = this,
            te = null,
            ne = null,
            re = null,
            ie = -1,
            se = "",
            ce = null,
            le = new a,
            he = null,
            ue = new a,
            de = 0,
            pe = new q(0),
            me = 0,
            ge = N.width,
            ve = N.height,
            ye = 1,
            be = new a(0, 0, ge, ve),
            xe = !1,
            we = new a(0, 0, ge, ve),
            _e = new oe,
            Me = new ft,
            Ee = !1,
            Te = !1,
            Se = new u,
            Ae = new h,
            Pe = new u,
            Re = new u,
            Oe = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: []
            },
            De = {
                geometries: 0,
                textures: 0
            },
            Fe = {
                frame: 0,
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: Fe,
            memory: De,
            programs: null
        };
        var ze;
        try {
            var je = {
                alpha: U,
                depth: F,
                stencil: z,
                antialias: j,
                premultipliedAlpha: H,
                preserveDrawingBuffer: V
            };
            if (null === (ze = B || N.getContext("webgl", je) || N.getContext("experimental-webgl", je))) throw null !== N.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            void 0 === ze.getShaderPrecisionFormat && (ze.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }), N.addEventListener("webglcontextlost", i, !1)
        } catch (e) {
            console.error("THREE.WebGLRenderer: " + e)
        }
        var qe = new pt(ze);
        qe.get("WEBGL_depth_texture"), qe.get("OES_texture_float"), qe.get("OES_texture_float_linear"), qe.get("OES_texture_half_float"), qe.get("OES_texture_half_float_linear"), qe.get("OES_standard_derivatives"), qe.get("ANGLE_instanced_arrays"), qe.get("OES_element_index_uint") && (Ce.MaxIndex = 4294967296);
        var Ye = new dt(ze, qe, e),
            Ze = new ut(ze, qe, D),
            Je = new ht,
            Ke = new lt(ze, qe, Ze, Je, Ye, D, De),
            Qe = new Ue(ze),
            et = new We(ze, Qe, De),
            tt = new Xe(ze, et, Fe),
            nt = new ct(this, Ye),
            rt = new $e,
            it = new He;
        this.info.programs = nt.programs;
        var ot, at, st, mt, gt = new Ge(ze, qe, Fe),
            vt = new Ve(ze, qe, Fe);
        n(), this.context = ze, this.capabilities = Ye, this.extensions = qe, this.properties = Je, this.state = Ze;
        var yt = new ae(this, Oe, tt, Ye);
        this.shadowMap = yt;
        var bt = new J(this, Y),
            xt = new Z(this, K);
        this.getContext = function() {
            return ze
        }, this.getContextAttributes = function() {
            return ze.getContextAttributes()
        }, this.forceContextLoss = function() {
            var e = qe.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.getMaxAnisotropy = function() {
            return Ye.getMaxAnisotropy()
        }, this.getPrecision = function() {
            return Ye.precision
        }, this.getPixelRatio = function() {
            return ye
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (ye = e, this.setSize(we.z, we.w, !1))
        }, this.getSize = function() {
            return {
                width: ge,
                height: ve
            }
        }, this.setSize = function(e, t, n) {
            ge = e, ve = t, N.width = e * ye, N.height = t * ye, !1 !== n && (N.style.width = e + "px", N.style.height = t + "px"), this.setViewport(0, 0, e, t)
        }, this.setViewport = function(e, t, n, r) {
            Ze.viewport(we.set(e, t, n, r))
        }, this.setScissor = function(e, t, n, r) {
            Ze.scissor(be.set(e, t, n, r))
        }, this.setScissorTest = function(e) {
            Ze.setScissorTest(xe = e)
        }, this.getClearColor = function() {
            return pe
        }, this.setClearColor = function(e, t) {
            pe.set(e), me = void 0 !== t ? t : 1, Ze.buffers.color.setClear(pe.r, pe.g, pe.b, me, H)
        }, this.getClearAlpha = function() {
            return me
        }, this.setClearAlpha = function(e) {
            me = e, Ze.buffers.color.setClear(pe.r, pe.g, pe.b, me, H)
        }, this.clear = function(e, t, n) {
            var r = 0;
            (void 0 === e || e) && (r |= ze.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= ze.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= ze.STENCIL_BUFFER_BIT), ze.clear(r)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.clearTarget = function(e, t, n, r) {
            this.setRenderTarget(e), this.clear(t, n, r)
        }, this.resetGLState = r, this.dispose = function() {
            N.removeEventListener("webglcontextlost", i, !1), it.dispose()
        }, this.renderBufferImmediate = function(e, t, n) {
            Ze.initAttributes();
            var r = Je.get(e);
            e.hasPositions && !r.position && (r.position = ze.createBuffer()), e.hasNormals && !r.normal && (r.normal = ze.createBuffer()), e.hasUvs && !r.uv && (r.uv = ze.createBuffer()), e.hasColors && !r.color && (r.color = ze.createBuffer());
            var i = t.getAttributes();
            if (e.hasPositions && (ze.bindBuffer(ze.ARRAY_BUFFER, r.position), ze.bufferData(ze.ARRAY_BUFFER, e.positionArray, ze.DYNAMIC_DRAW), Ze.enableAttribute(i.position), ze.vertexAttribPointer(i.position, 3, ze.FLOAT, !1, 0, 0)), e.hasNormals) {
                if (ze.bindBuffer(ze.ARRAY_BUFFER, r.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && n.shading === xo)
                    for (var o = 0, a = 3 * e.count; o < a; o += 9) {
                        var s = e.normalArray,
                            c = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                            l = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                            h = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                        s[o + 0] = c, s[o + 1] = l, s[o + 2] = h, s[o + 3] = c, s[o + 4] = l, s[o + 5] = h, s[o + 6] = c, s[o + 7] = l, s[o + 8] = h
                    }
                ze.bufferData(ze.ARRAY_BUFFER, e.normalArray, ze.DYNAMIC_DRAW), Ze.enableAttribute(i.normal), ze.vertexAttribPointer(i.normal, 3, ze.FLOAT, !1, 0, 0)
            }
            e.hasUvs && n.map && (ze.bindBuffer(ze.ARRAY_BUFFER, r.uv), ze.bufferData(ze.ARRAY_BUFFER, e.uvArray, ze.DYNAMIC_DRAW), Ze.enableAttribute(i.uv), ze.vertexAttribPointer(Qe.uv, 2, ze.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== _o && (ze.bindBuffer(ze.ARRAY_BUFFER, r.color), ze.bufferData(ze.ARRAY_BUFFER, e.colorArray, ze.DYNAMIC_DRAW), Ze.enableAttribute(i.color), ze.vertexAttribPointer(i.color, 3, ze.FLOAT, !1, 0, 0)), Ze.disableUnusedAttributes(), ze.drawArrays(ze.TRIANGLES, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, n, r, i, o, a) {
            Ze.setMaterial(i);
            var s = b(e, n, i, o),
                c = r.id + "_" + s.id + "_" + (!0 === i.wireframe),
                l = !1;
            c !== se && (se = c, l = !0);
            var h = o.morphTargetInfluences;
            if (void 0 !== h) {
                for (var u = [], d = 0, m = h.length; d < m; d++) {
                    var g = h[d];
                    u.push([g, d])
                }
                u.sort(p), u.length > 8 && (u.length = 8);
                for (var v = r.morphAttributes, d = 0, m = u.length; d < m; d++) {
                    var g = u[d];
                    if ($[d] = g[0], 0 !== g[0]) {
                        var y = g[1];
                        !0 === i.morphTargets && v.position && r.addAttribute("morphTarget" + d, v.position[y]), !0 === i.morphNormals && v.normal && r.addAttribute("morphNormal" + d, v.normal[y])
                    } else !0 === i.morphTargets && r.removeAttribute("morphTarget" + d), !0 === i.morphNormals && r.removeAttribute("morphNormal" + d)
                }
                for (var d = u.length, x = $.length; d < x; d++) $[d] = 0;
                s.getUniforms().setValue(ze, "morphTargetInfluences", $), l = !0
            }
            var y = r.index,
                w = r.attributes.position,
                _ = 1;
            !0 === i.wireframe && (y = et.getWireframeAttribute(r), _ = 2);
            var M = gt;
            null !== y && (M = vt, M.setIndex(y)), l && (f(i, s, r), null !== y && ze.bindBuffer(ze.ELEMENT_ARRAY_BUFFER, Qe.get(y).buffer));
            var E = 0;
            null !== y ? E = y.count : void 0 !== w && (E = w.count);
            var T = r.drawRange.start * _,
                S = r.drawRange.count * _,
                A = null !== a ? a.start * _ : 0,
                P = null !== a ? a.count * _ : 1 / 0,
                C = Math.max(T, A),
                L = Math.min(E, T + S, A + P) - 1,
                R = Math.max(0, L - C + 1);
            if (0 !== R) {
                if (o.isMesh)
                    if (!0 === i.wireframe) Ze.setLineWidth(i.wireframeLinewidth * t()), M.setMode(ze.LINES);
                    else switch (o.drawMode) {
                        case hs:
                            M.setMode(ze.TRIANGLES);
                            break;
                        case us:
                            M.setMode(ze.TRIANGLE_STRIP);
                            break;
                        case ds:
                            M.setMode(ze.TRIANGLE_FAN)
                    } else if (o.isLine) {
                        var I = i.linewidth;
                        void 0 === I && (I = 1), Ze.setLineWidth(I * t()), o.isLineSegments ? M.setMode(ze.LINES) : o.isLineLoop ? M.setMode(ze.LINE_LOOP) : M.setMode(ze.LINE_STRIP)
                    } else o.isPoints && M.setMode(ze.POINTS);
                r && r.isInstancedBufferGeometry ? r.maxInstancedCount > 0 && M.renderInstances(r, C, R) : M.render(C, R)
            }
        }, this.compile = function(e, t) {
            G = [], e.traverse(function(e) {
                e.isLight && G.push(e)
            }), O(G, t), e.traverse(function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var n = 0; n < t.material.length; n++) y(t.material[n], e.fog, t);
                    else y(t.material, e.fog, t)
            })
        }, this.render = function(e, t, n, r) {
            if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            se = "", ie = -1, ce = null, !0 === e.autoUpdate && e.updateMatrixWorld(), t.onBeforeRender(ee), null === t.parent && t.updateMatrixWorld(), t.matrixWorldInverse.getInverse(t.matrixWorld), Se.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), _e.setFromMatrix(Se), G.length = 0, Y.length = 0, K.length = 0, Te = this.localClippingEnabled, Ee = Me.init(this.clippingPlanes, Te, t), W = it.get(e, t), W.init(), m(e, t, ee.sortObjects), W.finish(), !0 === ee.sortObjects && W.sort(), Ee && Me.beginShadows(), I(G), yt.render(e, t), O(G, t), Ee && Me.endShadows(), Fe.frame++, Fe.calls = 0, Fe.vertices = 0, Fe.faces = 0, Fe.points = 0, void 0 === n && (n = null), this.setRenderTarget(n);
            var i = e.background;
            null === i ? Ze.buffers.color.setClear(pe.r, pe.g, pe.b, me, H) : i && i.isColor && (Ze.buffers.color.setClear(i.r, i.g, i.b, 1, H), r = !0), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), i && i.isCubeTexture ? (void 0 === st && (st = new Ne, mt = new Le(new Ie(5, 5, 5), new Q({
                uniforms: Ns.cube.uniforms,
                vertexShader: Ns.cube.vertexShader,
                fragmentShader: Ns.cube.fragmentShader,
                side: yo,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }))), st.projectionMatrix.copy(t.projectionMatrix), st.matrixWorld.extractRotation(t.matrixWorld), st.matrixWorldInverse.getInverse(st.matrixWorld), mt.material.uniforms.tCube.value = i, mt.modelViewMatrix.multiplyMatrices(st.matrixWorldInverse, mt.matrixWorld), tt.update(mt), ee.renderBufferDirect(st, null, mt.geometry, mt.material, mt, null)) : i && i.isTexture && (void 0 === ot && (ot = new Be(-1, 1, 1, -1, 0, 1), at = new Le(new ke(2, 2), new fe({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }))), at.material.map = i, tt.update(at), ee.renderBufferDirect(ot, null, at.geometry, at.material, at, null));
            var o = W.opaque,
                a = W.transparent;
            if (e.overrideMaterial) {
                var s = e.overrideMaterial;
                o.length && g(o, e, t, s), a.length && g(a, e, t, s)
            } else o.length && g(o, e, t), a.length && g(a, e, t);
            bt.render(e, t), xt.render(e, t, ue), n && Ke.updateRenderTargetMipmap(n), Ze.buffers.depth.setTest(!0), Ze.buffers.depth.setMask(!0), Ze.buffers.color.setMask(!0), t.isArrayCamera && t.enabled && ee.setScissorTest(!1), t.onAfterRender(ee)
        }, this.setFaceCulling = function(e, t) {
            Ze.setCullFace(e), Ze.setFlipSided(t === uo)
        }, this.allocTextureUnit = k, this.setTexture2D = function() {
            var e = !1;
            return function(t, n) {
                t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), Ke.setTexture2D(t, n)
            }
        }(), this.setTexture = function() {
            var e = !1;
            return function(t, n) {
                e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), Ke.setTexture2D(t, n)
            }
        }(), this.setTextureCube = function() {
            var e = !1;
            return function(t, n) {
                t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? Ke.setTextureCube(t, n) : Ke.setTextureCubeDynamic(t, n)
            }
        }(), this.getRenderTarget = function() {
            return ne
        }, this.setRenderTarget = function(e) {
            ne = e, e && void 0 === Je.get(e).__webglFramebuffer && Ke.setupRenderTarget(e);
            var t, n = e && e.isWebGLRenderTargetCube;
            if (e) {
                var r = Je.get(e);
                t = n ? r.__webglFramebuffer[e.activeCubeFace] : r.__webglFramebuffer, le.copy(e.scissor), he = e.scissorTest, ue.copy(e.viewport)
            } else t = null, le.copy(be).multiplyScalar(ye), he = xe, ue.copy(we).multiplyScalar(ye);
            if (re !== t && (ze.bindFramebuffer(ze.FRAMEBUFFER, t), re = t), Ze.scissor(le), Ze.setScissorTest(he), Ze.viewport(ue), n) {
                var i = Je.get(e.texture);
                ze.framebufferTexture2D(ze.FRAMEBUFFER, ze.COLOR_ATTACHMENT0, ze.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel)
            }
        }, this.readRenderTargetPixels = function(e, t, n, r, i, o) {
            if (!1 === (e && e.isWebGLRenderTarget)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var a = Je.get(e).__webglFramebuffer;
            if (a) {
                var s = !1;
                a !== re && (ze.bindFramebuffer(ze.FRAMEBUFFER, a), s = !0);
                try {
                    var c = e.texture,
                        l = c.format,
                        h = c.type;
                    if (l !== za && D(l) !== ze.getParameter(ze.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(h === Sa || D(h) === ze.getParameter(ze.IMPLEMENTATION_COLOR_READ_TYPE) || h === Ia && (qe.get("OES_texture_float") || qe.get("WEBGL_color_buffer_float")) || h === Oa && qe.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    ze.checkFramebufferStatus(ze.FRAMEBUFFER) === ze.FRAMEBUFFER_COMPLETE ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ze.readPixels(t, n, r, i, D(l), D(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    s && ze.bindFramebuffer(ze.FRAMEBUFFER, re)
                }
            }
        }
    }

    function gt(e, t) {
        this.name = "", this.color = new q(e), this.density = void 0 !== t ? t : 25e-5
    }

    function vt(e, t, n) {
        this.name = "", this.color = new q(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
    }

    function yt() {
        he.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }

    function bt(e, t, n, r, i) {
        he.call(this), this.lensFlares = [], this.positionScreen = new h, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, r, i)
    }

    function xt(e) {
        K.call(this), this.type = "SpriteMaterial", this.color = new q(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(e)
    }

    function wt(e) {
        he.call(this), this.type = "Sprite", this.material = void 0 !== e ? e : new xt
    }

    function _t() {
        he.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function Mt(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new u)
        }
    }

    function Et() {
        he.call(this), this.type = "Bone"
    }

    function Tt(e, t) {
        Le.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new u, this.bindMatrixInverse = new u;
        var n = this.initBones(),
            r = new Mt(n);
        this.bind(r, this.matrixWorld), this.normalizeSkinWeights()
    }

    function St(e) {
        K.call(this), this.type = "LineBasicMaterial", this.color = new q(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
    }

    function At(e, t, n) {
        if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Pt(e, t);
        he.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Ce, this.material = void 0 !== t ? t : new St({
            color: 16777215 * Math.random()
        })
    }

    function Pt(e, t) {
        At.call(this, e, t), this.type = "LineSegments"
    }

    function Ct(e, t) {
        At.call(this, e, t), this.type = "LineLoop"
    }

    function Lt(e) {
        K.call(this), this.type = "PointsMaterial", this.color = new q(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(e)
    }

    function Rt(e, t) {
        he.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Ce, this.material = void 0 !== t ? t : new Lt({
            color: 16777215 * Math.random()
        })
    }

    function It() {
        he.call(this), this.type = "Group"
    }

    function Ot(e, t, n, r, i, a, s, c, l) {
        function h() {
            requestAnimationFrame(h), e.readyState >= e.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
        }
        o.call(this, e, t, n, r, i, a, s, c, l), this.generateMipmaps = !1;
        var u = this;
        h()
    }

    function kt(e, t, n, r, i, a, s, c, l, h, u, d) {
        o.call(this, null, a, s, c, l, h, r, i, u, d), this.image = {
            width: t,
            height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }

    function Dt(e, t, n, r, i, a, s, c, l) {
        o.call(this, e, t, n, r, i, a, s, c, l), this.needsUpdate = !0
    }

    function Nt(e, t, n, r, i, a, s, c, l, h) {
        if ((h = void 0 !== h ? h : Ga) !== Ga && h !== Wa) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && h === Ga && (n = Ca), void 0 === n && h === Wa && (n = Ba), o.call(this, null, r, i, a, s, c, h, n, l), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== s ? s : xa, this.minFilter = void 0 !== c ? c : xa, this.flipY = !1, this.generateMipmaps = !1
    }

    function Bt(e) {
        Ce.call(this), this.type = "WireframeGeometry";
        var t, n, r, i, o, a, s, c, l, u, d = [],
            p = [0, 0],
            f = {},
            m = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var g = e.faces;
            for (t = 0, r = g.length; t < r; t++) {
                var v = g[t];
                for (n = 0; n < 3; n++) s = v[m[n]], c = v[m[(n + 1) % 3]], p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === f[l] && (f[l] = {
                    index1: p[0],
                    index2: p[1]
                })
            }
            for (l in f) a = f[l], u = e.vertices[a.index1], d.push(u.x, u.y, u.z), u = e.vertices[a.index2], d.push(u.x, u.y, u.z)
        } else if (e && e.isBufferGeometry) {
            var y, b, x, w, _, M, E, T;
            if (u = new h, null !== e.index) {
                for (y = e.attributes.position, b = e.index, x = e.groups, 0 === x.length && (x = [{
                        start: 0,
                        count: b.count,
                        materialIndex: 0
                    }]), i = 0, o = x.length; i < o; ++i)
                    for (w = x[i], _ = w.start, M = w.count, t = _, r = _ + M; t < r; t += 3)
                        for (n = 0; n < 3; n++) s = b.getX(t + n), c = b.getX(t + (n + 1) % 3), p[0] = Math.min(s, c), p[1] = Math.max(s, c), l = p[0] + "," + p[1], void 0 === f[l] && (f[l] = {
                            index1: p[0],
                            index2: p[1]
                        });
                for (l in f) a = f[l], u.fromBufferAttribute(y, a.index1), d.push(u.x, u.y, u.z), u.fromBufferAttribute(y, a.index2), d.push(u.x, u.y, u.z)
            } else
                for (y = e.attributes.position, t = 0, r = y.count / 3; t < r; t++)
                    for (n = 0; n < 3; n++) E = 3 * t + n, u.fromBufferAttribute(y, E), d.push(u.x, u.y, u.z), T = 3 * t + (n + 1) % 3, u.fromBufferAttribute(y, T), d.push(u.x, u.y, u.z)
        }
        this.addAttribute("position", new Me(d, 3))
    }

    function Ut(e, t, n) {
        Pe.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        }, this.fromBufferGeometry(new Ft(e, t, n)), this.mergeVertices()
    }

    function Ft(e, t, n) {
        Ce.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        var r, i, o = [],
            a = [],
            s = [],
            c = [],
            l = new h,
            u = new h,
            d = new h,
            p = new h,
            f = new h,
            m = t + 1;
        for (r = 0; r <= n; r++) {
            var g = r / n;
            for (i = 0; i <= t; i++) {
                var v = i / t;
                u = e(v, g, u), a.push(u.x, u.y, u.z), v - 1e-5 >= 0 ? (d = e(v - 1e-5, g, d), p.subVectors(u, d)) : (d = e(v + 1e-5, g, d), p.subVectors(d, u)), g - 1e-5 >= 0 ? (d = e(v, g - 1e-5, d), f.subVectors(u, d)) : (d = e(v, g + 1e-5, d), f.subVectors(d, u)), l.crossVectors(p, f).normalize(), s.push(l.x, l.y, l.z), c.push(v, g)
            }
        }
        for (r = 0; r < n; r++)
            for (i = 0; i < t; i++) {
                var y = r * m + i,
                    b = r * m + i + 1,
                    x = (r + 1) * m + i + 1,
                    w = (r + 1) * m + i;
                o.push(y, b, w), o.push(b, x, w)
            }
        this.setIndex(o), this.addAttribute("position", new Me(a, 3)), this.addAttribute("normal", new Me(s, 3)), this.addAttribute("uv", new Me(c, 2))
    }

    function zt(e, t, n, r) {
        Pe.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, this.fromBufferGeometry(new jt(e, t, n, r)), this.mergeVertices()
    }

    function jt(e, t, n, r) {
        function o(e, t, n, r) {
            var i, o, a = Math.pow(2, r),
                c = [];
            for (i = 0; i <= a; i++) {
                c[i] = [];
                var l = e.clone().lerp(n, i / a),
                    h = t.clone().lerp(n, i / a),
                    u = a - i;
                for (o = 0; o <= u; o++) c[i][o] = 0 === o && i === a ? l : l.clone().lerp(h, o / u)
            }
            for (i = 0; i < a; i++)
                for (o = 0; o < 2 * (a - i) - 1; o++) {
                    var d = Math.floor(o / 2);
                    o % 2 == 0 ? (s(c[i][d + 1]), s(c[i + 1][d]), s(c[i][d])) : (s(c[i][d + 1]), s(c[i + 1][d + 1]), s(c[i + 1][d]))
                }
        }

        function a() {
            for (var e = 0; e < m.length; e += 6) {
                var t = m[e + 0],
                    n = m[e + 2],
                    r = m[e + 4],
                    i = Math.max(t, n, r),
                    o = Math.min(t, n, r);
                i > .9 && o < .1 && (t < .2 && (m[e + 0] += 1), n < .2 && (m[e + 2] += 1), r < .2 && (m[e + 4] += 1))
            }
        }

        function s(e) {
            f.push(e.x, e.y, e.z)
        }

        function c(t, n) {
            var r = 3 * t;
            n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
        }

        function l() {
            for (var e = new h, t = new h, n = new h, r = new h, o = new i, a = new i, s = new i, c = 0, l = 0; c < f.length; c += 9, l += 6) {
                e.set(f[c + 0], f[c + 1], f[c + 2]), t.set(f[c + 3], f[c + 4], f[c + 5]), n.set(f[c + 6], f[c + 7], f[c + 8]), o.set(m[l + 0], m[l + 1]), a.set(m[l + 2], m[l + 3]), s.set(m[l + 4], m[l + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                var p = d(r);
                u(o, l + 0, e, p), u(a, l + 2, t, p), u(s, l + 4, n, p)
            }
        }

        function u(e, t, n, r) {
            r < 0 && 1 === e.x && (m[t] = e.x - 1), 0 === n.x && 0 === n.z && (m[t] = r / 2 / Math.PI + .5)
        }

        function d(e) {
            return Math.atan2(e.z, -e.x)
        }

        function p(e) {
            return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
        }
        Ce.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, n = n || 1, r = r || 0;
        var f = [],
            m = [];
        ! function(e) {
            for (var n = new h, r = new h, i = new h, a = 0; a < t.length; a += 3) c(t[a + 0], n), c(t[a + 1], r), c(t[a + 2], i), o(n, r, i, e)
        }(r),
        function(e) {
            for (var t = new h, n = 0; n < f.length; n += 3) t.x = f[n + 0], t.y = f[n + 1], t.z = f[n + 2], t.normalize().multiplyScalar(e), f[n + 0] = t.x, f[n + 1] = t.y, f[n + 2] = t.z
        }(n),
        function() {
            for (var e = new h, t = 0; t < f.length; t += 3) {
                e.x = f[t + 0], e.y = f[t + 1], e.z = f[t + 2];
                var n = d(e) / 2 / Math.PI + .5,
                    r = p(e) / Math.PI + .5;
                m.push(n, 1 - r)
            }
            l(), a()
        }(), this.addAttribute("position", new Me(f, 3)), this.addAttribute("normal", new Me(f.slice(), 3)), this.addAttribute("uv", new Me(m, 2)), this.normalizeNormals()
    }

    function Ht(e, t) {
        Pe.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Vt(e, t)), this.mergeVertices()
    }

    function Vt(e, t) {
        var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        jt.call(this, n, r, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Gt(e, t) {
        Pe.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Wt(e, t)), this.mergeVertices()
    }

    function Wt(e, t) {
        var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        jt.call(this, n, r, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function $t(e, t) {
        Pe.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Xt(e, t)), this.mergeVertices()
    }

    function Xt(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
            i = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        jt.call(this, r, i, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function qt(e, t) {
        Pe.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new Yt(e, t)), this.mergeVertices()
    }

    function Yt(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n,
            i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        jt.call(this, i, o, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Zt(e, t, n, r, i, o) {
        Pe.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new Jt(e, t, n, r, i);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function Jt(e, t, n, r, o) {
        function a(i) {
            var o = e.getPointAt(i / t),
                a = l.normals[i],
                s = l.binormals[i];
            for (d = 0; d <= r; d++) {
                var c = d / r * Math.PI * 2,
                    h = Math.sin(c),
                    u = -Math.cos(c);
                f.x = u * a.x + h * s.x, f.y = u * a.y + h * s.y, f.z = u * a.z + h * s.z, f.normalize(), v.push(f.x, f.y, f.z), p.x = o.x + n * f.x, p.y = o.y + n * f.y, p.z = o.z + n * f.z, g.push(p.x, p.y, p.z)
            }
        }

        function s() {
            for (d = 1; d <= t; d++)
                for (u = 1; u <= r; u++) {
                    var e = (r + 1) * (d - 1) + (u - 1),
                        n = (r + 1) * d + (u - 1),
                        i = (r + 1) * d + u,
                        o = (r + 1) * (d - 1) + u;
                    b.push(e, n, o), b.push(n, i, o)
                }
        }

        function c() {
            for (u = 0; u <= t; u++)
                for (d = 0; d <= r; d++) m.x = u / t, m.y = d / r, y.push(m.x, m.y)
        }
        Ce.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: o
        }, t = t || 64, n = n || 1, r = r || 8, o = o || !1;
        var l = e.computeFrenetFrames(t, o);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var u, d, p = new h,
            f = new h,
            m = new i,
            g = [],
            v = [],
            y = [],
            b = [];
        ! function() {
            for (u = 0; u < t; u++) a(u);
            a(!1 === o ? t : 0), c(), s()
        }(), this.setIndex(b), this.addAttribute("position", new Me(g, 3)), this.addAttribute("normal", new Me(v, 3)), this.addAttribute("uv", new Me(y, 2))
    }

    function Kt(e, t, n, r, i, o, a) {
        Pe.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Qt(e, t, n, r, i, o)), this.mergeVertices()
    }

    function Qt(e, t, n, r, i, o) {
        function a(e, t, n, r, i) {
            var o = Math.cos(e),
                a = Math.sin(e),
                s = n / t * e,
                c = Math.cos(s);
            i.x = r * (2 + c) * .5 * o, i.y = r * (2 + c) * a * .5, i.z = r * Math.sin(s) * .5
        }
        Ce.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, e = e || 100, t = t || 40, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
        var s, c, l = [],
            u = [],
            d = [],
            p = [],
            f = new h,
            m = new h,
            g = new h,
            v = new h,
            y = new h,
            b = new h,
            x = new h;
        for (s = 0; s <= n; ++s) {
            var w = s / n * i * Math.PI * 2;
            for (a(w, i, o, e, g), a(w + .01, i, o, e, v), b.subVectors(v, g), x.addVectors(v, g), y.crossVectors(b, x), x.crossVectors(y, b), y.normalize(), x.normalize(), c = 0; c <= r; ++c) {
                var _ = c / r * Math.PI * 2,
                    M = -t * Math.cos(_),
                    E = t * Math.sin(_);
                f.x = g.x + (M * x.x + E * y.x), f.y = g.y + (M * x.y + E * y.y), f.z = g.z + (M * x.z + E * y.z), u.push(f.x, f.y, f.z), m.subVectors(f, g).normalize(), d.push(m.x, m.y, m.z), p.push(s / n), p.push(c / r)
            }
        }
        for (c = 1; c <= n; c++)
            for (s = 1; s <= r; s++) {
                var T = (r + 1) * (c - 1) + (s - 1),
                    S = (r + 1) * c + (s - 1),
                    A = (r + 1) * c + s,
                    P = (r + 1) * (c - 1) + s;
                l.push(T, S, P), l.push(S, A, P)
            }
        this.setIndex(l), this.addAttribute("position", new Me(u, 3)), this.addAttribute("normal", new Me(d, 3)), this.addAttribute("uv", new Me(p, 2))
    }

    function en(e, t, n, r, i) {
        Pe.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, this.fromBufferGeometry(new tn(e, t, n, r, i)), this.mergeVertices()
    }

    function tn(e, t, n, r, i) {
        Ce.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, e = e || 100, t = t || 40, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
        var o, a, s = [],
            c = [],
            l = [],
            u = [],
            d = new h,
            p = new h,
            f = new h;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= r; a++) {
                var m = a / r * i,
                    g = o / n * Math.PI * 2;
                p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), l.push(f.x, f.y, f.z), u.push(a / r), u.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= r; a++) {
                var v = (r + 1) * o + a - 1,
                    y = (r + 1) * (o - 1) + a - 1,
                    b = (r + 1) * (o - 1) + a,
                    x = (r + 1) * o + a;
                s.push(v, y, x), s.push(y, b, x)
            }
        this.setIndex(s), this.addAttribute("position", new Me(c, 3)), this.addAttribute("normal", new Me(l, 3)), this.addAttribute("uv", new Me(u, 2))
    }

    function nn(e, t) {
        Pe.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new rn(e, t)), this.mergeVertices()
    }

    function rn(e, t) {
        if (void 0 === e) return void(e = []);
        Ce.call(this), this.type = "ExtrudeBufferGeometry", e = Array.isArray(e) ? e : [e], this.addShapeList(e, t), this.computeVertexNormals()
    }

    function on(e, t) {
        Pe.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new an(e, t)), this.mergeVertices()
    }

    function an(e, t) {
        t = t || {};
        var n = t.font;
        if (!1 === (n && n.isFont)) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Pe;
        var r = n.generateShapes(e, t.size, t.curveSegments);
        t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), rn.call(this, r, t), this.type = "TextBufferGeometry"
    }

    function sn(e, t, n, r, i, o, a) {
        Pe.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new cn(e, t, n, r, i, o, a)), this.mergeVertices()
    }

    function cn(e, t, n, r, i, o, a) {
        Ce.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, c, l = o + a,
            u = 0,
            d = [],
            p = new h,
            f = new h,
            m = [],
            g = [],
            v = [],
            y = [];
        for (c = 0; c <= n; c++) {
            var b = [],
                x = c / n;
            for (s = 0; s <= t; s++) {
                var w = s / t;
                p.x = -e * Math.cos(r + w * i) * Math.sin(o + x * a), p.y = e * Math.cos(o + x * a), p.z = e * Math.sin(r + w * i) * Math.sin(o + x * a), g.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), v.push(f.x, f.y, f.z), y.push(w, 1 - x), b.push(u++)
            }
            d.push(b)
        }
        for (c = 0; c < n; c++)
            for (s = 0; s < t; s++) {
                var _ = d[c][s + 1],
                    M = d[c][s],
                    E = d[c + 1][s],
                    T = d[c + 1][s + 1];
                (0 !== c || o > 0) && m.push(_, M, T), (c !== n - 1 || l < Math.PI) && m.push(M, E, T)
            }
        this.setIndex(m), this.addAttribute("position", new Me(g, 3)), this.addAttribute("normal", new Me(v, 3)), this.addAttribute("uv", new Me(y, 2))
    }

    function ln(e, t, n, r, i, o) {
        Pe.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, this.fromBufferGeometry(new hn(e, t, n, r, i, o)), this.mergeVertices()
    }

    function hn(e, t, n, r, o, a) {
        Ce.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: o,
            thetaLength: a
        }, e = e || 20, t = t || 50, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
        var s, c, l, u = [],
            d = [],
            p = [],
            f = [],
            m = e,
            g = (t - e) / r,
            v = new h,
            y = new i;
        for (c = 0; c <= r; c++) {
            for (l = 0; l <= n; l++) s = o + l / n * a, v.x = m * Math.cos(s), v.y = m * Math.sin(s), d.push(v.x, v.y, v.z), p.push(0, 0, 1), y.x = (v.x / t + 1) / 2, y.y = (v.y / t + 1) / 2, f.push(y.x, y.y);
            m += g
        }
        for (c = 0; c < r; c++) {
            var b = c * (n + 1);
            for (l = 0; l < n; l++) {
                s = l + b;
                var x = s,
                    w = s + n + 1,
                    _ = s + n + 2,
                    M = s + 1;
                u.push(x, w, M), u.push(w, _, M)
            }
        }
        this.setIndex(u), this.addAttribute("position", new Me(d, 3)), this.addAttribute("normal", new Me(p, 3)), this.addAttribute("uv", new Me(f, 2))
    }

    function un(e, t, n, r) {
        Pe.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, this.fromBufferGeometry(new dn(e, t, n, r)), this.mergeVertices()
    }

    function dn(e, t, n, r) {
        Ce.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = Ms.clamp(r, 0, 2 * Math.PI);
        var o, a, s, c = [],
            l = [],
            u = [],
            d = 1 / t,
            p = new h,
            f = new i;
        for (a = 0; a <= t; a++) {
            var m = n + a * d * r,
                g = Math.sin(m),
                v = Math.cos(m);
            for (s = 0; s <= e.length - 1; s++) p.x = e[s].x * g, p.y = e[s].y, p.z = e[s].x * v, l.push(p.x, p.y, p.z), f.x = a / t, f.y = s / (e.length - 1), u.push(f.x, f.y)
        }
        for (a = 0; a < t; a++)
            for (s = 0; s < e.length - 1; s++) {
                o = s + a * e.length;
                var y = o,
                    b = o + e.length,
                    x = o + e.length + 1,
                    w = o + 1;
                c.push(y, b, w), c.push(b, x, w)
            }
        if (this.setIndex(c), this.addAttribute("position", new Me(l, 3)), this.addAttribute("uv", new Me(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
            var _ = this.attributes.normal.array,
                M = new h,
                E = new h,
                T = new h;
            for (o = t * e.length * 3, a = 0, s = 0; a < e.length; a++, s += 3) M.x = _[s + 0], M.y = _[s + 1], M.z = _[s + 2], E.x = _[o + s + 0], E.y = _[o + s + 1], E.z = _[o + s + 2], T.addVectors(M, E).normalize(), _[s + 0] = _[o + s + 0] = T.x, _[s + 1] = _[o + s + 1] = T.y, _[s + 2] = _[o + s + 2] = T.z
        }
    }

    function pn(e, t) {
        Pe.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new fn(e, t)), this.mergeVertices()
    }

    function fn(e, t) {
        function n(e) {
            var n, s, l, h = i.length / 3,
                u = e.extractPoints(t),
                d = u.shape,
                p = u.holes;
            if (!1 === js.isClockWise(d))
                for (d = d.reverse(), n = 0, s = p.length; n < s; n++) l = p[n], !0 === js.isClockWise(l) && (p[n] = l.reverse());
            var f = js.triangulateShape(d, p);
            for (n = 0, s = p.length; n < s; n++) l = p[n], d = d.concat(l);
            for (n = 0, s = d.length; n < s; n++) {
                var m = d[n];
                i.push(m.x, m.y, 0), o.push(0, 0, 1), a.push(m.x, m.y)
            }
            for (n = 0, s = f.length; n < s; n++) {
                var g = f[n],
                    v = g[0] + h,
                    y = g[1] + h,
                    b = g[2] + h;
                r.push(v, y, b), c += 3
            }
        }
        Ce.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var r = [],
            i = [],
            o = [],
            a = [],
            s = 0,
            c = 0;
        if (!1 === Array.isArray(e)) n(e);
        else
            for (var l = 0; l < e.length; l++) n(e[l]), this.addGroup(s, c, l), s += c, c = 0;
        this.setIndex(r), this.addAttribute("position", new Me(i, 3)), this.addAttribute("normal", new Me(o, 3)), this.addAttribute("uv", new Me(a, 2))
    }

    function mn(e, t) {
        Ce.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        }, t = void 0 !== t ? t : 1;
        var n, r, i, o, a = [],
            s = Math.cos(Ms.DEG2RAD * t),
            c = [0, 0],
            l = {},
            h = ["a", "b", "c"];
        e.isBufferGeometry ? (o = new Pe, o.fromBufferGeometry(e)) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
        for (var u = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
            for (var m = d[p], g = 0; g < 3; g++) n = m[h[g]], r = m[h[(g + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), i = c[0] + "," + c[1], void 0 === l[i] ? l[i] = {
                index1: c[0],
                index2: c[1],
                face1: p,
                face2: void 0
            } : l[i].face2 = p;
        for (i in l) {
            var v = l[i];
            if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                var y = u[v.index1];
                a.push(y.x, y.y, y.z), y = u[v.index2], a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new Me(a, 3))
    }

    function gn(e, t, n, r, i, o, a, s) {
        Pe.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new vn(e, t, n, r, i, o, a, s)), this.mergeVertices()
    }

    function vn(e, t, n, r, o, a, s, c) {
        function l(n) {
            var o, a, l, v = new i,
                x = new h,
                w = 0,
                _ = !0 === n ? e : t,
                M = !0 === n ? 1 : -1;
            for (a = g, o = 1; o <= r; o++) p.push(0, y * M, 0), f.push(0, M, 0), m.push(.5, .5), g++;
            for (l = g, o = 0; o <= r; o++) {
                var E = o / r,
                    T = E * c + s,
                    S = Math.cos(T),
                    A = Math.sin(T);
                x.x = _ * A, x.y = y * M, x.z = _ * S, p.push(x.x, x.y, x.z), f.push(0, M, 0), v.x = .5 * S + .5, v.y = .5 * A * M + .5, m.push(v.x, v.y), g++
            }
            for (o = 0; o < r; o++) {
                var P = a + o,
                    C = l + o;
                !0 === n ? d.push(C, C + 1, P) : d.push(C + 1, C, P), w += 3
            }
            u.addGroup(b, w, !0 === n ? 1 : 2), b += w
        }
        Ce.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: o,
            openEnded: a,
            thetaStart: s,
            thetaLength: c
        };
        var u = this;
        e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, n = void 0 !== n ? n : 100, r = Math.floor(r) || 8, o = Math.floor(o) || 1, a = void 0 !== a && a, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI;
        var d = [],
            p = [],
            f = [],
            m = [],
            g = 0,
            v = [],
            y = n / 2,
            b = 0;
        ! function() {
            var i, a, l = new h,
                x = new h,
                w = 0,
                _ = (t - e) / n;
            for (a = 0; a <= o; a++) {
                var M = [],
                    E = a / o,
                    T = E * (t - e) + e;
                for (i = 0; i <= r; i++) {
                    var S = i / r,
                        A = S * c + s,
                        P = Math.sin(A),
                        C = Math.cos(A);
                    x.x = T * P, x.y = -E * n + y, x.z = T * C, p.push(x.x, x.y, x.z), l.set(P, _, C).normalize(), f.push(l.x, l.y, l.z), m.push(S, 1 - E), M.push(g++)
                }
                v.push(M)
            }
            for (i = 0; i < r; i++)
                for (a = 0; a < o; a++) {
                    var L = v[a][i],
                        R = v[a + 1][i],
                        I = v[a + 1][i + 1],
                        O = v[a][i + 1];
                    d.push(L, R, O), d.push(R, I, O), w += 6
                }
            u.addGroup(b, w, 0), b += w
        }(), !1 === a && (e > 0 && l(!0), t > 0 && l(!1)), this.setIndex(d), this.addAttribute("position", new Me(p, 3)), this.addAttribute("normal", new Me(f, 3)), this.addAttribute("uv", new Me(m, 2))
    }

    function yn(e, t, n, r, i, o, a) {
        gn.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function bn(e, t, n, r, i, o, a) {
        vn.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function xn(e, t, n, r) {
        Pe.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, this.fromBufferGeometry(new wn(e, t, n, r)), this.mergeVertices()
    }

    function wn(e, t, n, r) {
        Ce.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var o, a, s = [],
            c = [],
            l = [],
            u = [],
            d = new h,
            p = new i;
        for (c.push(0, 0, 0), l.push(0, 0, 1), u.push(.5, .5), a = 0, o = 3; a <= t; a++, o += 3) {
            var f = n + a / t * r;
            d.x = e * Math.cos(f), d.y = e * Math.sin(f), c.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (c[o] / e + 1) / 2, p.y = (c[o + 1] / e + 1) / 2, u.push(p.x, p.y)
        }
        for (o = 1; o <= t; o++) s.push(o, o + 1, 0);
        this.setIndex(s), this.addAttribute("position", new Me(c, 3)), this.addAttribute("normal", new Me(l, 3)), this.addAttribute("uv", new Me(u, 2))
    }

    function _n(e) {
        Q.call(this, {
            uniforms: ks.merge([Os.lights, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ds.shadow_vert,
            fragmentShader: Ds.shadow_frag
        }), this.lights = !0, this.transparent = !0, Object.defineProperties(this, {
            opacity: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.opacity.value
                },
                set: function(e) {
                    this.uniforms.opacity.value = e
                }
            }
        }), this.setValues(e)
    }

    function Mn(e) {
        Q.call(this, e), this.type = "RawShaderMaterial"
    }

    function En(e) {
        K.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new q(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Tn(e) {
        En.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
    }

    function Sn(e) {
        K.call(this), this.type = "MeshPhongMaterial", this.color = new q(16777215), this.specular = new q(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function An(e) {
        Sn.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function Pn(e) {
        K.call(this, e), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Cn(e) {
        K.call(this), this.type = "MeshLambertMaterial", this.color = new q(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new q(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Ln(e) {
        K.call(this), this.type = "LineDashedMaterial", this.color = new q(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(e)
    }

    function Rn(e, t, n) {
        var r = this,
            i = !1,
            o = 0,
            a = 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
            a++, !1 === i && void 0 !== r.onStart && r.onStart(e, o, a), i = !0
        }, this.itemEnd = function(e) {
            o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function(e) {
            void 0 !== r.onError && r.onError(e)
        }
    }

    function In(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function On(e) {
        this.manager = void 0 !== e ? e : Ws, this._parser = null
    }

    function kn(e) {
        this.manager = void 0 !== e ? e : Ws, this._parser = null
    }

    function Dn(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function Nn(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function Bn(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function Un(e, t) {
        he.call(this), this.type = "Light", this.color = new q(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Fn(e, t, n) {
        Un.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(he.DefaultUp), this.updateMatrix(), this.groundColor = new q(t)
    }

    function zn(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new u
    }

    function jn() {
        zn.call(this, new Ne(50, 1, .5, 500))
    }

    function Hn(e, t, n, r, i, o) {
        Un.call(this, e, t), this.type = "SpotLight", this.position.copy(he.DefaultUp), this.updateMatrix(), this.target = new he, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new jn
    }

    function Vn(e, t, n, r) {
        Un.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new zn(new Ne(90, 1, .5, 500))
    }

    function Gn() {
        zn.call(this, new Be(-5, 5, 5, -5, .5, 500))
    }

    function Wn(e, t) {
        Un.call(this, e, t), this.type = "DirectionalLight", this.position.copy(he.DefaultUp), this.updateMatrix(), this.target = new he, this.shadow = new Gn
    }

    function $n(e, t) {
        Un.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function Xn(e, t, n, r) {
        Un.call(this, e, t), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
    }

    function qn(e, t, n, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
    }

    function Yn(e, t, n, r) {
        qn.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Zn(e, t, n, r) {
        qn.call(this, e, t, n, r)
    }

    function Jn(e, t, n, r) {
        qn.call(this, e, t, n, r)
    }

    function Kn(e, t, n, r) {
        if (void 0 === e) throw new Error("track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("no keyframes in track named " + e);
        this.name = e, this.times = $s.convertArray(t, this.TimeBufferType), this.values = $s.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation), this.validate(), this.optimize()
    }

    function Qn(e, t, n, r) {
        Kn.call(this, e, t, n, r)
    }

    function er(e, t, n, r) {
        qn.call(this, e, t, n, r)
    }

    function tr(e, t, n, r) {
        Kn.call(this, e, t, n, r)
    }

    function nr(e, t, n, r) {
        Kn.call(this, e, t, n, r)
    }

    function rr(e, t, n, r) {
        Kn.call(this, e, t, n, r)
    }

    function ir(e, t, n) {
        Kn.call(this, e, t, n)
    }

    function or(e, t, n, r) {
        Kn.call(this, e, t, n, r)
    }

    function ar(e, t, n, r) {
        Kn.apply(this, arguments)
    }

    function sr(e, t, n) {
        this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Ms.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
    }

    function cr(e) {
        this.manager = void 0 !== e ? e : Ws, this.textures = {}
    }

    function lr(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function hr() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }

    function ur(e) {
        "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : Ws, this.withCredentials = !1
    }

    function dr(e) {
        this.manager = void 0 !== e ? e : Ws, this.texturePath = ""
    }

    function pr(e, t, n, r, i) {
        var o = .5 * (r - t),
            a = .5 * (i - n),
            s = e * e;
        return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
    }

    function fr(e, t) {
        var n = 1 - e;
        return n * n * t
    }

    function mr(e, t) {
        return 2 * (1 - e) * e * t
    }

    function gr(e, t) {
        return e * e * t
    }

    function vr(e, t, n, r) {
        return fr(e, t) + mr(e, n) + gr(e, r)
    }

    function yr(e, t) {
        var n = 1 - e;
        return n * n * n * t
    }

    function br(e, t) {
        var n = 1 - e;
        return 3 * n * n * e * t
    }

    function xr(e, t) {
        return 3 * (1 - e) * e * e * t
    }

    function wr(e, t) {
        return e * e * e * t
    }

    function _r(e, t, n, r, i) {
        return yr(e, t) + br(e, n) + xr(e, r) + wr(e, i)
    }

    function Mr() {
        this.arcLengthDivisions = 200
    }

    function Er(e, t) {
        Mr.call(this), this.v1 = e, this.v2 = t
    }

    function Tr() {
        Mr.call(this), this.curves = [], this.autoClose = !1
    }

    function Sr(e, t, n, r, i, o, a, s) {
        Mr.call(this), this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = a, this.aRotation = s || 0
    }

    function Ar(e) {
        Mr.call(this), this.points = void 0 === e ? [] : e
    }

    function Pr(e, t, n, r) {
        Mr.call(this), this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
    }

    function Cr(e, t, n) {
        Mr.call(this), this.v0 = e, this.v1 = t, this.v2 = n
    }

    function Lr(e) {
        Tr.call(this), this.currentPoint = new i, e && this.fromPoints(e)
    }

    function Rr() {
        Lr.apply(this, arguments), this.holes = []
    }

    function Ir() {
        this.subPaths = [], this.currentPath = null
    }

    function Or(e) {
        this.data = e
    }

    function kr(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function Dr(e) {
        this.manager = void 0 !== e ? e : Ws
    }

    function Nr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ne, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ne, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function Br(e, t, n) {
        he.call(this), this.type = "CubeCamera";
        var r = new Ne(90, 1, e, t);
        r.up.set(0, -1, 0), r.lookAt(new h(1, 0, 0)), this.add(r);
        var i = new Ne(90, 1, e, t);
        i.up.set(0, -1, 0), i.lookAt(new h(-1, 0, 0)), this.add(i);
        var o = new Ne(90, 1, e, t);
        o.up.set(0, 0, 1), o.lookAt(new h(0, 1, 0)), this.add(o);
        var a = new Ne(90, 1, e, t);
        a.up.set(0, 0, -1), a.lookAt(new h(0, -1, 0)), this.add(a);
        var s = new Ne(90, 1, e, t);
        s.up.set(0, -1, 0), s.lookAt(new h(0, 0, 1)), this.add(s);
        var l = new Ne(90, 1, e, t);
        l.up.set(0, -1, 0), l.lookAt(new h(0, 0, -1)), this.add(l);
        var u = {
            format: Fa,
            magFilter: Ma,
            minFilter: Ma
        };
        this.renderTarget = new c(n, n, u), this.renderTarget.texture.name = "CubeCamera", this.updateCubeMap = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget,
                c = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, r, n), n.activeCubeFace = 1, e.render(t, i, n), n.activeCubeFace = 2, e.render(t, o, n), n.activeCubeFace = 3, e.render(t, a, n), n.activeCubeFace = 4, e.render(t, s, n), n.texture.generateMipmaps = c, n.activeCubeFace = 5, e.render(t, l, n), e.setRenderTarget(null)
        }
    }

    function Ur(e) {
        Ne.call(this), this.enabled = !1, this.cameras = e || []
    }

    function Fr() {
        he.call(this), this.type = "AudioListener", this.context = ec.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function zr(e) {
        he.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function jr(e) {
        zr.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function Hr(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Vr(e, t, n) {
        this.binding = e, this.valueSize = n;
        var r, i = Float64Array;
        switch (t) {
            case "quaternion":
                r = this._slerp;
                break;
            case "string":
            case "bool":
                i = Array, r = this._select;
                break;
            default:
                r = this._lerp
        }
        this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }

    function Gr(e, t, n) {
        var r = n || Wr.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r)
    }

    function Wr(e, t, n) {
        this.path = t, this.parsedPath = n || Wr.parseTrackName(t), this.node = Wr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function $r(e) {
        this.uuid = Ms.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var n = 0, r = arguments.length; n !== r; ++n) t[arguments[n].uuid] = n;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var i = this;
        this.stats = {
            objects: {get total() {
                    return i._objects.length
                },
                get inUse() {
                    return this.total - i.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return i._bindings.length
            }
        }
    }

    function Xr(e, t, n) {
        this._mixer = e, this._clip = t, this._localRoot = n || null;
        for (var r = t.tracks, i = r.length, o = new Array(i), a = {
                endingStart: ss,
                endingEnd: ss
            }, s = 0; s !== i; ++s) {
            var c = r[s].createInterpolant(null);
            o[s] = c, c.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ns, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function qr(e) {
        this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Yr(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
    }

    function Zr() {
        Ce.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Jr(e, t, n, r) {
        this.uuid = Ms.generateUUID(), this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
    }

    function Kr(e, t) {
        this.uuid = Ms.generateUUID(), this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0
    }

    function Qr(e, t, n) {
        Kr.call(this, e, t), this.meshPerAttribute = n || 1
    }

    function ei(e, t, n) {
        me.call(this, e, t), this.meshPerAttribute = n || 1
    }

    function ti(e, t, n, r) {
        this.ray = new se(e, t), this.near = n || 0, this.far = r || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function ni(e, t) {
        return e.distance - t.distance
    }

    function ri(e, t, n, r) {
        if (!1 !== e.visible && (e.raycast(t, n), !0 === r))
            for (var i = e.children, o = 0, a = i.length; o < a; o++) ri(i[o], t, n, !0)
    }

    function ii(e) {
        this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    function oi(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
    }

    function ai(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
    }

    function si(e, t) {
        Le.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
        var n = this.geometry.morphTargets.length,
            r = n - 1,
            i = n / 1;
        this.createAnimation("__default", 0, r, i), this.setAnimationWeight("__default", 1)
    }

    function ci(e) {
        he.call(this), this.material = e, this.render = function(e) {}
    }

    function li(e, t, n, r) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var i = void 0 !== n ? n : 16711680,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var c = new Ce,
            l = new Me(2 * a * 3, 3);
        c.addAttribute("position", l), Pt.call(this, c, new St({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function hi(e) {
        he.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        for (var t = new Ce, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, i = 1; r < 32; r++, i++) {
            var o = r / 32 * Math.PI * 2,
                a = i / 32 * Math.PI * 2;
            n.push(Math.cos(o), Math.sin(o), 1, Math.cos(a), Math.sin(a), 1)
        }
        t.addAttribute("position", new Me(n, 3));
        var s = new St({
            fog: !1
        });
        this.cone = new Pt(t, s), this.add(this.cone), this.update()
    }

    function ui(e) {
        this.bones = this.getBoneList(e);
        for (var t = new Ce, n = [], r = [], i = new q(0, 0, 1), o = new q(0, 1, 0), a = 0; a < this.bones.length; a++) {
            var s = this.bones[a];
            s.parent && s.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(i.r, i.g, i.b), r.push(o.r, o.g, o.b))
        }
        t.addAttribute("position", new Me(n, 3)), t.addAttribute("color", new Me(r, 3));
        var c = new St({
            vertexColors: Eo,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Pt.call(this, t, c), this.root = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function di(e, t) {
        this.light = e, this.light.updateMatrixWorld();
        var n = new cn(t, 4, 2),
            r = new fe({
                wireframe: !0,
                fog: !1
            });
        r.color.copy(this.light.color), Le.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }

    function pi(e) {
        he.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        var t = new St({
                color: e.color
            }),
            n = new Ce;
        n.addAttribute("position", new me(new Float32Array(15), 3)), this.add(new At(n, t)), this.update()
    }

    function fi(e, t) {
        he.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
        var n = new Wt(t);
        n.rotateY(.5 * Math.PI);
        var r = new fe({
                vertexColors: Eo,
                wireframe: !0
            }),
            i = n.getAttribute("position"),
            o = new Float32Array(3 * i.count);
        n.addAttribute("color", new me(o, 3)), this.add(new Le(n, r)), this.update()
    }

    function mi(e, t, n, r) {
        e = e || 10, t = t || 10, n = new q(void 0 !== n ? n : 4473924), r = new q(void 0 !== r ? r : 8947848);
        for (var i = t / 2, o = e / t, a = e / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= t; l++, u += o) {
            s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
            var d = l === i ? n : r;
            d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3
        }
        var p = new Ce;
        p.addAttribute("position", new Me(s, 3)), p.addAttribute("color", new Me(c, 3));
        var f = new St({
            vertexColors: Eo
        });
        Pt.call(this, p, f)
    }

    function gi(e, t, n, r, i, o) {
        e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new q(void 0 !== i ? i : 4473924), o = new q(void 0 !== o ? o : 8947848);
        var a, s, c, l, h, u, d, p = [],
            f = [];
        for (l = 0; l <= t; l++) c = l / t * (2 * Math.PI), a = Math.sin(c) * e, s = Math.cos(c) * e, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & l ? i : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
        for (l = 0; l <= n; l++)
            for (d = 1 & l ? i : o, u = e - e / n * l, h = 0; h < r; h++) c = h / r * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b), c = (h + 1) / r * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b);
        var m = new Ce;
        m.addAttribute("position", new Me(p, 3)), m.addAttribute("color", new Me(f, 3));
        var g = new St({
            vertexColors: Eo
        });
        Pt.call(this, m, g)
    }

    function vi(e, t, n, r) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var i = void 0 !== n ? n : 16776960,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new Ce,
            l = new Me(2 * a * 3, 3);
        c.addAttribute("position", l), Pt.call(this, c, new St({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function yi(e, t) {
        he.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, void 0 === t && (t = 1);
        var n = new Ce;
        n.addAttribute("position", new Me([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var r = new St({
            fog: !1
        });
        this.add(new At(n, r)), n = new Ce, n.addAttribute("position", new Me([0, 0, 0, 0, 0, 1], 3)), this.add(new At(n, r)), this.update()
    }

    function bi(e) {
        function t(e, t, r) {
            n(e, r), n(t, r)
        }

        function n(e, t) {
            o.push(0, 0, 0), a.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(o.length / 3 - 1)
        }
        var r = new Ce,
            i = new St({
                color: 16777215,
                vertexColors: Mo
            }),
            o = [],
            a = [],
            s = {},
            c = new q(16755200),
            l = new q(16711680),
            h = new q(43775),
            u = new q(16777215),
            d = new q(3355443);
        t("n1", "n2", c), t("n2", "n4", c), t("n4", "n3", c), t("n3", "n1", c), t("f1", "f2", c), t("f2", "f4", c), t("f4", "f3", c), t("f3", "f1", c), t("n1", "f1", c), t("n2", "f2", c), t("n3", "f3", c), t("n4", "f4", c), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), t("p", "n4", l), t("u1", "u2", h), t("u2", "u3", h), t("u3", "u1", h), t("c", "t", u), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), r.addAttribute("position", new Me(o, 3)), r.addAttribute("color", new Me(a, 3)), Pt.call(this, r, i), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
    }

    function xi(e, t) {
        this.object = e, void 0 === t && (t = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Float32Array(24),
            i = new Ce;
        i.setIndex(new me(n, 1)), i.addAttribute("position", new me(r, 3)), Pt.call(this, i, new St({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function wi(e, t, n, r, i, o) {
        he.call(this), void 0 === r && (r = 16776960), void 0 === n && (n = 1), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === tc && (tc = new Ce, tc.addAttribute("position", new Me([0, 0, 0, 0, 1, 0], 3)), nc = new vn(0, .5, 1, 5, 1), nc.translate(0, -.5, 0)), this.position.copy(t), this.line = new At(tc, new St({
            color: r
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Le(nc, new fe({
            color: r
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o)
    }

    function _i(e) {
        e = e || 1;
        var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            r = new Ce;
        r.addAttribute("position", new Me(t, 3)), r.addAttribute("color", new Me(n, 3));
        var i = new St({
            vertexColors: Eo
        });
        Pt.call(this, r, i)
    }

    function Mi() {
        function e(e, o, a, s) {
            t = e, n = a, r = -3 * e + 3 * o - 2 * a - s, i = 2 * e - 2 * o + a + s
        }
        var t = 0,
            n = 0,
            r = 0,
            i = 0;
        return {
            initCatmullRom: function(t, n, r, i, o) {
                e(n, r, o * (r - t), o * (i - n))
            },
            initNonuniformCatmullRom: function(t, n, r, i, o, a, s) {
                var c = (n - t) / o - (r - t) / (o + a) + (r - n) / a,
                    l = (r - n) / a - (i - n) / (a + s) + (i - r) / s;
                c *= a, l *= a, e(n, r, c, l)
            },
            calc: function(e) {
                var o = e * e;
                return t + n * e + r * o + i * (o * e)
            }
        }
    }

    function Ei(e) {
        Mr.call(this), this.points = e || [], this.closed = !1
    }

    function Ti(e, t, n, r) {
        Mr.call(this), this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
    }

    function Si(e, t, n) {
        Mr.call(this), this.v0 = e, this.v1 = t, this.v2 = n
    }

    function Ai(e, t) {
        Mr.call(this), this.v1 = e, this.v2 = t
    }

    function Pi(e, t, n, r, i, o) {
        Sr.call(this, e, t, n, n, r, i, o)
    }

    function Ci(e, t, n, r, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new pe(e, t, n, i, o, a)
    }

    function Li(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }

    function Ri(e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
            return e.slice()
        }, e
    }

    function Ii(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Rt(e, t)
    }

    function Oi(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new wt(e)
    }

    function ki(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Rt(e, t)
    }

    function Di(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Lt(e)
    }

    function Ni(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Lt(e)
    }

    function Bi(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Lt(e)
    }

    function Ui(e, t, n) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new h(e, t, n)
    }

    function Fi(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new me(e, t).setDynamic(!0)
    }

    function zi(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ge(e, t)
    }

    function ji(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ve(e, t)
    }

    function Hi(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new ye(e, t)
    }

    function Vi(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new be(e, t)
    }

    function Gi(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new xe(e, t)
    }

    function Wi(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new we(e, t)
    }

    function $i(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new _e(e, t)
    }

    function Xi(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Me(e, t)
    }

    function qi(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Ee(e, t)
    }

    function Yi(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ei.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function Zi(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ei.call(this, e), this.type = "catmullrom"
    }

    function Ji(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ei.call(this, e), this.type = "catmullrom"
    }

    function Ki(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new xi(e, t)
    }

    function Qi(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Pt(new mn(e.geometry), new St({
            color: void 0 !== t ? t : 16777215
        }))
    }

    function eo(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Pt(new Bt(e.geometry), new St({
            color: void 0 !== t ? t : 16777215
        }))
    }

    function to(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new In(e)
    }

    function no(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new kn(e)
    }

    function ro() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
        }, this.unprojectVector = function(e, t) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }

    function io() {
        console.error("THREE.CanvasRenderer%20has%20been%20moved%20to/examples/js/renderers/CanvasRenderer.html"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n.d(t, "WebGLRenderTargetCube", function() {
        return c
    }), n.d(t, "WebGLRenderTarget", function() {
        return s
    }), n.d(t, "WebGLRenderer", function() {
        return mt
    }), n.d(t, "ShaderLib", function() {
        return Ns
    }), n.d(t, "UniformsLib", function() {
        return Os
    }), n.d(t, "UniformsUtils", function() {
        return ks
    }), n.d(t, "ShaderChunk", function() {
        return Ds
    }), n.d(t, "FogExp2", function() {
        return gt
    }), n.d(t, "Fog", function() {
        return vt
    }), n.d(t, "Scene", function() {
        return yt
    }), n.d(t, "LensFlare", function() {
        return bt
    }), n.d(t, "Sprite", function() {
        return wt
    }), n.d(t, "LOD", function() {
        return _t
    }), n.d(t, "SkinnedMesh", function() {
        return Tt
    }), n.d(t, "Skeleton", function() {
        return Mt
    }), n.d(t, "Bone", function() {
        return Et
    }), n.d(t, "Mesh", function() {
        return Le
    }), n.d(t, "LineSegments", function() {
        return Pt
    }), n.d(t, "LineLoop", function() {
        return Ct
    }), n.d(t, "Line", function() {
        return At
    }), n.d(t, "Points", function() {
        return Rt
    }), n.d(t, "Group", function() {
        return It
    }), n.d(t, "VideoTexture", function() {
        return Ot
    }), n.d(t, "DataTexture", function() {
        return d
    }), n.d(t, "CompressedTexture", function() {
        return kt
    }), n.d(t, "CubeTexture", function() {
        return p
    }), n.d(t, "CanvasTexture", function() {
        return Dt
    }), n.d(t, "DepthTexture", function() {
        return Nt
    }), n.d(t, "Texture", function() {
        return o
    }), n.d(t, "CompressedTextureLoader", function() {
        return On
    }), n.d(t, "DataTextureLoader", function() {
        return kn
    }), n.d(t, "CubeTextureLoader", function() {
        return Nn
    }), n.d(t, "TextureLoader", function() {
        return Bn
    }), n.d(t, "ObjectLoader", function() {
        return dr
    }), n.d(t, "MaterialLoader", function() {
        return cr
    }), n.d(t, "BufferGeometryLoader", function() {
        return lr
    }), n.d(t, "DefaultLoadingManager", function() {
        return Ws
    }), n.d(t, "LoadingManager", function() {
        return Rn
    }), n.d(t, "JSONLoader", function() {
        return ur
    }), n.d(t, "ImageLoader", function() {
        return Dn
    }), n.d(t, "FontLoader", function() {
        return kr
    }), n.d(t, "FileLoader", function() {
        return In
    }), n.d(t, "Loader", function() {
        return hr
    }), n.d(t, "Cache", function() {
        return Gs
    }), n.d(t, "AudioLoader", function() {
        return Dr
    }), n.d(t, "SpotLightShadow", function() {
        return jn
    }), n.d(t, "SpotLight", function() {
        return Hn
    }), n.d(t, "PointLight", function() {
        return Vn
    }), n.d(t, "RectAreaLight", function() {
        return Xn
    }), n.d(t, "HemisphereLight", function() {
        return Fn
    }), n.d(t, "DirectionalLightShadow", function() {
        return Gn
    }), n.d(t, "DirectionalLight", function() {
        return Wn
    }), n.d(t, "AmbientLight", function() {
        return $n
    }), n.d(t, "LightShadow", function() {
        return zn
    }), n.d(t, "Light", function() {
        return Un
    }), n.d(t, "StereoCamera", function() {
        return Nr
    }), n.d(t, "PerspectiveCamera", function() {
        return Ne
    }), n.d(t, "OrthographicCamera", function() {
        return Be
    }), n.d(t, "CubeCamera", function() {
        return Br
    }), n.d(t, "ArrayCamera", function() {
        return Ur
    }), n.d(t, "Camera", function() {
        return De
    }), n.d(t, "AudioListener", function() {
        return Fr
    }), n.d(t, "PositionalAudio", function() {
        return jr
    }), n.d(t, "AudioContext", function() {
        return ec
    }), n.d(t, "AudioAnalyser", function() {
        return Hr
    }), n.d(t, "Audio", function() {
        return zr
    }), n.d(t, "VectorKeyframeTrack", function() {
        return Qn
    }), n.d(t, "StringKeyframeTrack", function() {
        return rr
    }), n.d(t, "QuaternionKeyframeTrack", function() {
        return tr
    }), n.d(t, "NumberKeyframeTrack", function() {
        return nr
    }), n.d(t, "ColorKeyframeTrack", function() {
        return or
    }), n.d(t, "BooleanKeyframeTrack", function() {
        return ir
    }), n.d(t, "PropertyMixer", function() {
        return Vr
    }), n.d(t, "PropertyBinding", function() {
        return Wr
    }), n.d(t, "KeyframeTrack", function() {
        return ar
    }), n.d(t, "AnimationUtils", function() {
        return $s
    }), n.d(t, "AnimationObjectGroup", function() {
        return $r
    }), n.d(t, "AnimationMixer", function() {
        return qr
    }), n.d(t, "AnimationClip", function() {
        return sr
    }), n.d(t, "Uniform", function() {
        return Yr
    }), n.d(t, "InstancedBufferGeometry", function() {
        return Zr
    }), n.d(t, "BufferGeometry", function() {
        return Ce
    }), n.d(t, "GeometryIdCount", function() {
        return Ae
    }), n.d(t, "Geometry", function() {
        return Pe
    }), n.d(t, "InterleavedBufferAttribute", function() {
        return Jr
    }), n.d(t, "InstancedInterleavedBuffer", function() {
        return Qr
    }), n.d(t, "InterleavedBuffer", function() {
        return Kr
    }), n.d(t, "InstancedBufferAttribute", function() {
        return ei
    }), n.d(t, "Face3", function() {
        return pe
    }), n.d(t, "Object3D", function() {
        return he
    }), n.d(t, "Raycaster", function() {
        return ti
    }), n.d(t, "Layers", function() {
        return le
    }), n.d(t, "EventDispatcher", function() {
        return r
    }), n.d(t, "Clock", function() {
        return ii
    }), n.d(t, "QuaternionLinearInterpolant", function() {
        return er
    }), n.d(t, "LinearInterpolant", function() {
        return Zn
    }), n.d(t, "DiscreteInterpolant", function() {
        return Jn
    }), n.d(t, "CubicInterpolant", function() {
        return Yn
    }), n.d(t, "Interpolant", function() {
        return qn
    }), n.d(t, "Triangle", function() {
        return de
    }), n.d(t, "Math", function() {
        return Ms
    }), n.d(t, "Spherical", function() {
        return oi
    }), n.d(t, "Cylindrical", function() {
        return ai
    }), n.d(t, "Plane", function() {
        return ie
    }), n.d(t, "Frustum", function() {
        return oe
    }), n.d(t, "Sphere", function() {
        return ne
    }), n.d(t, "Ray", function() {
        return se
    }), n.d(t, "Matrix4", function() {
        return u
    }), n.d(t, "Matrix3", function() {
        return re
    }), n.d(t, "Box3", function() {
        return te
    }), n.d(t, "Box2", function() {
        return Y
    }), n.d(t, "Line3", function() {
        return ue
    }), n.d(t, "Euler", function() {
        return ce
    }), n.d(t, "Vector4", function() {
        return a
    }), n.d(t, "Vector3", function() {
        return h
    }), n.d(t, "Vector2", function() {
        return i
    }), n.d(t, "Quaternion", function() {
        return l
    }), n.d(t, "Color", function() {
        return q
    }), n.d(t, "MorphBlendMesh", function() {
        return si
    }), n.d(t, "ImmediateRenderObject", function() {
        return ci
    }), n.d(t, "VertexNormalsHelper", function() {
        return li
    }), n.d(t, "SpotLightHelper", function() {
        return hi
    }), n.d(t, "SkeletonHelper", function() {
        return ui
    }), n.d(t, "PointLightHelper", function() {
        return di
    }), n.d(t, "RectAreaLightHelper", function() {
        return pi
    }), n.d(t, "HemisphereLightHelper", function() {
        return fi
    }), n.d(t, "GridHelper", function() {
        return mi
    }), n.d(t, "PolarGridHelper", function() {
        return gi
    }), n.d(t, "FaceNormalsHelper", function() {
        return vi
    }), n.d(t, "DirectionalLightHelper", function() {
        return yi
    }), n.d(t, "CameraHelper", function() {
        return bi
    }), n.d(t, "BoxHelper", function() {
        return xi
    }), n.d(t, "ArrowHelper", function() {
        return wi
    }), n.d(t, "AxisHelper", function() {
        return _i
    }), n.d(t, "CatmullRomCurve3", function() {
        return Ei
    }), n.d(t, "CubicBezierCurve3", function() {
        return Ti
    }), n.d(t, "QuadraticBezierCurve3", function() {
        return Si
    }), n.d(t, "LineCurve3", function() {
        return Ai
    }), n.d(t, "ArcCurve", function() {
        return Pi
    }), n.d(t, "EllipseCurve", function() {
        return Sr
    }), n.d(t, "SplineCurve", function() {
        return Ar
    }), n.d(t, "CubicBezierCurve", function() {
        return Pr
    }), n.d(t, "QuadraticBezierCurve", function() {
        return Cr
    }), n.d(t, "LineCurve", function() {
        return Er
    }), n.d(t, "Shape", function() {
        return Rr
    }), n.d(t, "Path", function() {
        return Lr
    }), n.d(t, "ShapePath", function() {
        return Ir
    }), n.d(t, "Font", function() {
        return Or
    }), n.d(t, "CurvePath", function() {
        return Tr
    }), n.d(t, "Curve", function() {
        return Mr
    }), n.d(t, "ShapeUtils", function() {
        return js
    }), n.d(t, "SceneUtils", function() {
        return sc
    }), n.d(t, "WireframeGeometry", function() {
        return Bt
    }), n.d(t, "ParametricGeometry", function() {
        return Ut
    }), n.d(t, "ParametricBufferGeometry", function() {
        return Ft
    }), n.d(t, "TetrahedronGeometry", function() {
        return Ht
    }), n.d(t, "TetrahedronBufferGeometry", function() {
        return Vt
    }), n.d(t, "OctahedronGeometry", function() {
        return Gt
    }), n.d(t, "OctahedronBufferGeometry", function() {
        return Wt
    }), n.d(t, "IcosahedronGeometry", function() {
        return $t
    }), n.d(t, "IcosahedronBufferGeometry", function() {
        return Xt
    }), n.d(t, "DodecahedronGeometry", function() {
        return qt
    }), n.d(t, "DodecahedronBufferGeometry", function() {
        return Yt
    }), n.d(t, "PolyhedronGeometry", function() {
        return zt
    }), n.d(t, "PolyhedronBufferGeometry", function() {
        return jt
    }), n.d(t, "TubeGeometry", function() {
        return Zt
    }), n.d(t, "TubeBufferGeometry", function() {
        return Jt
    }), n.d(t, "TorusKnotGeometry", function() {
        return Kt
    }), n.d(t, "TorusKnotBufferGeometry", function() {
        return Qt
    }), n.d(t, "TorusGeometry", function() {
        return en
    }), n.d(t, "TorusBufferGeometry", function() {
        return tn
    }), n.d(t, "TextGeometry", function() {
        return on
    }), n.d(t, "TextBufferGeometry", function() {
        return an
    }), n.d(t, "SphereGeometry", function() {
        return sn
    }), n.d(t, "SphereBufferGeometry", function() {
        return cn
    }), n.d(t, "RingGeometry", function() {
        return ln
    }), n.d(t, "RingBufferGeometry", function() {
        return hn
    }), n.d(t, "PlaneGeometry", function() {
        return Oe
    }), n.d(t, "PlaneBufferGeometry", function() {
        return ke
    }), n.d(t, "LatheGeometry", function() {
        return un
    }), n.d(t, "LatheBufferGeometry", function() {
        return dn
    }), n.d(t, "ShapeGeometry", function() {
        return pn
    }), n.d(t, "ShapeBufferGeometry", function() {
        return fn
    }), n.d(t, "ExtrudeGeometry", function() {
        return nn
    }), n.d(t, "ExtrudeBufferGeometry", function() {
        return rn
    }), n.d(t, "EdgesGeometry", function() {
        return mn
    }), n.d(t, "ConeGeometry", function() {
        return yn
    }), n.d(t, "ConeBufferGeometry", function() {
        return bn
    }), n.d(t, "CylinderGeometry", function() {
        return gn
    }), n.d(t, "CylinderBufferGeometry", function() {
        return vn
    }), n.d(t, "CircleGeometry", function() {
        return xn
    }), n.d(t, "CircleBufferGeometry", function() {
        return wn
    }), n.d(t, "BoxGeometry", function() {
        return Re
    }), n.d(t, "BoxBufferGeometry", function() {
        return Ie
    }), n.d(t, "ShadowMaterial", function() {
        return _n
    }), n.d(t, "SpriteMaterial", function() {
        return xt
    }), n.d(t, "RawShaderMaterial", function() {
        return Mn
    }), n.d(t, "ShaderMaterial", function() {
        return Q
    }), n.d(t, "PointsMaterial", function() {
        return Lt
    });
    n.d(t, "MeshPhysicalMaterial", function() {
        return Tn
    }), n.d(t, "MeshStandardMaterial", function() {
        return En
    }), n.d(t, "MeshPhongMaterial", function() {
        return Sn
    }), n.d(t, "MeshToonMaterial", function() {
        return An
    }), n.d(t, "MeshNormalMaterial", function() {
        return Pn
    }), n.d(t, "MeshLambertMaterial", function() {
        return Cn
    }), n.d(t, "MeshDepthMaterial", function() {
        return ee
    }), n.d(t, "MeshBasicMaterial", function() {
        return fe
    }), n.d(t, "LineDashedMaterial", function() {
        return Ln
    }), n.d(t, "LineBasicMaterial", function() {
        return St
    }), n.d(t, "Material", function() {
        return K
    }), n.d(t, "Float64BufferAttribute", function() {
        return Ee
    }), n.d(t, "Float32BufferAttribute", function() {
        return Me
    }), n.d(t, "Uint32BufferAttribute", function() {
        return _e
    }), n.d(t, "Int32BufferAttribute", function() {
        return we
    }), n.d(t, "Uint16BufferAttribute", function() {
        return xe
    }), n.d(t, "Int16BufferAttribute", function() {
        return be
    }), n.d(t, "Uint8ClampedBufferAttribute", function() {
        return ye
    }), n.d(t, "Uint8BufferAttribute", function() {
        return ve
    }), n.d(t, "Int8BufferAttribute", function() {
        return ge
    }), n.d(t, "BufferAttribute", function() {
        return me
    }), n.d(t, "REVISION", function() {
        return oo
    }), n.d(t, "MOUSE", function() {
        return ao
    }), n.d(t, "CullFaceNone", function() {
        return so
    }), n.d(t, "CullFaceBack", function() {
        return co
    }), n.d(t, "CullFaceFront", function() {
        return lo
    }), n.d(t, "CullFaceFrontBack", function() {
        return ho
    }), n.d(t, "FrontFaceDirectionCW", function() {
        return uo
    }), n.d(t, "FrontFaceDirectionCCW", function() {
        return po
    }), n.d(t, "BasicShadowMap", function() {
        return fo
    }), n.d(t, "PCFShadowMap", function() {
        return mo
    }), n.d(t, "PCFSoftShadowMap", function() {
        return go
    }), n.d(t, "FrontSide", function() {
        return vo
    }), n.d(t, "BackSide", function() {
        return yo
    }), n.d(t, "DoubleSide", function() {
        return bo
    }), n.d(t, "FlatShading", function() {
        return xo
    }), n.d(t, "SmoothShading", function() {
        return wo
    }), n.d(t, "NoColors", function() {
        return _o
    }), n.d(t, "FaceColors", function() {
        return Mo
    }), n.d(t, "VertexColors", function() {
        return Eo
    }), n.d(t, "NoBlending", function() {
        return To
    }), n.d(t, "NormalBlending", function() {
        return So
    }), n.d(t, "AdditiveBlending", function() {
        return Ao
    }), n.d(t, "SubtractiveBlending", function() {
        return Po
    }), n.d(t, "MultiplyBlending", function() {
        return Co
    }), n.d(t, "CustomBlending", function() {
        return Lo
    }), n.d(t, "AddEquation", function() {
        return Ro
    }), n.d(t, "SubtractEquation", function() {
        return Io
    }), n.d(t, "ReverseSubtractEquation", function() {
        return Oo
    }), n.d(t, "MinEquation", function() {
        return ko
    }), n.d(t, "MaxEquation", function() {
        return Do
    }), n.d(t, "ZeroFactor", function() {
        return No
    }), n.d(t, "OneFactor", function() {
        return Bo
    }), n.d(t, "SrcColorFactor", function() {
        return Uo
    }), n.d(t, "OneMinusSrcColorFactor", function() {
        return Fo
    }), n.d(t, "SrcAlphaFactor", function() {
        return zo
    }), n.d(t, "OneMinusSrcAlphaFactor", function() {
        return jo
    }), n.d(t, "DstAlphaFactor", function() {
        return Ho
    }), n.d(t, "OneMinusDstAlphaFactor", function() {
        return Vo
    }), n.d(t, "DstColorFactor", function() {
        return Go
    }), n.d(t, "OneMinusDstColorFactor", function() {
        return Wo
    }), n.d(t, "SrcAlphaSaturateFactor", function() {
        return $o
    }), n.d(t, "NeverDepth", function() {
        return Xo
    }), n.d(t, "AlwaysDepth", function() {
        return qo
    }), n.d(t, "LessDepth", function() {
        return Yo
    }), n.d(t, "LessEqualDepth", function() {
        return Zo
    }), n.d(t, "EqualDepth", function() {
        return Jo
    }), n.d(t, "GreaterEqualDepth", function() {
        return Ko
    }), n.d(t, "GreaterDepth", function() {
        return Qo
    }), n.d(t, "NotEqualDepth", function() {
        return ea
    }), n.d(t, "MultiplyOperation", function() {
        return ta
    }), n.d(t, "MixOperation", function() {
        return na
    }), n.d(t, "AddOperation", function() {
        return ra
    }), n.d(t, "NoToneMapping", function() {
        return ia
    }), n.d(t, "LinearToneMapping", function() {
        return oa
    }), n.d(t, "ReinhardToneMapping", function() {
        return aa
    }), n.d(t, "Uncharted2ToneMapping", function() {
        return sa
    }), n.d(t, "CineonToneMapping", function() {
        return ca
    }), n.d(t, "UVMapping", function() {
        return la
    }), n.d(t, "CubeReflectionMapping", function() {
        return ha
    }), n.d(t, "CubeRefractionMapping", function() {
        return ua
    }), n.d(t, "EquirectangularReflectionMapping", function() {
        return da
    }), n.d(t, "EquirectangularRefractionMapping", function() {
        return pa
    }), n.d(t, "SphericalReflectionMapping", function() {
        return fa
    }), n.d(t, "CubeUVReflectionMapping", function() {
        return ma
    }), n.d(t, "CubeUVRefractionMapping", function() {
        return ga
    }), n.d(t, "RepeatWrapping", function() {
        return va
    }), n.d(t, "ClampToEdgeWrapping", function() {
        return ya
    }), n.d(t, "MirroredRepeatWrapping", function() {
        return ba
    }), n.d(t, "NearestFilter", function() {
        return xa
    }), n.d(t, "NearestMipMapNearestFilter", function() {
        return wa
    }), n.d(t, "NearestMipMapLinearFilter", function() {
        return _a
    }), n.d(t, "LinearFilter", function() {
        return Ma
    }), n.d(t, "LinearMipMapNearestFilter", function() {
        return Ea
    }), n.d(t, "LinearMipMapLinearFilter", function() {
        return Ta
    }), n.d(t, "UnsignedByteType", function() {
        return Sa
    }), n.d(t, "ByteType", function() {
        return Aa
    }), n.d(t, "ShortType", function() {
        return Pa
    }), n.d(t, "UnsignedShortType", function() {
        return Ca
    }), n.d(t, "IntType", function() {
        return La
    }), n.d(t, "UnsignedIntType", function() {
        return Ra
    }), n.d(t, "FloatType", function() {
        return Ia
    }), n.d(t, "HalfFloatType", function() {
        return Oa
    }), n.d(t, "UnsignedShort4444Type", function() {
        return ka
    }), n.d(t, "UnsignedShort5551Type", function() {
        return Da
    }), n.d(t, "UnsignedShort565Type", function() {
        return Na
    }), n.d(t, "UnsignedInt248Type", function() {
        return Ba
    }), n.d(t, "AlphaFormat", function() {
        return Ua
    }), n.d(t, "RGBFormat", function() {
        return Fa
    }), n.d(t, "RGBAFormat", function() {
        return za
    }), n.d(t, "LuminanceFormat", function() {
        return ja
    }), n.d(t, "LuminanceAlphaFormat", function() {
        return Ha
    }), n.d(t, "RGBEFormat", function() {
        return Va
    }), n.d(t, "DepthFormat", function() {
        return Ga
    }), n.d(t, "DepthStencilFormat", function() {
        return Wa
    }), n.d(t, "RGB_S3TC_DXT1_Format", function() {
        return $a
    }), n.d(t, "RGBA_S3TC_DXT1_Format", function() {
        return Xa
    }), n.d(t, "RGBA_S3TC_DXT3_Format", function() {
        return qa
    }), n.d(t, "RGBA_S3TC_DXT5_Format", function() {
        return Ya
    }), n.d(t, "RGB_PVRTC_4BPPV1_Format", function() {
        return Za
    }), n.d(t, "RGB_PVRTC_2BPPV1_Format", function() {
        return Ja
    }), n.d(t, "RGBA_PVRTC_4BPPV1_Format", function() {
        return Ka
    }), n.d(t, "RGBA_PVRTC_2BPPV1_Format", function() {
        return Qa
    }), n.d(t, "RGB_ETC1_Format", function() {
        return es
    }), n.d(t, "LoopOnce", function() {
        return ts
    }), n.d(t, "LoopRepeat", function() {
        return ns
    }), n.d(t, "LoopPingPong", function() {
        return rs
    }), n.d(t, "InterpolateDiscrete", function() {
        return is
    }), n.d(t, "InterpolateLinear", function() {
        return os
    }), n.d(t, "InterpolateSmooth", function() {
        return as
    }), n.d(t, "ZeroCurvatureEnding", function() {
        return ss
    }), n.d(t, "ZeroSlopeEnding", function() {
        return cs
    }), n.d(t, "WrapAroundEnding", function() {
        return ls
    }), n.d(t, "TrianglesDrawMode", function() {
        return hs
    }), n.d(t, "TriangleStripDrawMode", function() {
        return us
    }), n.d(t, "TriangleFanDrawMode", function() {
        return ds
    }), n.d(t, "LinearEncoding", function() {
        return ps
    }), n.d(t, "sRGBEncoding", function() {
        return fs
    }), n.d(t, "GammaEncoding", function() {
        return ms
    }), n.d(t, "RGBEEncoding", function() {
        return gs
    }), n.d(t, "LogLuvEncoding", function() {
        return vs
    }), n.d(t, "RGBM7Encoding", function() {
        return ys
    }), n.d(t, "RGBM16Encoding", function() {
        return bs
    }), n.d(t, "RGBDEncoding", function() {
        return xs
    }), n.d(t, "BasicDepthPacking", function() {
        return ws
    }), n.d(t, "RGBADepthPacking", function() {
        return _s
    }), n.d(t, "CubeGeometry", function() {
        return Re
    }), n.d(t, "Face4", function() {
        return Ci
    }), n.d(t, "LineStrip", function() {
        return cc
    }), n.d(t, "LinePieces", function() {
        return lc
    }), n.d(t, "MeshFaceMaterial", function() {
        return Li
    }), n.d(t, "MultiMaterial", function() {
        return Ri
    }), n.d(t, "PointCloud", function() {
        return Ii
    }), n.d(t, "Particle", function() {
        return Oi
    }), n.d(t, "ParticleSystem", function() {
        return ki
    }), n.d(t, "PointCloudMaterial", function() {
        return Di
    }), n.d(t, "ParticleBasicMaterial", function() {
        return Ni
    }), n.d(t, "ParticleSystemMaterial", function() {
        return Bi
    }), n.d(t, "Vertex", function() {
        return Ui
    }), n.d(t, "DynamicBufferAttribute", function() {
        return Fi
    }), n.d(t, "Int8Attribute", function() {
        return zi
    }), n.d(t, "Uint8Attribute", function() {
        return ji
    }), n.d(t, "Uint8ClampedAttribute", function() {
        return Hi
    }), n.d(t, "Int16Attribute", function() {
        return Vi
    }), n.d(t, "Uint16Attribute", function() {
        return Gi
    }), n.d(t, "Int32Attribute", function() {
        return Wi
    }), n.d(t, "Uint32Attribute", function() {
        return $i
    }), n.d(t, "Float32Attribute", function() {
        return Xi
    }), n.d(t, "Float64Attribute", function() {
        return qi
    }), n.d(t, "ClosedSplineCurve3", function() {
        return Yi
    }), n.d(t, "SplineCurve3", function() {
        return Zi
    }), n.d(t, "Spline", function() {
        return Ji
    }), n.d(t, "BoundingBoxHelper", function() {
        return Ki
    }), n.d(t, "EdgesHelper", function() {
        return Qi
    }), n.d(t, "WireframeHelper", function() {
        return eo
    }), n.d(t, "XHRLoader", function() {
        return to
    }), n.d(t, "BinaryTextureLoader", function() {
        return no
    }), n.d(t, "GeometryUtils", function() {
        return hc
    }), n.d(t, "ImageUtils", function() {
        return uc
    }), n.d(t, "Projector", function() {
        return ro
    }), n.d(t, "CanvasRenderer", function() {
        return io
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && function() {
        Object.assign = function(e) {
            if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
            for (var t = Object(e), n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                if (void 0 !== r && null !== r)
                    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
            }
            return t
        }
    }(), Object.assign(r.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var n = this._listeners,
                    r = n[e];
                if (void 0 !== r) {
                    var i = r.indexOf(t); - 1 !== i && r.splice(i, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners,
                    n = t[e.type];
                if (void 0 !== n) {
                    e.target = this;
                    var r = [],
                        i = 0,
                        o = n.length;
                    for (i = 0; i < o; i++) r[i] = n[i];
                    for (i = 0; i < o; i++) r[i].call(this, e)
                }
            }
        }
    });
    var oo = "85",
        ao = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        so = 0,
        co = 1,
        lo = 2,
        ho = 3,
        uo = 0,
        po = 1,
        fo = 0,
        mo = 1,
        go = 2,
        vo = 0,
        yo = 1,
        bo = 2,
        xo = 1,
        wo = 2,
        _o = 0,
        Mo = 1,
        Eo = 2,
        To = 0,
        So = 1,
        Ao = 2,
        Po = 3,
        Co = 4,
        Lo = 5,
        Ro = 100,
        Io = 101,
        Oo = 102,
        ko = 103,
        Do = 104,
        No = 200,
        Bo = 201,
        Uo = 202,
        Fo = 203,
        zo = 204,
        jo = 205,
        Ho = 206,
        Vo = 207,
        Go = 208,
        Wo = 209,
        $o = 210,
        Xo = 0,
        qo = 1,
        Yo = 2,
        Zo = 3,
        Jo = 4,
        Ko = 5,
        Qo = 6,
        ea = 7,
        ta = 0,
        na = 1,
        ra = 2,
        ia = 0,
        oa = 1,
        aa = 2,
        sa = 3,
        ca = 4,
        la = 300,
        ha = 301,
        ua = 302,
        da = 303,
        pa = 304,
        fa = 305,
        ma = 306,
        ga = 307,
        va = 1e3,
        ya = 1001,
        ba = 1002,
        xa = 1003,
        wa = 1004,
        _a = 1005,
        Ma = 1006,
        Ea = 1007,
        Ta = 1008,
        Sa = 1009,
        Aa = 1010,
        Pa = 1011,
        Ca = 1012,
        La = 1013,
        Ra = 1014,
        Ia = 1015,
        Oa = 1016,
        ka = 1017,
        Da = 1018,
        Na = 1019,
        Ba = 1020,
        Ua = 1021,
        Fa = 1022,
        za = 1023,
        ja = 1024,
        Ha = 1025,
        Va = za,
        Ga = 1026,
        Wa = 1027,
        $a = 2001,
        Xa = 2002,
        qa = 2003,
        Ya = 2004,
        Za = 2100,
        Ja = 2101,
        Ka = 2102,
        Qa = 2103,
        es = 2151,
        ts = 2200,
        ns = 2201,
        rs = 2202,
        is = 2300,
        os = 2301,
        as = 2302,
        ss = 2400,
        cs = 2401,
        ls = 2402,
        hs = 0,
        us = 1,
        ds = 2,
        ps = 3e3,
        fs = 3001,
        ms = 3007,
        gs = 3002,
        vs = 3003,
        ys = 3004,
        bs = 3005,
        xs = 3006,
        ws = 3200,
        _s = 3201,
        Ms = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var e, t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    n = new Array(36),
                    r = 0;
                return function() {
                    for (var i = 0; i < 36; i++) 8 === i || 13 === i || 18 === i || 23 === i ? n[i] = "-" : 14 === i ? n[i] = "4" : (r <= 2 && (r = 33554432 + 16777216 * Math.random() | 0), e = 15 & r, r >>= 4, n[i] = t[19 === i ? 3 & e | 8 : e]);
                    return n.join("")
                }
            }(),
            clamp: function(e, t, n) {
                return Math.max(t, Math.min(n, e))
            },
            euclideanModulo: function(e, t) {
                return (e % t + t) % t
            },
            mapLinear: function(e, t, n, r, i) {
                return r + (e - t) * (i - r) / (n - t)
            },
            lerp: function(e, t, n) {
                return (1 - n) * e + n * t
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            degToRad: function(e) {
                return e * Ms.DEG2RAD
            },
            radToDeg: function(e) {
                return e * Ms.RAD2DEG
            },
            isPowerOfTwo: function(e) {
                return 0 == (e & e - 1) && 0 !== e
            },
            nearestPowerOfTwo: function(e) {
                return Math.pow(2, Math.round(Math.log(e) / Math.LN2))
            },
            nextPowerOfTwo: function(e) {
                return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e
            }
        };
    Object.defineProperties(i.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function(e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function() {
            var e = new i,
                t = new i;
            return function(n, r) {
                return e.set(n, n), t.set(r, r), this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var n = this.length();
            return this.multiplyScalar(Math.max(e, Math.min(t, n)) / n)
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI), e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        },
        distanceToManhattan: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.multiplyScalar(e / this.length())
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function(e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = this.x - e.x,
                o = this.y - e.y;
            return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
        }
    });
    var Es = 0;
    o.DEFAULT_IMAGE = void 0, o.DEFAULT_MAPPING = la, Object.defineProperty(o.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(o.prototype, r.prototype, {
        constructor: o,
        isTexture: !0,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function(e) {
            if (void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var n = this.image;
                void 0 === n.uuid && (n.uuid = Ms.generateUUID()), void 0 === e.images[n.uuid] && (e.images[n.uuid] = {
                    uuid: n.uuid,
                    url: function(e) {
                        var t;
                        return void 0 !== e.toDataURL ? t = e : (t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), t.width = e.width, t.height = e.height, t.getContext("2d").drawImage(e, 0, 0, e.width, e.height)), t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }(n)
                }), t.image = n.uuid
            }
            return e.textures[this.uuid] = t, t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (this.mapping === la) {
                if (e.multiply(this.repeat), e.add(this.offset), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case va:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case ya:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case ba:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case va:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case ya:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case ba:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                this.flipY && (e.y = 1 - e.y)
            }
        }
    }), Object.assign(a.prototype, {
        isVector4: !0,
        set: function(e, t, n, r) {
            return this.x = e, this.y = t, this.z = n, this.w = r, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setW: function(e) {
            return this.w = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = this.w,
                o = e.elements;
            return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, n, r, i, o = e.elements,
                a = o[0],
                s = o[4],
                c = o[8],
                l = o[1],
                h = o[5],
                u = o[9],
                d = o[2],
                p = o[6],
                f = o[10];
            if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(u - p) < .01) {
                if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                var m = (a + 1) / 2,
                    g = (h + 1) / 2,
                    v = (f + 1) / 2,
                    y = (s + l) / 4,
                    b = (c + d) / 4,
                    x = (u + p) / 4;
                return m > g && m > v ? m < .01 ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(m), r = y / n, i = b / n) : g > v ? g < .01 ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(g), n = y / r, i = x / r) : v < .01 ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = b / i, r = x / i), this.set(n, r, i, t), this
            }
            var w = Math.sqrt((p - u) * (p - u) + (c - d) * (c - d) + (l - s) * (l - s));
            return Math.abs(w) < .001 && (w = 1), this.x = (p - u) / w, this.y = (c - d) / w, this.z = (l - s) / w, this.w = Math.acos((a + h + f - 1) / 2), this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function() {
            var e = new a,
                t = new a;
            return function(n, r) {
                return e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(e) {
            return this.multiplyScalar(e / this.length())
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), Object.assign(s.prototype, r.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), c.prototype = Object.create(s.prototype), c.prototype.constructor = c, c.prototype.isWebGLRenderTargetCube = !0, Object.assign(l, {
        slerp: function(e, t, n, r) {
            return n.copy(e).slerp(t, r)
        },
        slerpFlat: function(e, t, n, r, i, o, a) {
            var s = n[r + 0],
                c = n[r + 1],
                l = n[r + 2],
                h = n[r + 3],
                u = i[o + 0],
                d = i[o + 1],
                p = i[o + 2],
                f = i[o + 3];
            if (h !== f || s !== u || c !== d || l !== p) {
                var m = 1 - a,
                    g = s * u + c * d + l * p + h * f,
                    v = g >= 0 ? 1 : -1,
                    y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var b = Math.sqrt(y),
                        x = Math.atan2(b, g * v);
                    m = Math.sin(m * x) / b, a = Math.sin(a * x) / b
                }
                var w = a * v;
                if (s = s * m + u * w, c = c * m + d * w, l = l * m + p * w, h = h * m + f * w, m === 1 - a) {
                    var _ = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                    s *= _, c *= _, l *= _, h *= _
                }
            }
            e[t] = s, e[t + 1] = c, e[t + 2] = l, e[t + 3] = h
        }
    }), Object.defineProperties(l.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(l.prototype, {
        set: function(e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._w = r, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function(e, t) {
            if (!1 === (e && e.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = e._x,
                r = e._y,
                i = e._z,
                o = e.order,
                a = Math.cos,
                s = Math.sin,
                c = a(n / 2),
                l = a(r / 2),
                h = a(i / 2),
                u = s(n / 2),
                d = s(r / 2),
                p = s(i / 2);
            return "XYZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "YXZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "ZXY" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "ZYX" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "YZX" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h - u * d * p) : "XZY" === o && (this._x = u * l * h - c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h + u * d * p), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(e, t) {
            var n = t / 2,
                r = Math.sin(n);
            return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e) {
            var t, n = e.elements,
                r = n[0],
                i = n[4],
                o = n[8],
                a = n[1],
                s = n[5],
                c = n[9],
                l = n[2],
                h = n[6],
                u = n[10],
                d = r + s + u;
            return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (h - c) * t, this._y = (o - l) * t, this._z = (a - i) * t) : r > s && r > u ? (t = 2 * Math.sqrt(1 + r - s - u), this._w = (h - c) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (o + l) / t) : s > u ? (t = 2 * Math.sqrt(1 + s - r - u), this._w = (o - l) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (c + h) / t) : (t = 2 * Math.sqrt(1 + u - r - s), this._w = (a - i) / t, this._x = (o + l) / t, this._y = (c + h) / t, this._z = .25 * t), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var e, t = new h;
            return function(n, r) {
                return void 0 === t && (t = new h), e = n.dot(r) + 1, e < 1e-6 ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var n = e._x,
                r = e._y,
                i = e._z,
                o = e._w,
                a = t._x,
                s = t._y,
                c = t._z,
                l = t._w;
            return this._x = n * l + o * a + r * c - i * s, this._y = r * l + o * s + i * a - n * c, this._z = i * l + o * c + n * s - r * a, this._w = o * l - n * a - r * s - i * c, this.onChangeCallback(), this
        },
        slerp: function(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var n = this._x,
                r = this._y,
                i = this._z,
                o = this._w,
                a = o * e._w + n * e._x + r * e._y + i * e._z;
            if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
            var s = Math.sqrt(1 - a * a);
            if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this;
            var c = Math.atan2(s, a),
                l = Math.sin((1 - t) * c) / s,
                h = Math.sin(t * c) / s;
            return this._w = o * l + this._w * h, this._x = n * l + this._x * h, this._y = r * l + this._y * h, this._z = i * l + this._z * h, this.onChangeCallback(), this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(h.prototype, {
        isVector3: !0,
        set: function(e, t, n) {
            return this.x = e, this.y = t, this.z = n, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this.z = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function() {
            var e = new l;
            return function(t) {
                return !1 === (t && t.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(t))
            }
        }(),
        applyAxisAngle: function() {
            var e = new l;
            return function(t, n) {
                return this.applyQuaternion(e.setFromAxisAngle(t, n))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            this.x = i[0] * t + i[4] * n + i[8] * r + i[12], this.y = i[1] * t + i[5] * n + i[9] * r + i[13], this.z = i[2] * t + i[6] * n + i[10] * r + i[14];
            var o = i[3] * t + i[7] * n + i[11] * r + i[15];
            return this.divideScalar(o)
        },
        applyQuaternion: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.x,
                o = e.y,
                a = e.z,
                s = e.w,
                c = s * t + o * r - a * n,
                l = s * n + a * t - i * r,
                h = s * r + i * n - o * t,
                u = -i * t - o * n - a * r;
            return this.x = c * s + u * -i + l * -a - h * -o, this.y = l * s + u * -o + h * -i - c * -a, this.z = h * s + u * -a + c * -o - l * -i, this
        },
        project: function() {
            var e = new u;
            return function(t) {
                return e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyMatrix4(e)
            }
        }(),
        unproject: function() {
            var e = new u;
            return function(t) {
                return e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyMatrix4(e)
            }
        }(),
        transformDirection: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function() {
            var e = new h,
                t = new h;
            return function(n, r) {
                return e.set(n, n, n), t.set(r, r, r), this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var n = this.length();
            return this.multiplyScalar(Math.max(e, Math.min(t, n)) / n)
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(e) {
            return this.multiplyScalar(e / this.length())
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        cross: function(e, t) {
            if (void 0 !== t) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
            var n = this.x,
                r = this.y,
                i = this.z;
            return this.x = r * e.z - i * e.y, this.y = i * e.x - n * e.z, this.z = n * e.y - r * e.x, this
        },
        crossVectors: function(e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                o = t.x,
                a = t.y,
                s = t.z;
            return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function() {
            var e = new h;
            return function(t) {
                return e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function() {
            var e = new h;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(Ms.clamp(t, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                n = this.y - e.y,
                r = this.z - e.z;
            return t * t + n * n + r * r
        },
        distanceToManhattan: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            var t = Math.sin(e.phi) * e.radius;
            return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this
        },
        setFromCylindrical: function(e) {
            return this.x = e.radius * Math.sin(e.theta), this.y = e.y, this.z = e.radius * Math.cos(e.theta), this
        },
        setFromMatrixPosition: function(e) {
            return this.setFromMatrixColumn(e, 3)
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                r = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = r, this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(u.prototype, {
        isMatrix4: !0,
        set: function(e, t, n, r, i, o, a, s, c, l, h, u, d, p, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new u).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        },
        copyPosition: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        },
        extractBasis: function(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var e = new h;
            return function(t) {
                var n = this.elements,
                    r = t.elements,
                    i = 1 / e.setFromMatrixColumn(t, 0).length(),
                    o = 1 / e.setFromMatrixColumn(t, 1).length(),
                    a = 1 / e.setFromMatrixColumn(t, 2).length();
                return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[4] = r[4] * o, n[5] = r[5] * o, n[6] = r[6] * o, n[8] = r[8] * a, n[9] = r[9] * a, n[10] = r[10] * a, this
            }
        }(),
        makeRotationFromEuler: function(e) {
            !1 === (e && e.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z,
                o = Math.cos(n),
                a = Math.sin(n),
                s = Math.cos(r),
                c = Math.sin(r),
                l = Math.cos(i),
                h = Math.sin(i);
            if ("XYZ" === e.order) {
                var u = o * l,
                    d = o * h,
                    p = a * l,
                    f = a * h;
                t[0] = s * l, t[4] = -s * h, t[8] = c, t[1] = d + p * c, t[5] = u - f * c, t[9] = -a * s, t[2] = f - u * c, t[6] = p + d * c, t[10] = o * s
            } else if ("YXZ" === e.order) {
                var m = s * l,
                    g = s * h,
                    v = c * l,
                    y = c * h;
                t[0] = m + y * a, t[4] = v * a - g, t[8] = o * c, t[1] = o * h, t[5] = o * l, t[9] = -a, t[2] = g * a - v, t[6] = y + m * a, t[10] = o * s
            } else if ("ZXY" === e.order) {
                var m = s * l,
                    g = s * h,
                    v = c * l,
                    y = c * h;
                t[0] = m - y * a, t[4] = -o * h, t[8] = v + g * a, t[1] = g + v * a, t[5] = o * l, t[9] = y - m * a, t[2] = -o * c, t[6] = a, t[10] = o * s
            } else if ("ZYX" === e.order) {
                var u = o * l,
                    d = o * h,
                    p = a * l,
                    f = a * h;
                t[0] = s * l, t[4] = p * c - d, t[8] = u * c + f, t[1] = s * h, t[5] = f * c + u, t[9] = d * c - p, t[2] = -c, t[6] = a * s, t[10] = o * s
            } else if ("YZX" === e.order) {
                var b = o * s,
                    x = o * c,
                    w = a * s,
                    _ = a * c;
                t[0] = s * l, t[4] = _ - b * h, t[8] = w * h + x, t[1] = h, t[5] = o * l, t[9] = -a * l, t[2] = -c * l, t[6] = x * h + w, t[10] = b - _ * h
            } else if ("XZY" === e.order) {
                var b = o * s,
                    x = o * c,
                    w = a * s,
                    _ = a * c;
                t[0] = s * l, t[4] = -h, t[8] = c * l, t[1] = b * h + _, t[5] = o * l, t[9] = x * h - w, t[2] = w * h - x, t[6] = a * l, t[10] = _ * h + b
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function(e) {
            var t = this.elements,
                n = e._x,
                r = e._y,
                i = e._z,
                o = e._w,
                a = n + n,
                s = r + r,
                c = i + i,
                l = n * a,
                h = n * s,
                u = n * c,
                d = r * s,
                p = r * c,
                f = i * c,
                m = o * a,
                g = o * s,
                v = o * c;
            return t[0] = 1 - (d + f), t[4] = h - v, t[8] = u + g, t[1] = h + v, t[5] = 1 - (l + f), t[9] = p - m, t[2] = u - g, t[6] = p + m, t[10] = 1 - (l + d), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        lookAt: function() {
            var e = new h,
                t = new h,
                n = new h;
            return function(r, i, o) {
                var a = this.elements;
                return n.subVectors(r, i), 0 === n.lengthSq() && (n.z = 1), n.normalize(), e.crossVectors(o, n), 0 === e.lengthSq() && (n.z += 1e-4, e.crossVectors(o, n)), e.normalize(), t.crossVectors(n, e), a[0] = e.x, a[4] = t.x, a[8] = n.x, a[1] = e.y, a[5] = t.y, a[9] = n.y, a[2] = e.z, a[6] = t.z, a[10] = n.z, this
            }
        }(),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                o = n[0],
                a = n[4],
                s = n[8],
                c = n[12],
                l = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                f = n[6],
                m = n[10],
                g = n[14],
                v = n[3],
                y = n[7],
                b = n[11],
                x = n[15],
                w = r[0],
                _ = r[4],
                M = r[8],
                E = r[12],
                T = r[1],
                S = r[5],
                A = r[9],
                P = r[13],
                C = r[2],
                L = r[6],
                R = r[10],
                I = r[14],
                O = r[3],
                k = r[7],
                D = r[11],
                N = r[15];
            return i[0] = o * w + a * T + s * C + c * O, i[4] = o * _ + a * S + s * L + c * k, i[8] = o * M + a * A + s * R + c * D, i[12] = o * E + a * P + s * I + c * N, i[1] = l * w + h * T + u * C + d * O, i[5] = l * _ + h * S + u * L + d * k, i[9] = l * M + h * A + u * R + d * D, i[13] = l * E + h * P + u * I + d * N, i[2] = p * w + f * T + m * C + g * O, i[6] = p * _ + f * S + m * L + g * k, i[10] = p * M + f * A + m * R + g * D, i[14] = p * E + f * P + m * I + g * N, i[3] = v * w + y * T + b * C + x * O, i[7] = v * _ + y * S + b * L + x * k, i[11] = v * M + y * A + b * R + x * D, i[15] = v * E + y * P + b * I + x * N, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function() {
            var e = new h;
            return function(t) {
                for (var n = 0, r = t.count; n < r; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix4(this), t.setXYZ(n, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements,
                t = e[0],
                n = e[4],
                r = e[8],
                i = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                c = e[13],
                l = e[2],
                h = e[6],
                u = e[10],
                d = e[14];
            return e[3] * (+i * s * h - r * c * h - i * a * u + n * c * u + r * a * d - n * s * d) + e[7] * (+t * s * d - t * c * u + i * o * u - r * o * d + r * c * l - i * s * l) + e[11] * (+t * c * h - t * a * d - i * o * h + n * o * d + i * a * l - n * c * l) + e[15] * (-r * a * l - t * s * h + t * a * u + r * o * h - n * o * u + n * s * l)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        setPosition: function(e) {
            var t = this.elements;
            return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
        },
        getInverse: function(e, t) {
            var n = this.elements,
                r = e.elements,
                i = r[0],
                o = r[1],
                a = r[2],
                s = r[3],
                c = r[4],
                l = r[5],
                h = r[6],
                u = r[7],
                d = r[8],
                p = r[9],
                f = r[10],
                m = r[11],
                g = r[12],
                v = r[13],
                y = r[14],
                b = r[15],
                x = p * y * u - v * f * u + v * h * m - l * y * m - p * h * b + l * f * b,
                w = g * f * u - d * y * u - g * h * m + c * y * m + d * h * b - c * f * b,
                _ = d * v * u - g * p * u + g * l * m - c * v * m - d * l * b + c * p * b,
                M = g * p * h - d * v * h - g * l * f + c * v * f + d * l * y - c * p * y,
                E = i * x + o * w + a * _ + s * M;
            if (0 === E) {
                var T = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(T);
                return console.warn(T), this.identity()
            }
            var S = 1 / E;
            return n[0] = x * S, n[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * b - o * f * b) * S, n[2] = (l * y * s - v * h * s + v * a * u - o * y * u - l * a * b + o * h * b) * S, n[3] = (p * h * s - l * f * s - p * a * u + o * f * u + l * a * m - o * h * m) * S, n[4] = w * S, n[5] = (d * y * s - g * f * s + g * a * m - i * y * m - d * a * b + i * f * b) * S, n[6] = (g * h * s - c * y * s - g * a * u + i * y * u + c * a * b - i * h * b) * S, n[7] = (c * f * s - d * h * s + d * a * u - i * f * u - c * a * m + i * h * m) * S, n[8] = _ * S, n[9] = (g * p * s - d * v * s - g * o * m + i * v * m + d * o * b - i * p * b) * S, n[10] = (c * v * s - g * l * s + g * o * u - i * v * u - c * o * b + i * l * b) * S, n[11] = (d * l * s - c * p * s - d * o * u + i * p * u + c * o * m - i * l * m) * S, n[12] = M * S, n[13] = (d * v * a - g * p * a + g * o * f - i * v * f - d * o * y + i * p * y) * S, n[14] = (g * l * a - c * v * a - g * o * h + i * v * h + c * o * y - i * l * y) * S, n[15] = (c * p * a - d * l * a + d * o * h - i * p * h - c * o * f + i * l * f) * S, this
        },
        scale: function(e) {
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z;
            return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, r))
        },
        makeTranslation: function(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = 1 - n,
                o = e.x,
                a = e.y,
                s = e.z,
                c = i * o,
                l = i * a;
            return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, l * a + n, l * s - r * o, 0, c * s - r * a, l * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function(e, t, n) {
            return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(e, t, n) {
            return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
        },
        decompose: function() {
            var e = new h,
                t = new u;
            return function(n, r, i) {
                var o = this.elements,
                    a = e.set(o[0], o[1], o[2]).length(),
                    s = e.set(o[4], o[5], o[6]).length(),
                    c = e.set(o[8], o[9], o[10]).length();
                this.determinant() < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], t.copy(this);
                var l = 1 / a,
                    h = 1 / s,
                    u = 1 / c;
                return t.elements[0] *= l, t.elements[1] *= l, t.elements[2] *= l, t.elements[4] *= h, t.elements[5] *= h, t.elements[6] *= h, t.elements[8] *= u, t.elements[9] *= u, t.elements[10] *= u, r.setFromRotationMatrix(t), i.x = a, i.y = s, i.z = c, this
            }
        }(),
        makePerspective: function(e, t, n, r, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                s = 2 * i / (t - e),
                c = 2 * i / (n - r),
                l = (t + e) / (t - e),
                h = (n + r) / (n - r),
                u = -(o + i) / (o - i),
                d = -2 * o * i / (o - i);
            return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(e, t, n, r, i, o) {
            var a = this.elements,
                s = 1 / (t - e),
                c = 1 / (n - r),
                l = 1 / (o - i),
                h = (t + e) * s,
                u = (n + r) * c,
                d = (o + i) * l;
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    }), d.prototype = Object.create(o.prototype), d.prototype.constructor = d, d.prototype.isDataTexture = !0, p.prototype = Object.create(o.prototype), p.prototype.constructor = p, p.prototype.isCubeTexture = !0, Object.defineProperty(p.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    });
    var Ts = new o,
        Ss = new p,
        As = [],
        Ps = [],
        Cs = new Float32Array(16),
        Ls = new Float32Array(9);
    G.prototype.setValue = function(e, t) {
        for (var n = this.seq, r = 0, i = n.length; r !== i; ++r) {
            var o = n[r];
            o.setValue(e, t[o.id])
        }
    };
    var Rs = /([\w\d_]+)(\])?(\[|\.)?/g;
    X.prototype.setValue = function(e, t, n) {
        var r = this.map[t];
        void 0 !== r && r.setValue(e, n, this.renderer)
    }, X.prototype.setOptional = function(e, t, n) {
        var r = t[n];
        void 0 !== r && this.setValue(e, n, r)
    }, X.upload = function(e, t, n, r) {
        for (var i = 0, o = t.length; i !== o; ++i) {
            var a = t[i],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, r)
        }
    }, X.seqWithValue = function(e, t) {
        for (var n = [], r = 0, i = e.length; r !== i; ++r) {
            var o = e[r];
            o.id in t && n.push(o)
        }
        return n
    };
    var Is = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(q.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function(e) {
            return this.r = e, this.g = e, this.b = e, this
        },
        setHex: function(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function(e, t, n) {
            return this.r = e, this.g = t, this.b = n, this
        },
        setHSL: function() {
            function e(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            return function(t, n, r) {
                if (t = Ms.euclideanModulo(t, 1), n = Ms.clamp(n, 0, 1), r = Ms.clamp(r, 0, 1), 0 === n) this.r = this.g = this.b = r;
                else {
                    var i = r <= .5 ? r * (1 + n) : r + n - r * n,
                        o = 2 * r - i;
                    this.r = e(o, i, t + 1 / 3), this.g = e(o, i, t), this.b = e(o, i, t - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var r, i = n[1],
                    o = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[5]), this;
                        if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                            var a = parseFloat(r[1]) / 360,
                                s = parseInt(r[2], 10) / 100,
                                c = parseInt(r[3], 10) / 100;
                            return t(r[5]), this.setHSL(a, s, c)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var l = n[1],
                    h = l.length;
                if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
            }
            if (e && e.length > 0) {
                var l = Is[e];
                void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e)
            }
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var n = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
        },
        convertGammaToLinear: function() {
            var e = this.r,
                t = this.g,
                n = this.b;
            return this.r = e * e, this.g = t * t, this.b = n * n, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            var t, n, r = e || {
                    h: 0,
                    s: 0,
                    l: 0
                },
                i = this.r,
                o = this.g,
                a = this.b,
                s = Math.max(i, o, a),
                c = Math.min(i, o, a),
                l = (c + s) / 2;
            if (c === s) t = 0, n = 0;
            else {
                var h = s - c;
                switch (n = l <= .5 ? h / (s + c) : h / (2 - s - c), s) {
                    case i:
                        t = (o - a) / h + (o < a ? 6 : 0);
                        break;
                    case o:
                        t = (a - i) / h + 2;
                        break;
                    case a:
                        t = (i - o) / h + 4
                }
                t /= 6
            }
            return r.h = t, r.s = n, r.l = l, r
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(e, t, n) {
            var r = this.getHSL();
            return r.h += e, r.s += t, r.l += n, this.setHSL(r.h, r.s, r.l), this
        },
        add: function(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function(e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Os = {
            common: {
                diffuse: {
                    value: new q(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new a(0, 0, 1, 1)
                },
                specularMap: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new i(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new q(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new q(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                offsetRepeat: {
                    value: new a(0, 0, 1, 1)
                }
            }
        },
        ks = {
            merge: function(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var r = this.clone(e[n]);
                    for (var i in r) t[i] = r[i]
                }
                return t
            },
            clone: function(e) {
                var t = {};
                for (var n in e) {
                    t[n] = {};
                    for (var r in e[n]) {
                        var i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                }
                return t
            }
        },
        Ds = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
            normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
            distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
            shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
        },
        Ns = {
            basic: {
                uniforms: ks.merge([Os.common, Os.aomap, Os.lightmap, Os.fog]),
                vertexShader: Ds.meshbasic_vert,
                fragmentShader: Ds.meshbasic_frag
            },
            lambert: {
                uniforms: ks.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.fog, Os.lights, {
                    emissive: {
                        value: new q(0)
                    }
                }]),
                vertexShader: Ds.meshlambert_vert,
                fragmentShader: Ds.meshlambert_frag
            },
            phong: {
                uniforms: ks.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.gradientmap, Os.fog, Os.lights, {
                    emissive: {
                        value: new q(0)
                    },
                    specular: {
                        value: new q(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ds.meshphong_vert,
                fragmentShader: Ds.meshphong_frag
            },
            standard: {
                uniforms: ks.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.roughnessmap, Os.metalnessmap, Os.fog, Os.lights, {
                    emissive: {
                        value: new q(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ds.meshphysical_vert,
                fragmentShader: Ds.meshphysical_frag
            },
            points: {
                uniforms: ks.merge([Os.points, Os.fog]),
                vertexShader: Ds.points_vert,
                fragmentShader: Ds.points_frag
            },
            dashed: {
                uniforms: ks.merge([Os.common, Os.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ds.linedashed_vert,
                fragmentShader: Ds.linedashed_frag
            },
            depth: {
                uniforms: ks.merge([Os.common, Os.displacementmap]),
                vertexShader: Ds.depth_vert,
                fragmentShader: Ds.depth_frag
            },
            normal: {
                uniforms: ks.merge([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ds.normal_vert,
                fragmentShader: Ds.normal_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Ds.cube_vert,
                fragmentShader: Ds.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    }
                },
                vertexShader: Ds.equirect_vert,
                fragmentShader: Ds.equirect_frag
            },
            distanceRGBA: {
                uniforms: {
                    lightPos: {
                        value: new h
                    }
                },
                vertexShader: Ds.distanceRGBA_vert,
                fragmentShader: Ds.distanceRGBA_frag
            }
        };
    Ns.physical = {
        uniforms: ks.merge([Ns.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Ds.meshphysical_vert,
        fragmentShader: Ds.meshphysical_frag
    }, Object.assign(Y.prototype, {
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new i;
            return function(t, n) {
                var r = e.copy(n).multiplyScalar(.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            var t = e || new i;
            return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            var t = e || new i;
            return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return (t || new i).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return (t || new i).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new i;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var Bs = 0;
    Object.assign(K.prototype, r.prototype, {
        isMaterial: !0,
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var n = e[t];
                    if (void 0 !== n) {
                        var r = this[t];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = "overdraw" === t ? Number(n) : n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                    } else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            function t(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
            var n = void 0 === e;
            n && (e = {
                textures: {},
                images: {}
            });
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (r.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, r.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== So && (r.blending = this.blending), this.shading !== wo && (r.shading = this.shading), this.side !== vo && (r.side = this.side), this.vertexColors !== _o && (r.vertexColors = this.vertexColors), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, this.alphaTest > 0 && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), r.skinning = this.skinning, r.morphTargets = this.morphTargets, r.dithering = this.dithering, n) {
                var i = t(e.textures),
                    o = t(e.images);
                i.length > 0 && (r.textures = i), o.length > 0 && (r.images = o)
            }
            return r
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.shading = e.shading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes,
                n = null;
            if (null !== t) {
                var r = t.length;
                n = new Array(r);
                for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Q.prototype = Object.create(K.prototype), Q.prototype.constructor = Q, Q.prototype.isShaderMaterial = !0, Q.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ks.clone(e.uniforms), this.defines = e.defines, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, Q.prototype.toJSON = function(e) {
        var t = K.prototype.toJSON.call(this, e);
        return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
    }, ee.prototype = Object.create(K.prototype), ee.prototype.constructor = ee, ee.prototype.isMeshDepthMaterial = !0, ee.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, Object.assign(te.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                var l = e[s],
                    h = e[s + 1],
                    u = e[s + 2];
                l < t && (t = l), h < n && (n = h), u < r && (r = u), l > i && (i = l), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, n, r), this.max.set(i, o, a), this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
                var l = e.getX(s),
                    h = e.getY(s),
                    u = e.getZ(s);
                l < t && (t = l), h < n && (n = h), u < r && (r = u), l > i && (i = l), h > o && (o = h), u > a && (a = u)
            }
            return this.min.set(t, n, r), this.max.set(i, o, a), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new h;
            return function(t, n) {
                var r = e.copy(n).multiplyScalar(.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            var t = e || new h;
            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            var t = e || new h;
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function() {
            var e = new h;
            return function(t) {
                var n = this;
                return t.updateMatrixWorld(!0), t.traverse(function(t) {
                    var r, i, o = t.geometry;
                    if (void 0 !== o)
                        if (o.isGeometry) {
                            var a = o.vertices;
                            for (r = 0, i = a.length; r < i; r++) e.copy(a[r]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e)
                        } else if (o.isBufferGeometry) {
                        var s = o.attributes.position;
                        if (void 0 !== s)
                            for (r = 0, i = s.count; r < i; r++) e.fromBufferAttribute(s, r).applyMatrix4(t.matrixWorld), n.expandByPoint(e)
                    }
                }), this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return (t || new h).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var e = new h;
            return function(t) {
                return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function(e) {
            var t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= e.constant && n >= e.constant
        },
        clampPoint: function(e, t) {
            return (t || new h).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new h;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new h;
            return function(t) {
                var n = t || new ne;
                return this.getCenter(n.center), n.radius = .5 * this.getSize(e).length(), n
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function() {
            var e = [new h, new h, new h, new h, new h, new h, new h, new h];
            return function(t) {
                return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e), this)
            }
        }(),
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(ne.prototype, {
        set: function(e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function() {
            var e = new te;
            return function(t, n) {
                var r = this.center;
                void 0 !== n ? r.copy(n) : e.setFromPoints(t).getCenter(r);
                for (var i = 0, o = 0, a = t.length; o < a; o++) i = Math.max(i, r.distanceToSquared(t[o]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(this.center.dot(e.normal) - e.constant) <= this.radius
        },
        clampPoint: function(e, t) {
            var n = this.center.distanceToSquared(e),
                r = t || new h;
            return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
        },
        getBoundingBox: function(e) {
            var t = e || new te;
            return t.set(this.center, this.center), t.expandByScalar(this.radius), t
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        },
        translate: function(e) {
            return this.center.add(e), this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(re.prototype, {
        isMatrix3: !0,
        set: function(e, t, n, r, i, o, a, s, c) {
            var l = this.elements;
            return l[0] = e, l[1] = r, l[2] = a, l[3] = t, l[4] = i, l[5] = s, l[6] = n, l[7] = o, l[8] = c, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        },
        applyToBufferAttribute: function() {
            var e = new h;
            return function(t) {
                for (var n = 0, r = t.count; n < r; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix3(this), t.setXYZ(n, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                o = n[0],
                a = n[3],
                s = n[6],
                c = n[1],
                l = n[4],
                h = n[7],
                u = n[2],
                d = n[5],
                p = n[8],
                f = r[0],
                m = r[3],
                g = r[6],
                v = r[1],
                y = r[4],
                b = r[7],
                x = r[2],
                w = r[5],
                _ = r[8];
            return i[0] = o * f + a * v + s * x, i[3] = o * m + a * y + s * w, i[6] = o * g + a * b + s * _, i[1] = c * f + l * v + h * x, i[4] = c * m + l * y + h * w, i[7] = c * g + l * b + h * _, i[2] = u * f + d * v + p * x, i[5] = u * m + d * y + p * w, i[8] = u * g + d * b + p * _, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                n = e[1],
                r = e[2],
                i = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                c = e[7],
                l = e[8];
            return t * o * l - t * a * c - n * i * l + n * a * s + r * i * c - r * o * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            var n = e.elements,
                r = this.elements,
                i = n[0],
                o = n[1],
                a = n[2],
                s = n[3],
                c = n[4],
                l = n[5],
                h = n[6],
                u = n[7],
                d = n[8],
                p = d * c - l * u,
                f = l * h - d * s,
                m = u * s - c * h,
                g = i * p + o * f + a * m;
            if (0 === g) {
                var v = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(v);
                return console.warn(v), this.identity()
            }
            var y = 1 / g;
            return r[0] = p * y, r[1] = (a * u - d * o) * y, r[2] = (l * o - a * c) * y, r[3] = f * y, r[4] = (d * i - a * h) * y, r[5] = (a * s - l * i) * y, r[6] = m * y, r[7] = (o * h - u * i) * y, r[8] = (c * i - o * s) * y, this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
    }), Object.assign(ie.prototype, {
        set: function(e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function(e, t, n, r) {
            return this.normal.set(e, t, n), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var e = new h,
                t = new h;
            return function(n, r, i) {
                var o = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, n), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return this.orthoPoint(e, t).sub(e).negate()
        },
        orthoPoint: function(e, t) {
            var n = this.distanceToPoint(e);
            return (t || new h).copy(this.normal).multiplyScalar(n)
        },
        intersectLine: function() {
            var e = new h;
            return function(t, n) {
                var r = n || new h,
                    i = t.delta(e),
                    o = this.normal.dot(i);
                if (0 !== o) {
                    var a = -(t.start.dot(this.normal) + this.constant) / o;
                    if (!(a < 0 || a > 1)) return r.copy(i).multiplyScalar(a).add(t.start)
                } else if (0 === this.distanceToPoint(t.start)) return r.copy(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return (e || new h).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new h,
                t = new re;
            return function(n, r) {
                var i = this.coplanarPoint(e).applyMatrix4(n),
                    o = r || t.getNormalMatrix(n),
                    a = this.normal.applyMatrix3(o).normalize();
                return this.constant = -i.dot(a), this
            }
        }(),
        translate: function(e) {
            return this.constant = this.constant - e.dot(this.normal), this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(oe.prototype, {
        set: function(e, t, n, r, i, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes,
                n = e.elements,
                r = n[0],
                i = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                c = n[5],
                l = n[6],
                h = n[7],
                u = n[8],
                d = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = n[15];
            return t[0].setComponents(a - r, h - s, f - u, y - m).normalize(), t[1].setComponents(a + r, h + s, f + u, y + m).normalize(), t[2].setComponents(a + i, h + c, f + d, y + g).normalize(), t[3].setComponents(a - i, h - c, f - d, y - g).normalize(), t[4].setComponents(a - o, h - l, f - p, y - v).normalize(), t[5].setComponents(a + o, h + l, f + p, y + v).normalize(), this
        },
        intersectsObject: function() {
            var e = new ne;
            return function(t) {
                var n = t.geometry;
                return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function() {
            var e = new ne;
            return function(t) {
                return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                if (t[i].distanceToPoint(n) < r) return !1
            }
            return !0
        },
        intersectsBox: function() {
            var e = new h,
                t = new h;
            return function(n) {
                for (var r = this.planes, i = 0; i < 6; i++) {
                    var o = r[i];
                    e.x = o.normal.x > 0 ? n.min.x : n.max.x, t.x = o.normal.x > 0 ? n.max.x : n.min.x, e.y = o.normal.y > 0 ? n.min.y : n.max.y, t.y = o.normal.y > 0 ? n.max.y : n.min.y, e.z = o.normal.z > 0 ? n.min.z : n.max.z, t.z = o.normal.z > 0 ? n.max.z : n.min.z;
                    var a = o.distanceToPoint(e),
                        s = o.distanceToPoint(t);
                    if (a < 0 && s < 0) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
    }), Object.assign(se.prototype, {
        set: function(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function(e, t) {
            return (t || new h).copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function() {
            var e = new h;
            return function(t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function(e, t) {
            var n = t || new h;
            n.subVectors(e, this.origin);
            var r = n.dot(this.direction);
            return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new h;
            return function(t) {
                var n = e.subVectors(t, this.origin).dot(this.direction);
                return n < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function() {
            var e = new h,
                t = new h,
                n = new h;
            return function(r, i, o, a) {
                e.copy(r).add(i).multiplyScalar(.5), t.copy(i).sub(r).normalize(), n.copy(this.origin).sub(e);
                var s, c, l, h, u = .5 * r.distanceTo(i),
                    d = -this.direction.dot(t),
                    p = n.dot(this.direction),
                    f = -n.dot(t),
                    m = n.lengthSq(),
                    g = Math.abs(1 - d * d);
                if (g > 0)
                    if (s = d * f - p, c = d * p - f, h = u * g, s >= 0)
                        if (c >= -h)
                            if (c <= h) {
                                var v = 1 / g;
                                s *= v, c *= v, l = s * (s + d * c + 2 * p) + c * (d * s + c + 2 * f) + m
                            } else c = u, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m;
                else c = -u, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m;
                else c <= -h ? (s = Math.max(0, -(-d * u + p)), c = s > 0 ? -u : Math.min(Math.max(-u, -f), u), l = -s * s + c * (c + 2 * f) + m) : c <= h ? (s = 0, c = Math.min(Math.max(-u, -f), u), l = c * (c + 2 * f) + m) : (s = Math.max(0, -(d * u + p)), c = s > 0 ? u : Math.min(Math.max(-u, -f), u), l = -s * s + c * (c + 2 * f) + m);
                else c = d > 0 ? -u : u, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m;
                return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(t).multiplyScalar(c).add(e), l
            }
        }(),
        intersectSphere: function() {
            var e = new h;
            return function(t, n) {
                e.subVectors(t.center, this.origin);
                var r = e.dot(this.direction),
                    i = e.dot(e) - r * r,
                    o = t.radius * t.radius;
                if (i > o) return null;
                var a = Math.sqrt(o - i),
                    s = r - a,
                    c = r + a;
                return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceToPoint(e.center) <= e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        },
        intersectPlane: function(e, t) {
            var n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var n, r, i, o, a, s, c = 1 / this.direction.x,
                l = 1 / this.direction.y,
                h = 1 / this.direction.z,
                u = this.origin;
            return c >= 0 ? (n = (e.min.x - u.x) * c, r = (e.max.x - u.x) * c) : (n = (e.max.x - u.x) * c, r = (e.min.x - u.x) * c), l >= 0 ? (i = (e.min.y - u.y) * l, o = (e.max.y - u.y) * l) : (i = (e.max.y - u.y) * l, o = (e.min.y - u.y) * l), n > o || i > r ? null : ((i > n || n !== n) && (n = i), (o < r || r !== r) && (r = o), h >= 0 ? (a = (e.min.z - u.z) * h, s = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, s = (e.min.z - u.z) * h), n > s || a > r ? null : ((a > n || n !== n) && (n = a), (s < r || r !== r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
        },
        intersectsBox: function() {
            var e = new h;
            return function(t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function() {
            var e = new h,
                t = new h,
                n = new h,
                r = new h;
            return function(i, o, a, s, c) {
                t.subVectors(o, i), n.subVectors(a, i), r.crossVectors(t, n);
                var l, h = this.direction.dot(r);
                if (h > 0) {
                    if (s) return null;
                    l = 1
                } else {
                    if (!(h < 0)) return null;
                    l = -1, h = -h
                }
                e.subVectors(this.origin, i);
                var u = l * this.direction.dot(n.crossVectors(e, n));
                if (u < 0) return null;
                var d = l * this.direction.dot(t.cross(e));
                if (d < 0) return null;
                if (u + d > h) return null;
                var p = -l * e.dot(r);
                return p < 0 ? null : this.at(p / h, c)
            }
        }(),
        applyMatrix4: function(e) {
            return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), ce.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ce.DefaultOrder = "XYZ", Object.defineProperties(ce.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(ce.prototype, {
        isEuler: !0,
        set: function(e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e, t, n) {
            var r = Ms.clamp,
                i = e.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                c = i[1],
                l = i[5],
                h = i[9],
                u = i[2],
                d = i[6],
                p = i[10];
            return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === t ? (this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === t ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var e = new u;
            return function(t, n, r) {
                return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, r)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function() {
            var e = new l;
            return function(t) {
                return e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new h(this._x, this._y, this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {}
    }), Object.assign(le.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var Us = 0;
    he.DefaultUp = new h(0, 1, 0), he.DefaultMatrixAutoUpdate = !0, Object.assign(he.prototype, r.prototype, {
        isObject3D: !0,
        applyMatrix: function(e) {
            this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function() {
            var e = new l;
            return function(t, n) {
                return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
            }
        }(),
        rotateX: function() {
            var e = new h(1, 0, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new h(0, 1, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new h(0, 0, 1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new h;
            return function(t, n) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
            }
        }(),
        translateX: function() {
            var e = new h(1, 0, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new h(0, 1, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new h(0, 0, 1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var e = new u;
            return function(t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var e = new u;
            return function(t) {
                this.isCamera ? e.lookAt(this.position, t, this.up) : e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
            }
        }(),
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function(e) {
            if (arguments.length > 1)
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
            var n = this.children.indexOf(e); - 1 !== n && (e.parent = null, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(n, 1))
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n],
                    o = i.getObjectByProperty(e, t);
                if (void 0 !== o) return o
            }
        },
        getWorldPosition: function(e) {
            var t = e || new h;
            return this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var e = new h,
                t = new h;
            return function(n) {
                var r = n || new l;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, r, t), r
            }
        }(),
        getWorldRotation: function() {
            var e = new l;
            return function(t) {
                var n = t || new ce;
                return this.getWorldQuaternion(e), n.setFromQuaternion(e, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var e = new h,
                t = new l;
            return function(n) {
                var r = n || new h;
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, r), r
            }
        }(),
        getWorldDirection: function() {
            var e = new l;
            return function(t) {
                var n = t || new h;
                return this.getWorldQuaternion(e), n.set(0, 0, 1).applyQuaternion(e)
            }
        }(),
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
        },
        toJSON: function(e) {
            function t(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
            }

            function n(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
            var r = void 0 === e || "" === e,
                i = {};
            r && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, i.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var o = {};
            if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), o.matrix = this.matrix.toArray(), void 0 !== this.geometry && (o.geometry = t(e.geometries, this.geometry)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var a = [], s = 0, c = this.material.length; s < c; s++) a.push(t(e.materials, this.material[s]));
                    o.material = a
                } else o.material = t(e.materials, this.material);
            if (this.children.length > 0) {
                o.children = [];
                for (var s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(e).object)
            }
            if (r) {
                var l = n(e.geometries),
                    h = n(e.materials),
                    u = n(e.textures),
                    d = n(e.images);
                l.length > 0 && (i.geometries = l), h.length > 0 && (i.materials = h), u.length > 0 && (i.textures = u), d.length > 0 && (i.images = d)
            }
            return i.object = o, i
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.add(r.clone())
                }
            return this
        }
    }), Object.assign(ue.prototype, {
        set: function(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function(e) {
            return (e || new h).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return (e || new h).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            var n = t || new h;
            return this.delta(n).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function() {
            var e = new h,
                t = new h;
            return function(n, r) {
                e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                var i = t.dot(t),
                    o = t.dot(e),
                    a = o / i;
                return r && (a = Ms.clamp(a, 0, 1)), a
            }
        }(),
        closestPointToPoint: function(e, t, n) {
            var r = this.closestPointToPointParameter(e, t),
                i = n || new h;
            return this.delta(i).multiplyScalar(r).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), Object.assign(de, {
        normal: function() {
            var e = new h;
            return function(t, n, r, i) {
                var o = i || new h;
                o.subVectors(r, n), e.subVectors(t, n), o.cross(e);
                var a = o.lengthSq();
                return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0)
            }
        }(),
        barycoordFromPoint: function() {
            var e = new h,
                t = new h,
                n = new h;
            return function(r, i, o, a, s) {
                e.subVectors(a, i), t.subVectors(o, i), n.subVectors(r, i);
                var c = e.dot(e),
                    l = e.dot(t),
                    u = e.dot(n),
                    d = t.dot(t),
                    p = t.dot(n),
                    f = c * d - l * l,
                    m = s || new h;
                if (0 === f) return m.set(-2, -1, -1);
                var g = 1 / f,
                    v = (d * u - l * p) * g,
                    y = (c * p - l * u) * g;
                return m.set(1 - v - y, y, v)
            }
        }(),
        containsPoint: function() {
            var e = new h;
            return function(t, n, r, i) {
                var o = de.barycoordFromPoint(t, n, r, i, e);
                return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
            }
        }()
    }), Object.assign(de.prototype, {
        set: function(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        },
        setFromPointsAndIndices: function(e, t, n, r) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        area: function() {
            var e = new h,
                t = new h;
            return function() {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        midpoint: function(e) {
            return (e || new h).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(e) {
            return de.normal(this.a, this.b, this.c, e)
        },
        plane: function(e) {
            return (e || new ie).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(e, t) {
            return de.barycoordFromPoint(e, this.a, this.b, this.c, t)
        },
        containsPoint: function(e) {
            return de.containsPoint(e, this.a, this.b, this.c)
        },
        closestPointToPoint: function() {
            var e = new ie,
                t = [new ue, new ue, new ue],
                n = new h,
                r = new h;
            return function(i, o) {
                var a = o || new h,
                    s = 1 / 0;
                if (e.setFromCoplanarPoints(this.a, this.b, this.c), e.projectPoint(i, n), !0 === this.containsPoint(n)) a.copy(n);
                else {
                    t[0].set(this.a, this.b), t[1].set(this.b, this.c), t[2].set(this.c, this.a);
                    for (var c = 0; c < t.length; c++) {
                        t[c].closestPointToPoint(n, !0, r);
                        var l = n.distanceToSquared(r);
                        l < s && (s = l, a.copy(r))
                    }
                }
                return a
            }
        }(),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), Object.assign(pe.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (var t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }), fe.prototype = Object.create(K.prototype), fe.prototype.constructor = fe, fe.prototype.isMeshBasicMaterial = !0, fe.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Object.defineProperty(me.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(me.prototype, {
        isBufferAttribute: !0,
        setArray: function(e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e
        },
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e), this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new q), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
            }
            return this
        },
        copyIndicesArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                t[n++] = o.a, t[n++] = o.b, t[n++] = o.c
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, o = e.length; r < o; r++) {
                var a = e[r];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), t[n++] = a.x, t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new h), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new a), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function(e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        },
        setXYZ: function(e, t, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
        },
        setXYZW: function(e, t, n, r, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), ge.prototype = Object.create(me.prototype), ge.prototype.constructor = ge, ve.prototype = Object.create(me.prototype), ve.prototype.constructor = ve, ye.prototype = Object.create(me.prototype), ye.prototype.constructor = ye, be.prototype = Object.create(me.prototype), be.prototype.constructor = be, xe.prototype = Object.create(me.prototype), xe.prototype.constructor = xe, we.prototype = Object.create(me.prototype), we.prototype.constructor = we, _e.prototype = Object.create(me.prototype), _e.prototype.constructor = _e, Me.prototype = Object.create(me.prototype), Me.prototype.constructor = Me, Ee.prototype = Object.create(me.prototype), Ee.prototype.constructor = Ee, Object.assign(Te.prototype, {
        computeGroups: function(e) {
            for (var t, n = [], r = void 0, i = e.faces, o = 0; o < i.length; o++) {
                var a = i[o];
                a.materialIndex !== r && (r = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
                    start: 3 * o,
                    materialIndex: r
                })
            }
            void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
        },
        fromGeometry: function(e) {
            var t, n = e.faces,
                r = e.vertices,
                o = e.faceVertexUvs,
                a = o[0] && o[0].length > 0,
                s = o[1] && o[1].length > 0,
                c = e.morphTargets,
                l = c.length;
            if (l > 0) {
                t = [];
                for (var h = 0; h < l; h++) t[h] = [];
                this.morphTargets.position = t
            }
            var u, d = e.morphNormals,
                p = d.length;
            if (p > 0) {
                u = [];
                for (var h = 0; h < p; h++) u[h] = [];
                this.morphTargets.normal = u
            }
            for (var f = e.skinIndices, m = e.skinWeights, g = f.length === r.length, v = m.length === r.length, h = 0; h < n.length; h++) {
                var y = n[h];
                this.vertices.push(r[y.a], r[y.b], r[y.c]);
                var b = y.vertexNormals;
                if (3 === b.length) this.normals.push(b[0], b[1], b[2]);
                else {
                    var x = y.normal;
                    this.normals.push(x, x, x)
                }
                var w = y.vertexColors;
                if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
                else {
                    var _ = y.color;
                    this.colors.push(_, _, _)
                }
                if (!0 === a) {
                    var M = o[0][h];
                    void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))
                }
                if (!0 === s) {
                    var M = o[1][h];
                    void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))
                }
                for (var E = 0; E < l; E++) {
                    var T = c[E].vertices;
                    t[E].push(T[y.a], T[y.b], T[y.c])
                }
                for (var E = 0; E < p; E++) {
                    var S = d[E].vertexNormals[h];
                    u[E].push(S.a, S.b, S.c)
                }
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    });
    var Fs = 0;
    Object.assign(Pe.prototype, r.prototype, {
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new re).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                this.vertices[n].applyMatrix4(e)
            }
            for (var n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n];
                i.normal.applyMatrix3(t).normalize();
                for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new u;
            return function(t, n, r) {
                return e.makeTranslation(t, n, r), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new u;
            return function(t, n, r) {
                return e.makeScale(t, n, r), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new he;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function(e) {
            function t(e, t, r, i) {
                var o = void 0 !== s ? [d[e].clone(), d[t].clone(), d[r].clone()] : [],
                    a = void 0 !== c ? [n.colors[e].clone(), n.colors[t].clone(), n.colors[r].clone()] : [],
                    h = new pe(e, t, r, o, a, i);
                n.faces.push(h), void 0 !== l && n.faceVertexUvs[0].push([p[e].clone(), p[t].clone(), p[r].clone()]), void 0 !== u && n.faceVertexUvs[1].push([f[e].clone(), f[t].clone(), f[r].clone()])
            }
            var n = this,
                r = null !== e.index ? e.index.array : void 0,
                o = e.attributes,
                a = o.position.array,
                s = void 0 !== o.normal ? o.normal.array : void 0,
                c = void 0 !== o.color ? o.color.array : void 0,
                l = void 0 !== o.uv ? o.uv.array : void 0,
                u = void 0 !== o.uv2 ? o.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var d = [], p = [], f = [], m = 0, g = 0; m < a.length; m += 3, g += 2) n.vertices.push(new h(a[m], a[m + 1], a[m + 2])), void 0 !== s && d.push(new h(s[m], s[m + 1], s[m + 2])), void 0 !== c && n.colors.push(new q(c[m], c[m + 1], c[m + 2])), void 0 !== l && p.push(new i(l[g], l[g + 1])), void 0 !== u && f.push(new i(u[g], u[g + 1]));
            var v = e.groups;
            if (v.length > 0)
                for (var m = 0; m < v.length; m++)
                    for (var y = v[m], b = y.start, x = y.count, g = b, w = b + x; g < w; g += 3) void 0 !== r ? t(r[g], r[g + 1], r[g + 2], y.materialIndex) : t(g, g + 1, g + 2, y.materialIndex);
            else if (void 0 !== r)
                for (var m = 0; m < r.length; m += 3) t(r[m], r[m + 1], r[m + 2]);
            else
                for (var m = 0; m < a.length / 3; m += 3) t(m, m + 1, m + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            this.computeBoundingBox();
            var e = this.boundingBox.getCenter().negate();
            return this.translate(e.x, e.y, e.z), e
        },
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius,
                n = 0 === t ? 1 : 1 / t,
                r = new u;
            return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
        },
        computeFaceNormals: function() {
            for (var e = new h, t = new h, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b],
                    s = this.vertices[i.c];
                e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            void 0 === e && (e = !0);
            var t, n, r, i, o, a;
            for (a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new h;
            if (e) {
                var s, c, l, u = new h,
                    d = new h;
                for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], u.subVectors(l, c), d.subVectors(s, c), u.cross(d), a[o.a].add(u), a[o.b].add(u), a[o.c].add(u)
            } else
                for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], a[o.a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
            for (r = 0, i = this.faces.length; r < i; r++) {
                o = this.faces[r];
                var p = o.vertexNormals;
                3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, n;
            for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                n = this.faces[e];
                var r = n.vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, n, r, i;
            for (n = 0, r = this.faces.length; n < r; n++)
                for (i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
            var o = new Pe;
            for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                    var a, s, c = this.morphNormals[e].faceNormals,
                        l = this.morphNormals[e].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++) a = new h, s = {
                        a: new h,
                        b: new h,
                        c: new h
                    }, c.push(a), l.push(s)
                }
                var u = this.morphNormals[e];
                o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals();
                var a, s;
                for (n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], a = u.faceNormals[n], s = u.vertexNormals[n], a.copy(i.normal), s.a.copy(i.vertexNormals[0]), s.b.copy(i.vertexNormals[1]), s.c.copy(i.vertexNormals[2])
            }
            for (n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeLineDistances: function() {
            for (var e = 0, t = this.vertices, n = 0, r = t.length; n < r; n++) n > 0 && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new te), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new ne), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, n) {
            if (!1 === (e && e.isGeometry)) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
            var r, i = this.vertices.length,
                o = this.vertices,
                a = e.vertices,
                s = this.faces,
                c = e.faces,
                l = this.faceVertexUvs[0],
                h = e.faceVertexUvs[0],
                u = this.colors,
                d = e.colors;
            void 0 === n && (n = 0), void 0 !== t && (r = (new re).getNormalMatrix(t));
            for (var p = 0, f = a.length; p < f; p++) {
                var m = a[p],
                    g = m.clone();
                void 0 !== t && g.applyMatrix4(t), o.push(g)
            }
            for (var p = 0, f = d.length; p < f; p++) u.push(d[p].clone());
            for (p = 0, f = c.length; p < f; p++) {
                var v, y, b, x = c[p],
                    w = x.vertexNormals,
                    _ = x.vertexColors;
                v = new pe(x.a + i, x.b + i, x.c + i), v.normal.copy(x.normal), void 0 !== r && v.normal.applyMatrix3(r).normalize();
                for (var M = 0, E = w.length; M < E; M++) y = w[M].clone(), void 0 !== r && y.applyMatrix3(r).normalize(), v.vertexNormals.push(y);
                v.color.copy(x.color);
                for (var M = 0, E = _.length; M < E; M++) b = _[M], v.vertexColors.push(b.clone());
                v.materialIndex = x.materialIndex + n, s.push(v)
            }
            for (p = 0, f = h.length; p < f; p++) {
                var T = h[p],
                    S = [];
                if (void 0 !== T) {
                    for (var M = 0, E = T.length; M < E; M++) S.push(T[M].clone());
                    l.push(S)
                }
            }
        },
        mergeMesh: function(e) {
            if (!1 === (e && e.isMesh)) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
            e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)
        },
        mergeVertices: function() {
            var e, t, n, r, i, o, a, s, c = {},
                l = [],
                h = [],
                u = Math.pow(10, 4);
            for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u), void 0 === c[t] ? (c[t] = n, l.push(this.vertices[n]), h[n] = l.length - 1) : h[n] = h[c[t]];
            var d = [];
            for (n = 0, r = this.faces.length; n < r; n++) {
                i = this.faces[n], i.a = h[i.a], i.b = h[i.b], i.c = h[i.c], o = [i.a, i.b, i.c];
                for (var p = 0; p < 3; p++)
                    if (o[p] === o[(p + 1) % 3]) {
                        d.push(n);
                        break
                    }
            }
            for (n = d.length - 1; n >= 0; n--) {
                var f = d[n];
                for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - l.length;
            return this.vertices = l, m
        },
        sortFacesByMaterialIndex: function() {
            function e(e, t) {
                return e.materialIndex - t.materialIndex
            }
            for (var t = this.faces, n = t.length, r = 0; r < n; r++) t[r]._id = r;
            t.sort(e);
            var i, o, a = this.faceVertexUvs[0],
                s = this.faceVertexUvs[1];
            a && a.length === n && (i = []), s && s.length === n && (o = []);
            for (var r = 0; r < n; r++) {
                var c = t[r]._id;
                i && i.push(a[c]), o && o.push(s[c])
            }
            i && (this.faceVertexUvs[0] = i), o && (this.faceVertexUvs[1] = o)
        },
        toJSON: function() {
            function e(e, t, n) {
                return n ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== d[t] ? d[t] : (d[t] = u.length / 3, u.push(e.x, e.y, e.z), d[t])
            }

            function n(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== f[t] ? f[t] : (f[t] = p.length, p.push(e.getHex()), f[t])
            }

            function r(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== g[t] ? g[t] : (g[t] = m.length / 2, m.push(e.x, e.y), g[t])
            }
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), void 0 !== this.parameters) {
                var o = this.parameters;
                for (var a in o) void 0 !== o[a] && (i[a] = o[a]);
                return i
            }
            for (var s = [], c = 0; c < this.vertices.length; c++) {
                var l = this.vertices[c];
                s.push(l.x, l.y, l.z)
            }
            for (var h = [], u = [], d = {}, p = [], f = {}, m = [], g = {}, c = 0; c < this.faces.length; c++) {
                var v = this.faces[c],
                    y = void 0 !== this.faceVertexUvs[0][c],
                    b = v.normal.length() > 0,
                    x = v.vertexNormals.length > 0,
                    w = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                    _ = v.vertexColors.length > 0,
                    M = 0;
                if (M = e(M, 0, 0), M = e(M, 1, !0), M = e(M, 2, !1), M = e(M, 3, y), M = e(M, 4, b), M = e(M, 5, x), M = e(M, 6, w), M = e(M, 7, _), h.push(M), h.push(v.a, v.b, v.c), h.push(v.materialIndex), y) {
                    var E = this.faceVertexUvs[0][c];
                    h.push(r(E[0]), r(E[1]), r(E[2]))
                }
                if (b && h.push(t(v.normal)), x) {
                    var T = v.vertexNormals;
                    h.push(t(T[0]), t(T[1]), t(T[2]))
                }
                if (w && h.push(n(v.color)), _) {
                    var S = v.vertexColors;
                    h.push(n(S[0]), n(S[1]), n(S[2]))
                }
            }
            return i.data = {}, i.data.vertices = s, i.data.normals = u, p.length > 0 && (i.data.colors = p), m.length > 0 && (i.data.uvs = [m]), i.data.faces = h, i
        },
        clone: function() {
            return (new Pe).copy(this)
        },
        copy: function(e) {
            var t, n, r, i, o, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var s = e.vertices;
            for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
            var c = e.colors;
            for (t = 0, n = c.length; t < n; t++) this.colors.push(c[t].clone());
            var l = e.faces;
            for (t = 0, n = l.length; t < n; t++) this.faces.push(l[t].clone());
            for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                var h = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = h.length; r < i; r++) {
                    var u = h[r],
                        d = [];
                    for (o = 0, a = u.length; o < a; o++) {
                        var p = u[o];
                        d.push(p.clone())
                    }
                    this.faceVertexUvs[t].push(d)
                }
            }
            var f = e.morphTargets;
            for (t = 0, n = f.length; t < n; t++) {
                var m = {};
                if (m.name = f[t].name, void 0 !== f[t].vertices)
                    for (m.vertices = [], r = 0, i = f[t].vertices.length; r < i; r++) m.vertices.push(f[t].vertices[r].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [], r = 0, i = f[t].normals.length; r < i; r++) m.normals.push(f[t].normals[r].clone());
                this.morphTargets.push(m)
            }
            var g = e.morphNormals;
            for (t = 0, n = g.length; t < n; t++) {
                var v = {};
                if (void 0 !== g[t].vertexNormals)
                    for (v.vertexNormals = [], r = 0, i = g[t].vertexNormals.length; r < i; r++) {
                        var y = g[t].vertexNormals[r],
                            b = {};
                        b.a = y.a.clone(), b.b = y.b.clone(), b.c = y.c.clone(), v.vertexNormals.push(b)
                    }
                if (void 0 !== g[t].faceNormals)
                    for (v.faceNormals = [], r = 0, i = g[t].faceNormals.length; r < i; r++) v.faceNormals.push(g[t].faceNormals[r].clone());
                this.morphNormals.push(v)
            }
            var x = e.skinWeights;
            for (t = 0, n = x.length; t < n; t++) this.skinWeights.push(x[t].clone());
            var w = e.skinIndices;
            for (t = 0, n = w.length; t < n; t++) this.skinIndices.push(w[t].clone());
            var _ = e.lineDistances;
            for (t = 0, n = _.length; t < n; t++) this.lineDistances.push(_[t]);
            var M = e.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var E = e.boundingSphere;
            return null !== E && (this.boundingSphere = E.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Ce.MaxIndex = 65535, Object.assign(Ce.prototype, r.prototype, {
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new(Se(e) > 65535 ? _e : xe)(e, 1) : this.index = e
        },
        addAttribute: function(e, t) {
            return !1 === (t && t.isBufferAttribute) && !1 === (t && t.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(e, new me(arguments[1], arguments[2]))) : "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(t)) : (this.attributes[e] = t, this)
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e], this
        },
        addGroup: function(e, t, n) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var n = this.attributes.normal;
            if (void 0 !== n) {
                (new re).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationX(t), this.applyMatrix(e), this
            }
        }(),
        rotateY: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationY(t), this.applyMatrix(e), this
            }
        }(),
        rotateZ: function() {
            var e = new u;
            return function(t) {
                return e.makeRotationZ(t), this.applyMatrix(e), this
            }
        }(),
        translate: function() {
            var e = new u;
            return function(t, n, r) {
                return e.makeTranslation(t, n, r), this.applyMatrix(e), this
            }
        }(),
        scale: function() {
            var e = new u;
            return function(t, n, r) {
                return e.makeScale(t, n, r), this.applyMatrix(e), this
            }
        }(),
        lookAt: function() {
            var e = new he;
            return function(t) {
                e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            this.computeBoundingBox();
            var e = this.boundingBox.getCenter().negate();
            return this.translate(e.x, e.y, e.z), e
        },
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var n = new Me(3 * t.vertices.length, 3),
                    r = new Me(3 * t.colors.length, 3);
                if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var i = new Me(t.lineDistances.length, 1);
                    this.addAttribute("lineDistance", i.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        updateFromObject: function(e) {
            var t = e.geometry;
            if (e.isMesh) {
                var n = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t);
                n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n
            }
            var r;
            return !0 === t.verticesNeedUpdate && (r = this.attributes.position, void 0 !== r && (r.copyVector3sArray(t.vertices), r.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (r = this.attributes.normal, void 0 !== r && (r.copyVector3sArray(t.normals), r.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (r = this.attributes.color, void 0 !== r && (r.copyColorsArray(t.colors), r.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (r = this.attributes.uv, void 0 !== r && (r.copyVector2sArray(t.uvs), r.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (r = this.attributes.lineDistance, void 0 !== r && (r.copyArray(t.lineDistances), r.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new Te).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new me(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                var n = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new me(n, 3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var r = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new me(r, 3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var i = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new me(i, 2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var o = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new me(o, 2).copyVector2sArray(e.uvs2))
            }
            if (e.indices.length > 0) {
                var a = Se(e.indices) > 65535 ? Uint32Array : Uint16Array,
                    s = new a(3 * e.indices.length);
                this.setIndex(new me(s, 1).copyIndicesArray(e.indices))
            }
            this.groups = e.groups;
            for (var c in e.morphTargets) {
                for (var l = [], h = e.morphTargets[c], u = 0, d = h.length; u < d; u++) {
                    var p = h[u],
                        f = new Me(3 * p.length, 3);
                    l.push(f.copyVector3sArray(p))
                }
                this.morphAttributes[c] = l
            }
            if (e.skinIndices.length > 0) {
                var m = new Me(4 * e.skinIndices.length, 4);
                this.addAttribute("skinIndex", m.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var g = new Me(4 * e.skinWeights.length, 4);
                this.addAttribute("skinWeight", g.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new te);
            var e = this.attributes.position;
            void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var e = new te,
                t = new h;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new ne);
                var n = this.attributes.position;
                if (n) {
                    var r = this.boundingSphere.center;
                    e.setFromBufferAttribute(n), e.getCenter(r);
                    for (var i = 0, o = 0, a = n.count; o < a; o++) t.x = n.getX(o), t.y = n.getY(o), t.z = n.getZ(o), i = Math.max(i, r.distanceToSquared(t));
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index,
                t = this.attributes,
                n = this.groups;
            if (t.position) {
                var r = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new me(new Float32Array(r.length), 3));
                else
                    for (var i = t.normal.array, o = 0, a = i.length; o < a; o++) i[o] = 0;
                var s, c, l, u = t.normal.array,
                    d = new h,
                    p = new h,
                    f = new h,
                    m = new h,
                    g = new h;
                if (e) {
                    var v = e.array;
                    0 === n.length && this.addGroup(0, v.length);
                    for (var y = 0, b = n.length; y < b; ++y)
                        for (var x = n[y], w = x.start, _ = x.count, o = w, a = w + _; o < a; o += 3) s = 3 * v[o + 0], c = 3 * v[o + 1], l = 3 * v[o + 2], d.fromArray(r, s), p.fromArray(r, c), f.fromArray(r, l), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), u[s] += m.x, u[s + 1] += m.y, u[s + 2] += m.z, u[c] += m.x, u[c + 1] += m.y, u[c + 2] += m.z, u[l] += m.x, u[l + 1] += m.y, u[l + 2] += m.z
                } else
                    for (var o = 0, a = r.length; o < a; o += 9) d.fromArray(r, o), p.fromArray(r, o + 3), f.fromArray(r, o + 6), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), u[o] = m.x, u[o + 1] = m.y, u[o + 2] = m.z, u[o + 3] = m.x, u[o + 4] = m.y, u[o + 5] = m.z, u[o + 6] = m.x, u[o + 7] = m.y, u[o + 8] = m.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (!1 === (e && e.isBufferGeometry)) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            void 0 === t && (t = 0);
            var n = this.attributes;
            for (var r in n)
                if (void 0 !== e.attributes[r])
                    for (var i = n[r], o = i.array, a = e.attributes[r], s = a.array, c = a.itemSize, l = 0, h = c * t; l < s.length; l++, h++) o[h] = s[l];
            return this
        },
        normalizeNormals: function() {
            for (var e, t, n, r, i = this.attributes.normal, o = 0, a = i.count; o < a; o++) e = i.getX(o), t = i.getY(o), n = i.getZ(o), r = 1 / Math.sqrt(e * e + t * t + n * n), i.setXYZ(o, e * r, t * r, n * r)
        },
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e = new Ce,
                t = this.index.array,
                n = this.attributes;
            for (var r in n) {
                for (var i = n[r], o = i.array, a = i.itemSize, s = new o.constructor(t.length * a), c = 0, l = 0, h = 0, u = t.length; h < u; h++) {
                    c = t[h] * a;
                    for (var d = 0; d < a; d++) s[l++] = o[c++]
                }
                e.addAttribute(r, new me(s, a))
            }
            return e
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var r = this.index;
            if (null !== r) {
                var i = Array.prototype.slice.call(r.array);
                e.data.index = {
                    type: r.array.constructor.name,
                    array: i
                }
            }
            var o = this.attributes;
            for (var n in o) {
                var a = o[n],
                    i = Array.prototype.slice.call(a.array);
                e.data.attributes[n] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: i,
                    normalized: a.normalized
                }
            }
            var s = this.groups;
            s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
            var c = this.boundingSphere;
            return null !== c && (e.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }), e
        },
        clone: function() {
            return (new Ce).copy(this)
        },
        copy: function(e) {
            var t, n, r;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var i = e.index;
            null !== i && this.setIndex(i.clone());
            var o = e.attributes;
            for (t in o) {
                var a = o[t];
                this.addAttribute(t, a.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var c = [],
                    l = s[t];
                for (n = 0, r = l.length; n < r; n++) c.push(l[n].clone());
                this.morphAttributes[t] = c
            }
            var h = e.groups;
            for (n = 0, r = h.length; n < r; n++) {
                var u = h[n];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var d = e.boundingBox;
            null !== d && (this.boundingBox = d.clone());
            var p = e.boundingSphere;
            return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Le.prototype = Object.assign(Object.create(he.prototype), {
        constructor: Le,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return he.prototype.copy.call(this, e), this.drawMode = e.drawMode, this
        },
        updateMorphTargets: function() {
            var e = this.geometry.morphTargets;
            if (void 0 !== e && e.length > 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (var t = 0, n = e.length; t < n; t++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[e[t].name] = t
            }
        },
        raycast: function() {
            function e(e, t, n, r, i, o, a) {
                return de.barycoordFromPoint(e, t, n, r, y), i.multiplyScalar(y.x), o.multiplyScalar(y.y), a.multiplyScalar(y.z), i.add(o).add(a), i.clone()
            }

            function t(e, t, n, r, i, o, a) {
                var s = e.material;
                if (null === (s.side === yo ? n.intersectTriangle(o, i, r, !0, a) : n.intersectTriangle(r, i, o, s.side !== bo, a))) return null;
                x.copy(a), x.applyMatrix4(e.matrixWorld);
                var c = t.ray.origin.distanceTo(x);
                return c < t.near || c > t.far ? null : {
                    distance: c,
                    point: x.clone(),
                    object: e
                }
            }

            function n(n, r, i, o, a, h, u, d) {
                s.fromBufferAttribute(o, h), c.fromBufferAttribute(o, u), l.fromBufferAttribute(o, d);
                var p = t(n, r, i, s, c, l, b);
                return p && (a && (m.fromBufferAttribute(a, h), g.fromBufferAttribute(a, u), v.fromBufferAttribute(a, d), p.uv = e(b, s, c, l, m, g, v)), p.face = new pe(h, u, d, de.normal(s, c, l)), p.faceIndex = h), p
            }
            var r = new u,
                o = new se,
                a = new ne,
                s = new h,
                c = new h,
                l = new h,
                d = new h,
                p = new h,
                f = new h,
                m = new i,
                g = new i,
                v = new i,
                y = new h,
                b = new h,
                x = new h;
            return function(i, h) {
                var u = this.geometry,
                    y = this.material,
                    x = this.matrixWorld;
                if (void 0 !== y && (null === u.boundingSphere && u.computeBoundingSphere(), a.copy(u.boundingSphere), a.applyMatrix4(x), !1 !== i.ray.intersectsSphere(a) && (r.getInverse(x), o.copy(i.ray).applyMatrix4(r), null === u.boundingBox || !1 !== o.intersectsBox(u.boundingBox)))) {
                    var w;
                    if (u.isBufferGeometry) {
                        var _, M, E, T, S, A = u.index,
                            P = u.attributes.position,
                            C = u.attributes.uv;
                        if (null !== A)
                            for (T = 0, S = A.count; T < S; T += 3) _ = A.getX(T), M = A.getX(T + 1), E = A.getX(T + 2), (w = n(this, i, o, P, C, _, M, E)) && (w.faceIndex = Math.floor(T / 3), h.push(w));
                        else
                            for (T = 0, S = P.count; T < S; T += 3) _ = T, M = T + 1, E = T + 2, (w = n(this, i, o, P, C, _, M, E)) && (w.index = _, h.push(w))
                    } else if (u.isGeometry) {
                        var L, R, I, O, k = Array.isArray(y),
                            D = u.vertices,
                            N = u.faces,
                            B = u.faceVertexUvs[0];
                        B.length > 0 && (O = B);
                        for (var U = 0, F = N.length; U < F; U++) {
                            var z = N[U],
                                j = k ? y[z.materialIndex] : y;
                            if (void 0 !== j) {
                                if (L = D[z.a], R = D[z.b], I = D[z.c], !0 === j.morphTargets) {
                                    var H = u.morphTargets,
                                        V = this.morphTargetInfluences;
                                    s.set(0, 0, 0), c.set(0, 0, 0), l.set(0, 0, 0);
                                    for (var G = 0, W = H.length; G < W; G++) {
                                        var $ = V[G];
                                        if (0 !== $) {
                                            var X = H[G].vertices;
                                            s.addScaledVector(d.subVectors(X[z.a], L), $), c.addScaledVector(p.subVectors(X[z.b], R), $), l.addScaledVector(f.subVectors(X[z.c], I), $)
                                        }
                                    }
                                    s.add(L), c.add(R), l.add(I), L = s, R = c, I = l
                                }
                                if (w = t(this, i, o, L, R, I, b)) {
                                    if (O && O[U]) {
                                        var q = O[U];
                                        m.copy(q[0]), g.copy(q[1]), v.copy(q[2]), w.uv = e(b, L, R, I, m, g, v)
                                    }
                                    w.face = z, w.faceIndex = U, h.push(w)
                                }
                            }
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Re.prototype = Object.create(Pe.prototype), Re.prototype.constructor = Re, Ie.prototype = Object.create(Ce.prototype), Ie.prototype.constructor = Ie, Oe.prototype = Object.create(Pe.prototype), Oe.prototype.constructor = Oe, ke.prototype = Object.create(Ce.prototype), ke.prototype.constructor = ke, De.prototype = Object.assign(Object.create(he.prototype), {
        constructor: De,
        isCamera: !0,
        copy: function(e) {
            return he.prototype.copy.call(this, e), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this
        },
        getWorldDirection: function() {
            var e = new l;
            return function(t) {
                var n = t || new h;
                return this.getWorldQuaternion(e), n.set(0, 0, -1).applyQuaternion(e)
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Ne.prototype = Object.assign(Object.create(De.prototype), {
        constructor: Ne,
        isPerspectiveCamera: !0,
        copy: function(e) {
            return De.prototype.copy.call(this, e), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Ms.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * Ms.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * Ms.RAD2DEG * Math.atan(Math.tan(.5 * Ms.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, n, r, i, o) {
            this.aspect = e / t, this.view = {
                fullWidth: e,
                fullHeight: t,
                offsetX: n,
                offsetY: r,
                width: i,
                height: o
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near,
                t = e * Math.tan(.5 * Ms.DEG2RAD * this.fov) / this.zoom,
                n = 2 * t,
                r = this.aspect * n,
                i = -.5 * r,
                o = this.view;
            if (null !== o) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                i += o.offsetX * r / a, t -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
            }
            var c = this.filmOffset;
            0 !== c && (i += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far)
        },
        toJSON: function(e) {
            var t = he.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }), Be.prototype = Object.assign(Object.create(De.prototype), {
        constructor: Be,
        isOrthographicCamera: !0,
        copy: function(e) {
            return De.prototype.copy.call(this, e), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function(e, t, n, r, i, o) {
            this.view = {
                fullWidth: e,
                fullHeight: t,
                offsetX: n,
                offsetY: r,
                width: i,
                height: o
            }, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - e,
                o = n + e,
                a = r + t,
                s = r - t;
            if (null !== this.view) {
                var c = this.zoom / (this.view.width / this.view.fullWidth),
                    l = this.zoom / (this.view.height / this.view.fullHeight),
                    h = (this.right - this.left) / this.view.width,
                    u = (this.top - this.bottom) / this.view.height;
                i += h * (this.view.offsetX / c), o = i + h * (this.view.width / c), a -= u * (this.view.offsetY / l), s = a - u * (this.view.height / l)
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far)
        },
        toJSON: function(e) {
            var t = he.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    });
    var zs = 0;
    gt.prototype.isFogExp2 = !0, gt.prototype.clone = function() {
        return new gt(this.color.getHex(), this.density)
    }, gt.prototype.toJSON = function(e) {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }, vt.prototype.isFog = !0, vt.prototype.clone = function() {
        return new vt(this.color.getHex(), this.near, this.far)
    }, vt.prototype.toJSON = function(e) {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }, yt.prototype = Object.assign(Object.create(he.prototype), {
        constructor: yt,
        copy: function(e, t) {
            return he.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function(e) {
            var t = he.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        }
    }), bt.prototype = Object.assign(Object.create(he.prototype), {
        constructor: bt,
        isLensFlare: !0,
        copy: function(e) {
            he.prototype.copy.call(this, e), this.positionScreen.copy(e.positionScreen), this.customUpdateCallback = e.customUpdateCallback;
            for (var t = 0, n = e.lensFlares.length; t < n; t++) this.lensFlares.push(e.lensFlares[t]);
            return this
        },
        add: function(e, t, n, r, i, o) {
            void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === o && (o = 1), void 0 === i && (i = new q(16777215)), void 0 === r && (r = So), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
                texture: e,
                size: t,
                distance: n,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: o,
                color: i,
                blending: r
            })
        },
        updateLensFlares: function() {
            var e, t, n = this.lensFlares.length,
                r = 2 * -this.positionScreen.x,
                i = 2 * -this.positionScreen.y;
            for (e = 0; e < n; e++) t = this.lensFlares[e], t.x = this.positionScreen.x + r * t.distance, t.y = this.positionScreen.y + i * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
        }
    }), xt.prototype = Object.create(K.prototype), xt.prototype.constructor = xt, xt.prototype.isSpriteMaterial = !0, xt.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this
    }, wt.prototype = Object.assign(Object.create(he.prototype), {
        constructor: wt,
        isSprite: !0,
        raycast: function() {
            var e = new h,
                t = new h,
                n = new h;
            return function(r, i) {
                t.setFromMatrixPosition(this.matrixWorld), r.ray.closestPointToPoint(t, e), n.setFromMatrixScale(this.matrixWorld);
                var o = n.x * n.y / 4;
                if (!(t.distanceToSquared(e) > o)) {
                    var a = r.ray.origin.distanceTo(e);
                    a < r.near || a > r.far || i.push({
                        distance: a,
                        point: e.clone(),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        }
    }), _t.prototype = Object.assign(Object.create(he.prototype), {
        constructor: _t,
        copy: function(e) {
            he.prototype.copy.call(this, e, !1);
            for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
            n.splice(r, 0, {
                distance: t,
                object: e
            }), this.add(e)
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
            return t[n - 1].object
        },
        raycast: function() {
            var e = new h;
            return function(t, n) {
                e.setFromMatrixPosition(this.matrixWorld);
                var r = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(r).raycast(t, n)
            }
        }(),
        update: function() {
            var e = new h,
                t = new h;
            return function(n) {
                var r = this.levels;
                if (r.length > 1) {
                    e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                    var i = e.distanceTo(t);
                    r[0].object.visible = !0;
                    for (var o = 1, a = r.length; o < a && i >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                    for (; o < a; o++) r[o].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            var t = he.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                t.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return t
        }
    }), Object.assign(Mt.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var n = new u;
                this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function() {
            var e, t, n;
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            var e = new u,
                t = new u;
            return function() {
                for (var n = this.bones, r = this.boneInverses, i = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
                    var c = n[a] ? n[a].matrixWorld : t;
                    e.multiplyMatrices(c, r[a]), e.toArray(i, 16 * a)
                }
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new Mt(this.bones, this.boneInverses)
        }
    }), Et.prototype = Object.assign(Object.create(he.prototype), {
        constructor: Et,
        isBone: !0
    }), Tt.prototype = Object.assign(Object.create(Le.prototype), {
        constructor: Tt,
        isSkinnedMesh: !0,
        initBones: function() {
            var e, t, n, r, i = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (n = 0, r = this.geometry.bones.length; n < r; n++) t = this.geometry.bones[n], e = new Et, i.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
                for (n = 0, r = this.geometry.bones.length; n < r; n++) t = this.geometry.bones[n], -1 !== t.parent && null !== t.parent && void 0 !== i[t.parent] ? i[t.parent].add(i[n]) : this.add(i[n])
            }
            return this.updateMatrixWorld(!0), i
        },
        bind: function(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var e, t;
            if (this.geometry && this.geometry.isGeometry)
                for (t = 0; t < this.geometry.skinWeights.length; t++) {
                    var n = this.geometry.skinWeights[t];
                    e = 1 / n.lengthManhattan(), e !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    var r = new a,
                        i = this.geometry.attributes.skinWeight;
                    for (t = 0; t < i.count; t++) r.x = i.getX(t), r.y = i.getY(t), r.z = i.getZ(t), r.w = i.getW(t), e = 1 / r.lengthManhattan(), e !== 1 / 0 ? r.multiplyScalar(e) : r.set(1, 0, 0, 0), i.setXYZW(t, r.x, r.y, r.z, r.w)
                }
        },
        updateMatrixWorld: function(e) {
            Le.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), St.prototype = Object.create(K.prototype), St.prototype.constructor = St, St.prototype.isLineBasicMaterial = !0, St.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, At.prototype = Object.assign(Object.create(he.prototype), {
        constructor: At,
        isLine: !0,
        raycast: function() {
            var e = new u,
                t = new se,
                n = new ne;
            return function(r, i) {
                var o = r.linePrecision,
                    a = o * o,
                    s = this.geometry,
                    c = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(c), !1 !== r.ray.intersectsSphere(n)) {
                    e.getInverse(c), t.copy(r.ray).applyMatrix4(e);
                    var l = new h,
                        u = new h,
                        d = new h,
                        p = new h,
                        f = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var m = s.index,
                            g = s.attributes,
                            v = g.position.array;
                        if (null !== m)
                            for (var y = m.array, b = 0, x = y.length - 1; b < x; b += f) {
                                var w = y[b],
                                    _ = y[b + 1];
                                l.fromArray(v, 3 * w), u.fromArray(v, 3 * _);
                                var M = t.distanceSqToSegment(l, u, p, d);
                                if (!(M > a)) {
                                    p.applyMatrix4(this.matrixWorld);
                                    var E = r.ray.origin.distanceTo(p);
                                    E < r.near || E > r.far || i.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: b,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else
                                for (var b = 0, x = v.length / 3 - 1; b < x; b += f) {
                                    l.fromArray(v, 3 * b), u.fromArray(v, 3 * b + 3);
                                    var M = t.distanceSqToSegment(l, u, p, d);
                                    if (!(M > a)) {
                                        p.applyMatrix4(this.matrixWorld);
                                        var E = r.ray.origin.distanceTo(p);
                                        E < r.near || E > r.far || i.push({
                                            distance: E,
                                            point: d.clone().applyMatrix4(this.matrixWorld),
                                            index: b,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                    } else if (s.isGeometry)
                        for (var T = s.vertices, S = T.length, b = 0; b < S - 1; b += f) {
                            var M = t.distanceSqToSegment(T[b], T[b + 1], p, d);
                            if (!(M > a)) {
                                p.applyMatrix4(this.matrixWorld);
                                var E = r.ray.origin.distanceTo(p);
                                E < r.near || E > r.far || i.push({
                                    distance: E,
                                    point: d.clone().applyMatrix4(this.matrixWorld),
                                    index: b,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Pt.prototype = Object.assign(Object.create(At.prototype), {
        constructor: Pt,
        isLineSegments: !0
    }), Ct.prototype = Object.assign(Object.create(At.prototype), {
        constructor: Ct,
        isLineLoop: !0
    }), Lt.prototype = Object.create(K.prototype), Lt.prototype.constructor = Lt, Lt.prototype.isPointsMaterial = !0, Lt.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
    }, Rt.prototype = Object.assign(Object.create(he.prototype), {
        constructor: Rt,
        isPoints: !0,
        raycast: function() {
            var e = new u,
                t = new se,
                n = new ne;
            return function(r, i) {
                function o(e, n) {
                    var o = t.distanceSqToPoint(e);
                    if (o < d) {
                        var s = t.closestPointToPoint(e);
                        s.applyMatrix4(c);
                        var l = r.ray.origin.distanceTo(s);
                        if (l < r.near || l > r.far) return;
                        i.push({
                            distance: l,
                            distanceToRay: Math.sqrt(o),
                            point: s.clone(),
                            index: n,
                            face: null,
                            object: a
                        })
                    }
                }
                var a = this,
                    s = this.geometry,
                    c = this.matrixWorld,
                    l = r.params.Points.threshold;
                if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(c), n.radius += l, !1 !== r.ray.intersectsSphere(n)) {
                    e.getInverse(c), t.copy(r.ray).applyMatrix4(e);
                    var u = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        d = u * u,
                        p = new h;
                    if (s.isBufferGeometry) {
                        var f = s.index,
                            m = s.attributes,
                            g = m.position.array;
                        if (null !== f)
                            for (var v = f.array, y = 0, b = v.length; y < b; y++) {
                                var x = v[y];
                                p.fromArray(g, 3 * x), o(p, x)
                            } else
                                for (var y = 0, w = g.length / 3; y < w; y++) p.fromArray(g, 3 * y), o(p, y)
                    } else
                        for (var _ = s.vertices, y = 0, w = _.length; y < w; y++) o(_[y], y)
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), It.prototype = Object.assign(Object.create(he.prototype), {
        constructor: It
    }), Ot.prototype = Object.create(o.prototype), Ot.prototype.constructor = Ot, kt.prototype = Object.create(o.prototype), kt.prototype.constructor = kt, kt.prototype.isCompressedTexture = !0, Dt.prototype = Object.create(o.prototype), Dt.prototype.constructor = Dt, Nt.prototype = Object.create(o.prototype), Nt.prototype.constructor = Nt, Nt.prototype.isDepthTexture = !0, Bt.prototype = Object.create(Ce.prototype), Bt.prototype.constructor = Bt, Ut.prototype = Object.create(Pe.prototype), Ut.prototype.constructor = Ut, Ft.prototype = Object.create(Ce.prototype), Ft.prototype.constructor = Ft, zt.prototype = Object.create(Pe.prototype), zt.prototype.constructor = zt, jt.prototype = Object.create(Ce.prototype), jt.prototype.constructor = jt, Ht.prototype = Object.create(Pe.prototype), Ht.prototype.constructor = Ht, Vt.prototype = Object.create(jt.prototype), Vt.prototype.constructor = Vt, Gt.prototype = Object.create(Pe.prototype), Gt.prototype.constructor = Gt, Wt.prototype = Object.create(jt.prototype), Wt.prototype.constructor = Wt, $t.prototype = Object.create(Pe.prototype), $t.prototype.constructor = $t, Xt.prototype = Object.create(jt.prototype), Xt.prototype.constructor = Xt, qt.prototype = Object.create(Pe.prototype), qt.prototype.constructor = qt, Yt.prototype = Object.create(jt.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(Pe.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(Ce.prototype), Jt.prototype.constructor = Jt, Kt.prototype = Object.create(Pe.prototype), Kt.prototype.constructor = Kt, Qt.prototype = Object.create(Ce.prototype), Qt.prototype.constructor = Qt, en.prototype = Object.create(Pe.prototype), en.prototype.constructor = en, tn.prototype = Object.create(Ce.prototype), tn.prototype.constructor = tn;
    var js = {
        area: function(e) {
            for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
            return .5 * n
        },
        triangulate: function() {
            function e(e, t, n, r, i, o) {
                var a, s, c, l, h, u, d, p, f;
                if (s = e[o[t]].x, c = e[o[t]].y, l = e[o[n]].x, h = e[o[n]].y, u = e[o[r]].x, d = e[o[r]].y, (l - s) * (d - c) - (h - c) * (u - s) <= 0) return !1;
                var m, g, v, y, b, x, w, _, M, E, T, S, A, P, C;
                for (m = u - l, g = d - h, v = s - u, y = c - d, b = l - s, x = h - c, a = 0; a < i; a++)
                    if (p = e[o[a]].x, f = e[o[a]].y, !(p === s && f === c || p === l && f === h || p === u && f === d) && (w = p - s, _ = f - c, M = p - l, E = f - h, T = p - u, S = f - d, C = m * E - g * M, A = b * _ - x * w, P = v * S - y * T, C >= -Number.EPSILON && P >= -Number.EPSILON && A >= -Number.EPSILON)) return !1;
                return !0
            }
            return function(t, n) {
                var r = t.length;
                if (r < 3) return null;
                var i, o, a, s = [],
                    c = [],
                    l = [];
                if (js.area(t) > 0)
                    for (o = 0; o < r; o++) c[o] = o;
                else
                    for (o = 0; o < r; o++) c[o] = r - 1 - o;
                var h = r,
                    u = 2 * h;
                for (o = h - 1; h > 2;) {
                    if (u-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), n ? l : s;
                    if (i = o, h <= i && (i = 0), o = i + 1, h <= o && (o = 0), a = o + 1, h <= a && (a = 0), e(t, i, o, a, h, c)) {
                        var d, p, f, m, g;
                        for (d = c[i], p = c[o], f = c[a], s.push([t[d], t[p], t[f]]), l.push([c[i], c[o], c[a]]), m = o, g = o + 1; g < h; m++, g++) c[m] = c[g];
                        h--, u = 2 * h
                    }
                }
                return n ? l : s
            }
        }(),
        triangulateShape: function(e, t) {
            function n(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function r(e, t, n) {
                return e.x !== t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x : t.x <= n.x && n.x <= e.x : e.y < t.y ? e.y <= n.y && n.y <= t.y : t.y <= n.y && n.y <= e.y
            }

            function i(e, t, n, i, o) {
                var a = t.x - e.x,
                    s = t.y - e.y,
                    c = i.x - n.x,
                    l = i.y - n.y,
                    h = e.x - n.x,
                    u = e.y - n.y,
                    d = s * c - a * l,
                    p = s * h - a * u;
                if (Math.abs(d) > Number.EPSILON) {
                    var f;
                    if (d > 0) {
                        if (p < 0 || p > d) return [];
                        if ((f = l * h - c * u) < 0 || f > d) return []
                    } else {
                        if (p > 0 || p < d) return [];
                        if ((f = l * h - c * u) > 0 || f < d) return []
                    }
                    if (0 === f) return !o || 0 !== p && p !== d ? [e] : [];
                    if (f === d) return !o || 0 !== p && p !== d ? [t] : [];
                    if (0 === p) return [n];
                    if (p === d) return [i];
                    var m = f / d;
                    return [{
                        x: e.x + m * a,
                        y: e.y + m * s
                    }]
                }
                if (0 !== p || l * h != c * u) return [];
                var g = 0 === a && 0 === s,
                    v = 0 === c && 0 === l;
                if (g && v) return e.x !== n.x || e.y !== n.y ? [] : [e];
                if (g) return r(n, i, e) ? [e] : [];
                if (v) return r(e, t, n) ? [n] : [];
                var y, b, x, w, _, M, E, T;
                return 0 !== a ? (e.x < t.x ? (y = e, x = e.x, b = t, w = t.x) : (y = t, x = t.x, b = e, w = e.x), n.x < i.x ? (_ = n, E = n.x, M = i, T = i.x) : (_ = i, E = i.x, M = n, T = n.x)) : (e.y < t.y ? (y = e, x = e.y, b = t, w = t.y) : (y = t, x = t.y, b = e, w = e.y), n.y < i.y ? (_ = n, E = n.y, M = i, T = i.y) : (_ = i, E = i.y, M = n, T = n.y)), x <= E ? w < E ? [] : w === E ? o ? [] : [_] : w <= T ? [_, b] : [_, M] : x > T ? [] : x === T ? o ? [] : [y] : w <= T ? [y, b] : [y, M]
            }

            function o(e, t, n, r) {
                var i = t.x - e.x,
                    o = t.y - e.y,
                    a = n.x - e.x,
                    s = n.y - e.y,
                    c = r.x - e.x,
                    l = r.y - e.y,
                    h = i * s - o * a,
                    u = i * l - o * c;
                if (Math.abs(h) > Number.EPSILON) {
                    var d = c * s - l * a;
                    return h > 0 ? u >= 0 && d >= 0 : u >= 0 || d >= 0
                }
                return u > 0
            }
            n(e), t.forEach(n);
            for (var a, s, c, l, h, u, d = {}, p = e.concat(), f = 0, m = t.length; f < m; f++) Array.prototype.push.apply(p, t[f]);
            for (a = 0, s = p.length; a < s; a++) h = p[a].x + ":" + p[a].y, void 0 !== d[h] && console.warn("THREE.ShapeUtils: Duplicate point", h, a), d[h] = a;
            var g = function(e, t) {
                    for (var n, r, a, s, c, l, h, u, d, p, f, m = e.concat(), g = [], v = [], y = 0, b = t.length; y < b; y++) g.push(y);
                    for (var x = 0, w = 2 * g.length; g.length > 0;) {
                        if (--w < 0) {
                            console.log("Infinite Loop! Holes left:" + g.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (a = x; a < m.length; a++) {
                            s = m[a], r = -1;
                            for (var y = 0; y < g.length; y++)
                                if (l = g[y], h = s.x + ":" + s.y + ":" + l, void 0 === v[h]) {
                                    n = t[l];
                                    for (var _ = 0; _ < n.length; _++)
                                        if (c = n[_], function(e, t) {
                                                var r = m.length - 1,
                                                    i = e - 1;
                                                i < 0 && (i = r);
                                                var a = e + 1;
                                                a > r && (a = 0);
                                                var s = o(m[e], m[i], m[a], n[t]);
                                                if (!s) return !1;
                                                var c = n.length - 1,
                                                    l = t - 1;
                                                l < 0 && (l = c);
                                                var h = t + 1;
                                                return h > c && (h = 0), !!(s = o(n[t], n[l], n[h], m[e]))
                                            }(a, _) && ! function(e, t) {
                                                var n, r, o;
                                                for (n = 0; n < m.length; n++)
                                                    if (r = n + 1, r %= m.length, o = i(e, t, m[n], m[r], !0), o.length > 0) return !0;
                                                return !1
                                            }(s, c) && ! function(e, n) {
                                                var r, o, a, s, c;
                                                for (r = 0; r < g.length; r++)
                                                    for (o = t[g[r]], a = 0; a < o.length; a++)
                                                        if (s = a + 1, s %= o.length, c = i(e, n, o[a], o[s], !0), c.length > 0) return !0;
                                                return !1
                                            }(s, c)) {
                                            r = _, g.splice(y, 1), u = m.slice(0, a + 1), d = m.slice(a), p = n.slice(r), f = n.slice(0, r + 1), m = u.concat(p).concat(f).concat(d), x = a;
                                            break
                                        }
                                    if (r >= 0) break;
                                    v[h] = !0
                                }
                            if (r >= 0) break
                        }
                    }
                    return m
                }(e, t),
                v = js.triangulate(g, !1);
            for (a = 0, s = v.length; a < s; a++)
                for (l = v[a], c = 0; c < 3; c++) h = l[c].x + ":" + l[c].y, void 0 !== (u = d[h]) && (l[c] = u);
            return v.concat()
        },
        isClockWise: function(e) {
            return js.area(e) < 0
        }
    };
    nn.prototype = Object.create(Pe.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(Ce.prototype), rn.prototype.constructor = rn, rn.prototype.getArrays = function() {
        var e = this.getAttribute("position"),
            t = e ? Array.prototype.slice.call(e.array) : [],
            n = this.getAttribute("uv"),
            r = n ? Array.prototype.slice.call(n.array) : [],
            i = this.index;
        return {
            position: t,
            uv: r,
            index: i ? Array.prototype.slice.call(i.array) : []
        }
    }, rn.prototype.addShapeList = function(e, t) {
        var n = e.length;
        t.arrays = this.getArrays();
        for (var r = 0; r < n; r++) {
            var i = e[r];
            this.addShape(i, t)
        }
        this.setIndex(t.arrays.index), this.addAttribute("position", new Me(t.arrays.position, 3)), this.addAttribute("uv", new Me(t.arrays.uv, 2))
    }, rn.prototype.addShape = function(e, t) {
        function n(e, t, n) {
            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
        }

        function r(e, t, n) {
            var r, o, a = 1,
                s = e.x - t.x,
                c = e.y - t.y,
                l = n.x - e.x,
                h = n.y - e.y,
                u = s * s + c * c,
                d = s * h - c * l;
            if (Math.abs(d) > Number.EPSILON) {
                var p = Math.sqrt(u),
                    f = Math.sqrt(l * l + h * h),
                    m = t.x - c / p,
                    g = t.y + s / p,
                    v = n.x - h / f,
                    y = n.y + l / f,
                    b = ((v - m) * h - (y - g) * l) / (s * h - c * l);
                r = m + s * b - e.x, o = g + c * b - e.y;
                var x = r * r + o * o;
                if (x <= 2) return new i(r, o);
                a = Math.sqrt(x / 2)
            } else {
                var w = !1;
                s > Number.EPSILON ? l > Number.EPSILON && (w = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (w = !0) : Math.sign(c) === Math.sign(h) && (w = !0), w ? (r = -c, o = s, a = Math.sqrt(u)) : (r = s, o = c, a = Math.sqrt(u / 2))
            }
            return new i(r / a, o / a)
        }

        function o(e, t) {
            var n, r;
            for (J = e.length; --J >= 0;) {
                n = J, r = J - 1, r < 0 && (r = e.length - 1);
                var i = 0,
                    o = P + 2 * T;
                for (i = 0; i < o; i++) {
                    var a = q * i,
                        s = q * (i + 1);
                    c(t + n + a, t + r + a, t + r + s, t + n + s, e, i, o, n, r)
                }
            }
        }

        function a(e, t, n) {
            w.push(e), w.push(t), w.push(n)
        }

        function s(e, t, n) {
            l(e), l(t), l(n);
            var r = y.length / 3,
                i = R.generateTopUV(D, y, r - 3, r - 2, r - 1);
            u(i[0]), u(i[1]), u(i[2])
        }

        function c(e, t, n, r, i, o, a, s, c) {
            l(e), l(t), l(r), l(t), l(n), l(r);
            var h = y.length / 3,
                d = R.generateSideWallUV(D, y, h - 6, h - 3, h - 2, h - 1);
            u(d[0]), u(d[1]), u(d[3]), u(d[1]), u(d[2]), u(d[3])
        }

        function l(e) {
            b.push(y.length / 3), y.push(w[3 * e + 0]), y.push(w[3 * e + 1]), y.push(w[3 * e + 2])
        }

        function u(e) {
            x.push(e.x), x.push(e.y)
        }
        var d, p, f, m, g, v = t.arrays ? t.arrays : this.getArrays(),
            y = v.position,
            b = v.index,
            x = v.uv,
            w = [],
            _ = void 0 !== t.amount ? t.amount : 100,
            M = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            E = void 0 !== t.bevelSize ? t.bevelSize : M - 2,
            T = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
            S = void 0 === t.bevelEnabled || t.bevelEnabled,
            A = void 0 !== t.curveSegments ? t.curveSegments : 12,
            P = void 0 !== t.steps ? t.steps : 1,
            C = t.extrudePath,
            L = !1,
            R = void 0 !== t.UVGenerator ? t.UVGenerator : nn.WorldUVGenerator;
        C && (d = C.getSpacedPoints(P), L = !0, S = !1, p = void 0 !== t.frames ? t.frames : C.computeFrenetFrames(P, !1), f = new h, m = new h, g = new h), S || (T = 0, M = 0, E = 0);
        var I, O, k, D = this,
            N = e.extractPoints(A),
            B = N.shape,
            U = N.holes,
            F = !js.isClockWise(B);
        if (F) {
            for (B = B.reverse(), O = 0, k = U.length; O < k; O++) I = U[O], js.isClockWise(I) && (U[O] = I.reverse());
            F = !1
        }
        var z = js.triangulateShape(B, U),
            j = B;
        for (O = 0, k = U.length; O < k; O++) I = U[O], B = B.concat(I);
        for (var H, V, G, W, $, X, q = B.length, Y = z.length, Z = [], J = 0, K = j.length, Q = K - 1, ee = J + 1; J < K; J++, Q++, ee++) Q === K && (Q = 0), ee === K && (ee = 0), Z[J] = r(j[J], j[Q], j[ee]);
        var te, ne = [],
            re = Z.concat();
        for (O = 0, k = U.length; O < k; O++) {
            for (I = U[O], te = [], J = 0, K = I.length, Q = K - 1, ee = J + 1; J < K; J++, Q++, ee++) Q === K && (Q = 0), ee === K && (ee = 0), te[J] = r(I[J], I[Q], I[ee]);
            ne.push(te), re = re.concat(te)
        }
        for (H = 0; H < T; H++) {
            for (G = H / T, W = M * Math.cos(G * Math.PI / 2), V = E * Math.sin(G * Math.PI / 2), J = 0, K = j.length; J < K; J++) $ = n(j[J], Z[J], V), a($.x, $.y, -W);
            for (O = 0, k = U.length; O < k; O++)
                for (I = U[O], te = ne[O], J = 0, K = I.length; J < K; J++) $ = n(I[J], te[J], V), a($.x, $.y, -W)
        }
        for (V = E, J = 0; J < q; J++) $ = S ? n(B[J], re[J], V) : B[J], L ? (m.copy(p.normals[0]).multiplyScalar($.x), f.copy(p.binormals[0]).multiplyScalar($.y), g.copy(d[0]).add(m).add(f), a(g.x, g.y, g.z)) : a($.x, $.y, 0);
        var ie;
        for (ie = 1; ie <= P; ie++)
            for (J = 0; J < q; J++) $ = S ? n(B[J], re[J], V) : B[J], L ? (m.copy(p.normals[ie]).multiplyScalar($.x), f.copy(p.binormals[ie]).multiplyScalar($.y), g.copy(d[ie]).add(m).add(f), a(g.x, g.y, g.z)) : a($.x, $.y, _ / P * ie);
        for (H = T - 1; H >= 0; H--) {
            for (G = H / T, W = M * Math.cos(G * Math.PI / 2), V = E * Math.sin(G * Math.PI / 2), J = 0, K = j.length; J < K; J++) $ = n(j[J], Z[J], V), a($.x, $.y, _ + W);
            for (O = 0, k = U.length; O < k; O++)
                for (I = U[O], te = ne[O], J = 0, K = I.length; J < K; J++) $ = n(I[J], te[J], V), L ? a($.x, $.y + d[P - 1].y, d[P - 1].x + W) : a($.x, $.y, _ + W)
        }! function() {
            var e = y.length / 3;
            if (S) {
                var n = 0,
                    r = q * n;
                for (J = 0; J < Y; J++) X = z[J], s(X[2] + r, X[1] + r, X[0] + r);
                for (n = P + 2 * T, r = q * n, J = 0; J < Y; J++) X = z[J], s(X[0] + r, X[1] + r, X[2] + r)
            } else {
                for (J = 0; J < Y; J++) X = z[J], s(X[2], X[1], X[0]);
                for (J = 0; J < Y; J++) X = z[J], s(X[0] + q * P, X[1] + q * P, X[2] + q * P)
            }
            D.addGroup(e, y.length / 3 - e, void 0 !== t.material ? t.material : 0)
        }(),
        function() {
            var e = y.length / 3,
                n = 0;
            for (o(j, n), n += j.length, O = 0, k = U.length; O < k; O++) I = U[O], o(I, n), n += I.length;
            D.addGroup(e, y.length / 3 - e, void 0 !== t.extrudeMaterial ? t.extrudeMaterial : 1)
        }(), t.arrays || (this.setIndex(b), this.addAttribute("position", new Me(y, 3)), this.addAttribute("uv", new Me(t.arrays.uv, 2)))
    }, nn.WorldUVGenerator = {
        generateTopUV: function(e, t, n, r, o) {
            var a = t[3 * n],
                s = t[3 * n + 1],
                c = t[3 * r],
                l = t[3 * r + 1],
                h = t[3 * o],
                u = t[3 * o + 1];
            return [new i(a, s), new i(c, l), new i(h, u)]
        },
        generateSideWallUV: function(e, t, n, r, o, a) {
            var s = t[3 * n],
                c = t[3 * n + 1],
                l = t[3 * n + 2],
                h = t[3 * r],
                u = t[3 * r + 1],
                d = t[3 * r + 2],
                p = t[3 * o],
                f = t[3 * o + 1],
                m = t[3 * o + 2],
                g = t[3 * a],
                v = t[3 * a + 1],
                y = t[3 * a + 2];
            return Math.abs(c - u) < .01 ? [new i(s, 1 - l), new i(h, 1 - d), new i(p, 1 - m), new i(g, 1 - y)] : [new i(c, 1 - l), new i(u, 1 - d), new i(f, 1 - m), new i(v, 1 - y)]
        }
    }, on.prototype = Object.create(Pe.prototype), on.prototype.constructor = on, an.prototype = Object.create(rn.prototype), an.prototype.constructor = an, sn.prototype = Object.create(Pe.prototype), sn.prototype.constructor = sn, cn.prototype = Object.create(Ce.prototype), cn.prototype.constructor = cn, ln.prototype = Object.create(Pe.prototype), ln.prototype.constructor = ln, hn.prototype = Object.create(Ce.prototype), hn.prototype.constructor = hn, un.prototype = Object.create(Pe.prototype), un.prototype.constructor = un, dn.prototype = Object.create(Ce.prototype), dn.prototype.constructor = dn, pn.prototype = Object.create(Pe.prototype), pn.prototype.constructor = pn, fn.prototype = Object.create(Ce.prototype), fn.prototype.constructor = fn, mn.prototype = Object.create(Ce.prototype), mn.prototype.constructor = mn, gn.prototype = Object.create(Pe.prototype), gn.prototype.constructor = gn, vn.prototype = Object.create(Ce.prototype), vn.prototype.constructor = vn, yn.prototype = Object.create(gn.prototype), yn.prototype.constructor = yn, bn.prototype = Object.create(vn.prototype), bn.prototype.constructor = bn, xn.prototype = Object.create(Pe.prototype), xn.prototype.constructor = xn, wn.prototype = Object.create(Ce.prototype), wn.prototype.constructor = wn;
    var Hs = Object.freeze({
        WireframeGeometry: Bt,
        ParametricGeometry: Ut,
        ParametricBufferGeometry: Ft,
        TetrahedronGeometry: Ht,
        TetrahedronBufferGeometry: Vt,
        OctahedronGeometry: Gt,
        OctahedronBufferGeometry: Wt,
        IcosahedronGeometry: $t,
        IcosahedronBufferGeometry: Xt,
        DodecahedronGeometry: qt,
        DodecahedronBufferGeometry: Yt,
        PolyhedronGeometry: zt,
        PolyhedronBufferGeometry: jt,
        TubeGeometry: Zt,
        TubeBufferGeometry: Jt,
        TorusKnotGeometry: Kt,
        TorusKnotBufferGeometry: Qt,
        TorusGeometry: en,
        TorusBufferGeometry: tn,
        TextGeometry: on,
        TextBufferGeometry: an,
        SphereGeometry: sn,
        SphereBufferGeometry: cn,
        RingGeometry: ln,
        RingBufferGeometry: hn,
        PlaneGeometry: Oe,
        PlaneBufferGeometry: ke,
        LatheGeometry: un,
        LatheBufferGeometry: dn,
        ShapeGeometry: pn,
        ShapeBufferGeometry: fn,
        ExtrudeGeometry: nn,
        ExtrudeBufferGeometry: rn,
        EdgesGeometry: mn,
        ConeGeometry: yn,
        ConeBufferGeometry: bn,
        CylinderGeometry: gn,
        CylinderBufferGeometry: vn,
        CircleGeometry: xn,
        CircleBufferGeometry: wn,
        BoxGeometry: Re,
        BoxBufferGeometry: Ie
    });
    _n.prototype = Object.create(Q.prototype), _n.prototype.constructor = _n, _n.prototype.isShadowMaterial = !0, Mn.prototype = Object.create(Q.prototype), Mn.prototype.constructor = Mn, Mn.prototype.isRawShaderMaterial = !0, En.prototype = Object.create(K.prototype), En.prototype.constructor = En, En.prototype.isMeshStandardMaterial = !0, En.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Tn.prototype = Object.create(En.prototype), Tn.prototype.constructor = Tn, Tn.prototype.isMeshPhysicalMaterial = !0, Tn.prototype.copy = function(e) {
        return En.prototype.copy.call(this, e), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, Sn.prototype = Object.create(K.prototype), Sn.prototype.constructor = Sn, Sn.prototype.isMeshPhongMaterial = !0, Sn.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, An.prototype = Object.create(Sn.prototype), An.prototype.constructor = An, An.prototype.isMeshToonMaterial = !0, An.prototype.copy = function(e) {
        return Sn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, Pn.prototype = Object.create(K.prototype), Pn.prototype.constructor = Pn, Pn.prototype.isMeshNormalMaterial = !0, Pn.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Cn.prototype = Object.create(K.prototype), Cn.prototype.constructor = Cn, Cn.prototype.isMeshLambertMaterial = !0, Cn.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Ln.prototype = Object.create(K.prototype), Ln.prototype.constructor = Ln, Ln.prototype.isLineDashedMaterial = !0, Ln.prototype.copy = function(e) {
        return K.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var Vs = Object.freeze({
            ShadowMaterial: _n,
            SpriteMaterial: xt,
            RawShaderMaterial: Mn,
            ShaderMaterial: Q,
            PointsMaterial: Lt,
            MeshPhysicalMaterial: Tn,
            MeshStandardMaterial: En,
            MeshPhongMaterial: Sn,
            MeshToonMaterial: An,
            MeshNormalMaterial: Pn,
            MeshLambertMaterial: Cn,
            MeshDepthMaterial: ee,
            MeshBasicMaterial: fe,
            LineDashedMaterial: Ln,
            LineBasicMaterial: St,
            Material: K
        }),
        Gs = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        },
        Ws = new Rn;
    Object.assign(In.prototype, {
        load: function(e, t, n, r) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
            var i = this,
                o = Gs.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() {
                t && t(o), i.manager.itemEnd(e)
            }, 0), o;
            var a = /^data:(.*?)(;base64)?,(.*)$/,
                s = e.match(a);
            if (s) {
                var c = s[1],
                    l = !!s[2],
                    h = s[3];
                h = window.decodeURIComponent(h), l && (h = window.atob(h));
                try {
                    var u, d = (this.responseType || "").toLowerCase();
                    switch (d) {
                        case "arraybuffer":
                        case "blob":
                            u = new ArrayBuffer(h.length);
                            for (var p = new Uint8Array(u), f = 0; f < h.length; f++) p[f] = h.charCodeAt(f);
                            "blob" === d && (u = new Blob([u], {
                                type: c
                            }));
                            break;
                        case "document":
                            var m = new DOMParser;
                            u = m.parseFromString(h, c);
                            break;
                        case "json":
                            u = JSON.parse(h);
                            break;
                        default:
                            u = h
                    }
                    window.setTimeout(function() {
                        t && t(u), i.manager.itemEnd(e)
                    }, 0)
                } catch (t) {
                    window.setTimeout(function() {
                        r && r(t), i.manager.itemEnd(e), i.manager.itemError(e)
                    }, 0)
                }
            } else {
                var g = new XMLHttpRequest;
                g.open("GET.html", e, !0), g.addEventListener("load", function(n) {
                    var o = n.target.response;
                    Gs.add(e, o), 200 === this.status ? (t && t(o), i.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), t && t(o), i.manager.itemEnd(e)) : (r && r(n), i.manager.itemEnd(e), i.manager.itemError(e))
                }, !1), void 0 !== n && g.addEventListener("progress", function(e) {
                    n(e)
                }, !1), g.addEventListener("error", function(t) {
                    r && r(t), i.manager.itemEnd(e), i.manager.itemError(e)
                }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (var v in this.requestHeader) g.setRequestHeader(v, this.requestHeader[v]);
                g.send(null)
            }
            return i.manager.itemStart(e), g
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResponseType: function(e) {
            return this.responseType = e, this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e, this
        },
        setMimeType: function(e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(On.prototype, {
        load: function(e, t, n, r) {
            var i = this,
                o = [],
                a = new kt;
            a.image = o;
            var s = new In(this.manager);
            if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))
                for (var c = 0, l = 0, h = e.length; l < h; ++l) ! function(l) {
                    s.load(e[l], function(e) {
                        var n = i._parser(e, !0);
                        o[l] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        }, 6 === (c += 1) && (1 === n.mipmapCount && (a.minFilter = Ma), a.format = n.format, a.needsUpdate = !0, t && t(a))
                    }, n, r)
                }(l);
            else s.load(e, function(e) {
                var n = i._parser(e, !0);
                if (n.isCubemap)
                    for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
                        o[s] = {
                            mipmaps: []
                        };
                        for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                1 === n.mipmapCount && (a.minFilter = Ma), a.format = n.format, a.needsUpdate = !0, t && t(a)
            }, n, r);
            return a
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(kn.prototype, {
        load: function(e, t, n, r) {
            var i = this,
                o = new d,
                a = new In(this.manager);
            return a.setResponseType("arraybuffer"), a.load(e, function(e) {
                var n = i._parser(e);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : ya, o.wrapT = void 0 !== n.wrapT ? n.wrapT : ya, o.magFilter = void 0 !== n.magFilter ? n.magFilter : Ma, o.minFilter = void 0 !== n.minFilter ? n.minFilter : Ta, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = Ma), o.needsUpdate = !0, t && t(o, n))
            }, n, r), o
        }
    }), Object.assign(Dn.prototype, {
        load: function(e, t, n, r) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e);
            var i = this,
                o = Gs.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout(function() {
                t && t(o), i.manager.itemEnd(e)
            }, 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return a.addEventListener("load", function() {
                Gs.add(e, this), t && t(this), i.manager.itemEnd(e)
            }, !1), a.addEventListener("error", function(t) {
                r && r(t), i.manager.itemEnd(e), i.manager.itemError(e)
            }, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Nn.prototype, {
        load: function(e, t, n, r) {
            var i = new p,
                o = new Dn(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            for (var a = 0, s = 0; s < e.length; ++s) ! function(n) {
                o.load(e[n], function(e) {
                    i.images[n] = e, 6 == ++a && (i.needsUpdate = !0, t && t(i))
                }, void 0, r)
            }(s);
            return i
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Object.assign(Bn.prototype, {
        load: function(e, t, n, r) {
            var i = new Dn(this.manager);
            i.setCrossOrigin(this.crossOrigin), i.setPath(this.path);
            var a = new o;
            return a.image = i.load(e, function() {
                var n = e.search(/\.(jpg|jpeg)$/) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                a.format = n ? Fa : za, a.needsUpdate = !0, void 0 !== t && t(a)
            }, n, r), a
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        }
    }), Un.prototype = Object.assign(Object.create(he.prototype), {
        constructor: Un,
        isLight: !0,
        copy: function(e) {
            return he.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            var t = he.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }), Fn.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: Fn,
        isHemisphereLight: !0,
        copy: function(e) {
            return Un.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(zn.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), jn.prototype = Object.assign(Object.create(zn.prototype), {
        constructor: jn,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera,
                n = 2 * Ms.RAD2DEG * e.angle,
                r = this.mapSize.width / this.mapSize.height,
                i = e.distance || t.far;
            n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix())
        }
    }), Hn.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: Hn,
        isSpotLight: !0,
        copy: function(e) {
            return Un.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), Vn.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: Vn,
        isPointLight: !0,
        copy: function(e) {
            return Un.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), Gn.prototype = Object.assign(Object.create(zn.prototype), {
        constructor: Gn
    }), Wn.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: Wn,
        isDirectionalLight: !0,
        copy: function(e) {
            return Un.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), $n.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: $n,
        isAmbientLight: !0
    }), Xn.prototype = Object.assign(Object.create(Un.prototype), {
        constructor: Xn,
        isRectAreaLight: !0,
        copy: function(e) {
            return Un.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function(e) {
            var t = Un.prototype.toJSON.call(this, e);
            return t.object.width = this.width, t.object.height = this.height, t
        }
    });
    var $s = {
        arraySlice: function(e, t, n) {
            return $s.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
        },
        convertArray: function(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(e) {
            function t(t, n) {
                return e[t] - e[n]
            }
            for (var n = e.length, r = new Array(n), i = 0; i !== n; ++i) r[i] = i;
            return r.sort(t), r
        },
        sortedArray: function(e, t, n) {
            for (var r = e.length, i = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                for (var s = n[o] * t, c = 0; c !== t; ++c) i[a++] = e[s + c];
            return i
        },
        flattenJSON: function(e, t, n, r) {
            for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[i++];
            if (void 0 !== o) {
                var a = o[r];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = o[r], void 0 !== a && (t.push(o.time), n.push.apply(n, a)), o = e[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                    do {
                        a = o[r], void 0 !== a && (t.push(o.time), a.toArray(n, n.length)), o = e[i++]
                    } while (void 0 !== o);
                else
                    do {
                        a = o[r], void 0 !== a && (t.push(o.time), n.push(a)), o = e[i++]
                    } while (void 0 !== o)
            }
        }
    };
    Object.assign(qn.prototype, {
            evaluate: function(e) {
                var t = this.parameterPositions,
                    n = this._cachedIndex,
                    r = t[n],
                    i = t[n - 1];
                e: {
                    t: {
                        var o;
                        n: {
                            r: if (!(e < r)) {
                                for (var a = n + 2;;) {
                                    if (void 0 === r) {
                                        if (e < i) break r;
                                        return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                    }
                                    if (n === a) break;
                                    if (i = r, r = t[++n], e < r) break t
                                }
                                o = t.length;
                                break n
                            } {
                                if (e >= i) break e;
                                var s = t[1];
                                e < s && (n = 2, i = s);
                                for (var a = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                    if (n === a) break;
                                    if (r = i, i = t[--n - 1], e >= i) break t
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            var c = n + o >>> 1;
                            e < t[c] ? o = c : n = c + 1
                        }
                        if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                        if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, e, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(e) {
                for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, o = 0; o !== r; ++o) t[o] = n[i + o];
                return t
            },
            interpolate_: function(e, t, n, r) {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function(e, t, n) {}
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(qn.prototype, {
            beforeStart_: qn.prototype.copySampleValue_,
            afterEnd_: qn.prototype.copySampleValue_
        }), Yn.prototype = Object.assign(Object.create(qn.prototype), {
            constructor: Yn,
            DefaultSettings_: {
                endingStart: ss,
                endingEnd: ss
            },
            intervalChanged_: function(e, t, n) {
                var r = this.parameterPositions,
                    i = e - 2,
                    o = e + 1,
                    a = r[i],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case cs:
                        i = e, a = 2 * t - n;
                        break;
                    case ls:
                        i = r.length - 2, a = t + r[i] - r[i + 1];
                        break;
                    default:
                        i = e, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case cs:
                        o = e, s = 2 * n - t;
                        break;
                    case ls:
                        o = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        o = e - 1, s = t
                }
                var c = .5 * (n - t),
                    l = this.valueSize;
                this._weightPrev = c / (t - a), this._weightNext = c / (s - n), this._offsetPrev = i * l, this._offsetNext = o * l
            },
            interpolate_: function(e, t, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, b = d * m - d * f, x = 0; x !== a; ++x) i[x] = g * o[l + x] + v * o[c + x] + y * o[s + x] + b * o[h + x];
                return i
            }
        }), Zn.prototype = Object.assign(Object.create(qn.prototype), {
            constructor: Zn,
            interpolate_: function(e, t, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = (n - t) / (r - t), h = 1 - l, u = 0; u !== a; ++u) i[u] = o[c + u] * h + o[s + u] * l;
                return i
            }
        }), Jn.prototype = Object.assign(Object.create(qn.prototype), {
            constructor: Jn,
            interpolate_: function(e, t, n, r) {
                return this.copySampleValue_(e - 1)
            }
        });
    var Xs;
    Xs = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: os,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new Jn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new Zn(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new Yn(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
                case is:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case os:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case as:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return void console.warn(n)
            }
            this.createInterpolant = t
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return is;
                case this.InterpolantFactoryMethodLinear:
                    return os;
                case this.InterpolantFactoryMethodSmooth:
                    return as
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
            return this
        },
        trim: function(e, t) {
            for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < e;) ++i;
            for (; - 1 !== o && n[o] > t;) --o;
            if (++o, 0 !== i || o !== r) {
                i >= o && (o = Math.max(o, 1), i = o - 1);
                var a = this.getValueSize();
                this.times = $s.arraySlice(n, i, o), this.values = $s.arraySlice(this.values, i * a, o * a)
            }
            return this
        },
        validate: function() {
            var e = !0,
                t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("invalid value size in track", this), e = !1);
            var n = this.times,
                r = this.values,
                i = n.length;
            0 === i && (console.error("track is empty", this), e = !1);
            for (var o = null, a = 0; a !== i; a++) {
                var s = n[a];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("time is not a valid number", this, a, s), e = !1;
                    break
                }
                if (null !== o && o > s) {
                    console.error("out of order keys", this, a, s, o), e = !1;
                    break
                }
                o = s
            }
            if (void 0 !== r && $s.isTypedArray(r))
                for (var a = 0, c = r.length; a !== c; ++a) {
                    var l = r[a];
                    if (isNaN(l)) {
                        console.error("value is not a valid number", this, a, l), e = !1;
                        break
                    }
                }
            return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, n = this.getValueSize(), r = this.getInterpolation() === as, i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                var s = !1,
                    c = e[a];
                if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                    if (r) s = !0;
                    else
                        for (var l = a * n, h = l - n, u = l + n, d = 0; d !== n; ++d) {
                            var p = t[l + d];
                            if (p !== t[h + d] || p !== t[u + d]) {
                                s = !0;
                                break
                            }
                        }
                    if (s) {
                        if (a !== i) {
                            e[i] = e[a];
                            for (var f = a * n, m = i * n, d = 0; d !== n; ++d) t[m + d] = t[f + d]
                        }++i
                    }
            }
            if (o > 0) {
                e[i] = e[o];
                for (var f = o * n, m = i * n, d = 0; d !== n; ++d) t[m + d] = t[f + d];
                ++i
            }
            return i !== e.length && (this.times = $s.arraySlice(e, 0, i), this.values = $s.arraySlice(t, 0, i * n)), this
        }
    }, Qn.prototype = Object.assign(Object.create(Xs), {
        constructor: Qn,
        ValueTypeName: "vector"
    }), er.prototype = Object.assign(Object.create(qn.prototype), {
        constructor: er,
        interpolate_: function(e, t, n, r) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = (n - t) / (r - t), h = s + a; s !== h; s += 4) l.slerpFlat(i, 0, o, s - a, o, s, c);
            return i
        }
    }), tr.prototype = Object.assign(Object.create(Xs), {
        constructor: tr,
        ValueTypeName: "quaternion",
        DefaultInterpolation: os,
        InterpolantFactoryMethodLinear: function(e) {
            return new er(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), nr.prototype = Object.assign(Object.create(Xs), {
        constructor: nr,
        ValueTypeName: "number"
    }), rr.prototype = Object.assign(Object.create(Xs), {
        constructor: rr,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: is,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), ir.prototype = Object.assign(Object.create(Xs), {
        constructor: ir,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: is,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), or.prototype = Object.assign(Object.create(Xs), {
        constructor: or,
        ValueTypeName: "color"
    }), ar.prototype = Xs, Xs.constructor = ar, Object.assign(ar, {
        parse: function(e) {
            if (void 0 === e.type) throw new Error("track type undefined, can not parse");
            var t = ar._getTrackTypeForValueTypeName(e.type);
            if (void 0 === e.times) {
                var n = [],
                    r = [];
                $s.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        },
        toJSON: function(e) {
            var t, n = e.constructor;
            if (void 0 !== n.toJSON) t = n.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: $s.convertArray(e.times, Array),
                    values: $s.convertArray(e.values, Array)
                };
                var r = e.getInterpolation();
                r !== e.DefaultInterpolation && (t.interpolation = r)
            }
            return t.type = e.ValueTypeName, t
        },
        _getTrackTypeForValueTypeName: function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return nr;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Qn;
                case "color":
                    return or;
                case "quaternion":
                    return tr;
                case "bool":
                case "boolean":
                    return ir;
                case "string":
                    return rr
            }
            throw new Error("Unsupported typeName: " + e)
        }
    }), Object.assign(sr, {
        parse: function(e) {
            for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, o = n.length; i !== o; ++i) t.push(ar.parse(n[i]).scale(r));
            return new sr(e.name, e.duration, t)
        },
        toJSON: function(e) {
            for (var t = [], n = e.tracks, r = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t
                }, i = 0, o = n.length; i !== o; ++i) t.push(ar.toJSON(n[i]));
            return r
        },
        CreateFromMorphTargetSequence: function(e, t, n, r) {
            for (var i = t.length, o = [], a = 0; a < i; a++) {
                var s = [],
                    c = [];
                s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
                var l = $s.getKeyframeOrder(s);
                s = $s.sortedArray(s, 1, l), c = $s.sortedArray(c, 1, l), r || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new nr(".morphTargetInfluences[" + t[a].name + "]", s, c).scale(1 / n))
            }
            return new sr(e, -1, o)
        },
        findByName: function(e, t) {
            var n = e;
            if (!Array.isArray(e)) {
                var r = e;
                n = r.geometry && r.geometry.animations || r.animations
            }
            for (var i = 0; i < n.length; i++)
                if (n[i].name === t) return n[i];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, n) {
            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                var s = e[o],
                    c = s.name.match(i);
                if (c && c.length > 1) {
                    var l = c[1],
                        h = r[l];
                    h || (r[l] = h = []), h.push(s)
                }
            }
            var u = [];
            for (var l in r) u.push(sr.CreateFromMorphTargetSequence(l, r[l], t, n));
            return u
        },
        parseAnimation: function(e, t) {
            if (!e) return console.error("  no animation in JSONLoader data"), null;
            for (var n = function(e, t, n, r, i) {
                    if (0 !== n.length) {
                        var o = [],
                            a = [];
                        $s.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                    }
                }, r = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
                var l = s[c].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        for (var h = {}, u = 0; u < l.length; u++)
                            if (l[u].morphTargets)
                                for (var d = 0; d < l[u].morphTargets.length; d++) h[l[u].morphTargets[d]] = -1;
                        for (var p in h) {
                            for (var f = [], m = [], d = 0; d !== l[u].morphTargets.length; ++d) {
                                var g = l[u];
                                f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                            }
                            r.push(new nr(".morphTargetInfluence[" + p + "]", f, m))
                        }
                        o = h.length * (a || 1)
                    } else {
                        var v = ".bones[" + t[c].name + "]";
                        n(Qn, v + ".position", l, "pos", r), n(tr, v + ".quaternion", l, "rot", r), n(Qn, v + ".scale", l, "scl", r)
                    }
            }
            return 0 === r.length ? null : new sr(i, o, r)
        }
    }), Object.assign(sr.prototype, {
        resetDuration: function() {
            for (var e = this.tracks, t = 0, n = 0, r = e.length; n !== r; ++n) {
                var i = this.tracks[n];
                t = Math.max(t, i.times[i.times.length - 1])
            }
            this.duration = t
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
    }), Object.assign(cr.prototype, {
        load: function(e, t, n, r) {
            var i = this,
                o = new In(i.manager);
            o.setResponseType("json"), o.load(e, function(e) {
                t(i.parse(e))
            }, n, r)
        },
        setTextures: function(e) {
            this.textures = e
        },
        parse: function(e) {
            function t(e) {
                return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
            }
            var n = this.textures,
                r = new Vs[e.type];
            if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearCoat && (r.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (r.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.uniforms && (r.uniforms = e.uniforms), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.shading && (r.shading = e.shading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = t(e.map)), void 0 !== e.alphaMap && (r.alphaMap = t(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = t(e.normalMap)), void 0 !== e.normalScale) {
                var o = e.normalScale;
                !1 === Array.isArray(o) && (o = [o, o]), r.normalScale = (new i).fromArray(o)
            }
            return void 0 !== e.displacementMap && (r.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = t(e.specularMap)), void 0 !== e.envMap && (r.envMap = t(e.envMap)), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.lightMap && (r.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = t(e.gradientMap)), r
        }
    }), Object.assign(lr.prototype, {
        load: function(e, t, n, r) {
            var i = this,
                o = new In(i.manager);
            o.setResponseType("json"), o.load(e, function(e) {
                t(i.parse(e))
            }, n, r)
        },
        parse: function(e) {
            var t = new Ce,
                n = e.data.index;
            if (void 0 !== n) {
                var r = new qs[n.type](n.array);
                t.setIndex(new me(r, 1))
            }
            var i = e.data.attributes;
            for (var o in i) {
                var a = i[o],
                    r = new qs[a.type](a.array);
                t.addAttribute(o, new me(r, a.itemSize, a.normalized))
            }
            var s = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== s)
                for (var c = 0, l = s.length; c !== l; ++c) {
                    var u = s[c];
                    t.addGroup(u.start, u.count, u.materialIndex)
                }
            var d = e.data.boundingSphere;
            if (void 0 !== d) {
                var p = new h;
                void 0 !== d.center && p.fromArray(d.center), t.boundingSphere = new ne(p, d.radius)
            }
            return t
        }
    });
    var qs = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    hr.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, n = 0, r = t.length; n < r; n += 2) {
                var i = t[n],
                    o = t[n + 1];
                if (i.test(e)) return o
            }
            return null
        }
    }, Object.assign(hr.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function(e) {
            var t = e.split("https://productconfigurator.virtualsaleslab.com/");
            return 1 === t.length ? "./" : (t.pop(), t.join("https://productconfigurator.virtualsaleslab.com/") + "/")
        },
        initMaterials: function(e, t, n) {
            for (var r = [], i = 0; i < e.length; ++i) r[i] = this.createMaterial(e[i], t, n);
            return r
        },
        createMaterial: function() {
            var e = {
                    NoBlending: To,
                    NormalBlending: So,
                    AdditiveBlending: Ao,
                    SubtractiveBlending: Po,
                    MultiplyBlending: Co,
                    CustomBlending: Lo
                },
                t = new q,
                n = new Bn,
                r = new cr;
            return function(i, o, a) {
                function s(e, t, r, i, s) {
                    var l, h = o + e,
                        u = hr.Handlers.get(h);
                    null !== u ? l = u.load(h) : (n.setCrossOrigin(a), l = n.load(h)), void 0 !== t && (l.repeat.fromArray(t), 1 !== t[0] && (l.wrapS = va), 1 !== t[1] && (l.wrapT = va)), void 0 !== r && l.offset.fromArray(r), void 0 !== i && ("repeat" === i[0] && (l.wrapS = va), "mirror" === i[0] && (l.wrapS = ba), "repeat" === i[1] && (l.wrapT = va), "mirror" === i[1] && (l.wrapT = ba)), void 0 !== s && (l.anisotropy = s);
                    var d = Ms.generateUUID();
                    return c[d] = l, d
                }
                var c = {},
                    l = {
                        uuid: Ms.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                for (var h in i) {
                    var u = i[h];
                    switch (h) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            l.name = u;
                            break;
                        case "blending":
                            l.blending = e[u];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            l.color = t.fromArray(u).getHex();
                            break;
                        case "colorSpecular":
                            l.specular = t.fromArray(u).getHex();
                            break;
                        case "colorEmissive":
                            l.emissive = t.fromArray(u).getHex();
                            break;
                        case "specularCoef":
                            l.shininess = u;
                            break;
                        case "shading":
                            "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            l.map = s(u, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            l.emissiveMap = s(u, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            l.lightMap = s(u, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            l.aoMap = s(u, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            l.bumpMap = s(u, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            l.bumpScale = u;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            l.normalMap = s(u, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            l.normalScale = [u, u];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            l.specularMap = s(u, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            l.metalnessMap = s(u, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            l.roughnessMap = s(u, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            l.alphaMap = s(u, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            l.side = yo;
                            break;
                        case "doubleSided":
                            l.side = bo;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            l[h] = u;
                            break;
                        case "vertexColors":
                            !0 === u && (l.vertexColors = Eo), "face" === u && (l.vertexColors = Mo);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", h, u)
                    }
                }
                return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, l.opacity < 1 && (l.transparent = !0), r.setTextures(c), r.parse(l)
            }
        }()
    }), Object.assign(ur.prototype, {
        load: function(e, t, n, r) {
            var i = this,
                o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : hr.prototype.extractUrlBase(e),
                a = new In(this.manager);
            a.setResponseType("json"), a.setWithCredentials(this.withCredentials), a.load(e, function(n) {
                var r = n.metadata;
                if (void 0 !== r) {
                    var a = r.type;
                    if (void 0 !== a) {
                        if ("object" === a.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === a.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.SceneLoader instead.")
                    }
                }
                var s = i.parse(n, o);
                t(s.geometry, s.materials)
            }, n, r)
        },
        setTexturePath: function(e) {
            this.texturePath = e
        },
        parse: function() {
            function e(e, t) {
                function n(e, t) {
                    return e & 1 << t
                }
                var r, o, a, s, c, l, u, d, p, f, m, g, v, y, b, x, w, _, M, E, T, S, A, P, C, L, R, I = e.faces,
                    O = e.vertices,
                    k = e.normals,
                    D = e.colors,
                    N = e.scale,
                    B = 0;
                if (void 0 !== e.uvs) {
                    for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && B++;
                    for (r = 0; r < B; r++) t.faceVertexUvs[r] = []
                }
                for (s = 0, c = O.length; s < c;) _ = new h, _.x = O[s++] * N, _.y = O[s++] * N, _.z = O[s++] * N, t.vertices.push(_);
                for (s = 0, c = I.length; s < c;)
                    if (f = I[s++], m = n(f, 0), g = n(f, 1), v = n(f, 3), y = n(f, 4), b = n(f, 5), x = n(f, 6), w = n(f, 7), m) {
                        if (E = new pe, E.a = I[s], E.b = I[s + 1], E.c = I[s + 3], T = new pe, T.a = I[s + 1], T.b = I[s + 2], T.c = I[s + 3], s += 4, g && (p = I[s++], E.materialIndex = p, T.materialIndex = p), a = t.faces.length, v)
                            for (r = 0; r < B; r++)
                                for (P = e.uvs[r], t.faceVertexUvs[r][a] = [], t.faceVertexUvs[r][a + 1] = [], o = 0; o < 4; o++) d = I[s++], L = P[2 * d], R = P[2 * d + 1], C = new i(L, R), 2 !== o && t.faceVertexUvs[r][a].push(C), 0 !== o && t.faceVertexUvs[r][a + 1].push(C);
                        if (y && (u = 3 * I[s++], E.normal.set(k[u++], k[u++], k[u]), T.normal.copy(E.normal)), b)
                            for (r = 0; r < 4; r++) u = 3 * I[s++], A = new h(k[u++], k[u++], k[u]), 2 !== r && E.vertexNormals.push(A), 0 !== r && T.vertexNormals.push(A);
                        if (x && (l = I[s++], S = D[l], E.color.setHex(S), T.color.setHex(S)), w)
                            for (r = 0; r < 4; r++) l = I[s++], S = D[l], 2 !== r && E.vertexColors.push(new q(S)), 0 !== r && T.vertexColors.push(new q(S));
                        t.faces.push(E), t.faces.push(T)
                    } else {
                        if (M = new pe, M.a = I[s++], M.b = I[s++], M.c = I[s++], g && (p = I[s++], M.materialIndex = p), a = t.faces.length, v)
                            for (r = 0; r < B; r++)
                                for (P = e.uvs[r], t.faceVertexUvs[r][a] = [], o = 0; o < 3; o++) d = I[s++], L = P[2 * d], R = P[2 * d + 1], C = new i(L, R), t.faceVertexUvs[r][a].push(C);
                        if (y && (u = 3 * I[s++], M.normal.set(k[u++], k[u++], k[u])), b)
                            for (r = 0; r < 3; r++) u = 3 * I[s++], A = new h(k[u++], k[u++], k[u]), M.vertexNormals.push(A);
                        if (x && (l = I[s++], M.color.setHex(D[l])), w)
                            for (r = 0; r < 3; r++) l = I[s++], M.vertexColors.push(new q(D[l]));
                        t.faces.push(M)
                    }
            }

            function t(e, t) {
                var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                if (e.skinWeights)
                    for (var r = 0, i = e.skinWeights.length; r < i; r += n) {
                        var o = e.skinWeights[r],
                            s = n > 1 ? e.skinWeights[r + 1] : 0,
                            c = n > 2 ? e.skinWeights[r + 2] : 0,
                            l = n > 3 ? e.skinWeights[r + 3] : 0;
                        t.skinWeights.push(new a(o, s, c, l))
                    }
                if (e.skinIndices)
                    for (var r = 0, i = e.skinIndices.length; r < i; r += n) {
                        var h = e.skinIndices[r],
                            u = n > 1 ? e.skinIndices[r + 1] : 0,
                            d = n > 2 ? e.skinIndices[r + 2] : 0,
                            p = n > 3 ? e.skinIndices[r + 3] : 0;
                        t.skinIndices.push(new a(h, u, d, p))
                    }
                t.bones = e.bones, t.bones && t.bones.length > 0 && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
            }

            function n(e, t) {
                var n = e.scale;
                if (void 0 !== e.morphTargets)
                    for (var r = 0, i = e.morphTargets.length; r < i; r++) {
                        t.morphTargets[r] = {}, t.morphTargets[r].name = e.morphTargets[r].name, t.morphTargets[r].vertices = [];
                        for (var o = t.morphTargets[r].vertices, a = e.morphTargets[r].vertices, s = 0, c = a.length; s < c; s += 3) {
                            var l = new h;
                            l.x = a[s] * n, l.y = a[s + 1] * n, l.z = a[s + 2] * n, o.push(l)
                        }
                    }
                if (void 0 !== e.morphColors && e.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var u = t.faces, d = e.morphColors[0].colors, r = 0, i = u.length; r < i; r++) u[r].color.fromArray(d, 3 * r)
                }
            }

            function r(e, t) {
                var n = [],
                    r = [];
                void 0 !== e.animation && r.push(e.animation), void 0 !== e.animations && (e.animations.length ? r = r.concat(e.animations) : r.push(e.animations));
                for (var i = 0; i < r.length; i++) {
                    var o = sr.parseAnimation(r[i], t.bones);
                    o && n.push(o)
                }
                if (t.morphTargets) {
                    var a = sr.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                    n = n.concat(a)
                }
                n.length > 0 && (t.animations = n)
            }
            return function(i, o) {
                void 0 !== i.data && (i = i.data), void 0 !== i.scale ? i.scale = 1 / i.scale : i.scale = 1;
                var a = new Pe;
                return e(i, a), t(i, a), n(i, a), r(i, a), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === i.materials || 0 === i.materials.length ? {
                    geometry: a
                } : {
                    geometry: a,
                    materials: hr.prototype.initMaterials(i.materials, o, this.crossOrigin)
                }
            }
        }()
    }), Object.assign(dr.prototype, {
        load: function(e, t, n, r) {
            "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("https://productconfigurator.virtualsaleslab.com/") + 1));
            var i = this;
            new In(i.manager).load(e, function(n) {
                var o = null;
                try {
                    o = JSON.parse(n)
                } catch (t) {
                    return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                var a = o.metadata;
                if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.");
                i.parse(o, t)
            }, n, r)
        },
        setTexturePath: function(e) {
            this.texturePath = e
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        parse: function(e, t) {
            var n = this.parseGeometries(e.geometries),
                r = this.parseImages(e.images, function() {
                    void 0 !== t && t(a)
                }),
                i = this.parseTextures(e.textures, r),
                o = this.parseMaterials(e.materials, i),
                a = this.parseObject(e.object, n, o);
            return e.animations && (a.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(a), a
        },
        parseGeometries: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var n = new ur, r = new lr, i = 0, o = e.length; i < o; i++) {
                    var a, s = e[i];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new Hs[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            a = new Hs[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            a = new Hs[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            a = new Hs[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            a = new Hs[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            a = new Hs[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "IcosahedronGeometry":
                        case "OctahedronGeometry":
                        case "TetrahedronGeometry":
                            a = new Hs[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            a = new Hs[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            a = new Hs[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            a = new Hs[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            a = new Hs[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "BufferGeometry":
                            a = r.parse(s);
                            break;
                        case "Geometry":
                            a = n.parse(s, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), t[s.uuid] = a
                }
            return t
        },
        parseMaterials: function(e, t) {
            var n = {};
            if (void 0 !== e) {
                var r = new cr;
                r.setTextures(t);
                for (var i = 0, o = e.length; i < o; i++) {
                    var a = e[i];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], c = 0; c < a.materials.length; c++) s.push(r.parse(a.materials[c]));
                        n[a.uuid] = s
                    } else n[a.uuid] = r.parse(a)
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = sr.parse(e[n]);
                t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            var n = this,
                r = {};
            if (void 0 !== e && e.length > 0) {
                var i = new Rn(t),
                    o = new Dn(i);
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = e.length; a < s; a++) {
                    var c = e[a],
                        l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                    r[c.uuid] = function(e) {
                        return n.manager.itemStart(e), o.load(e, function() {
                            n.manager.itemEnd(e)
                        }, void 0, function() {
                            n.manager.itemEnd(e), n.manager.itemError(e)
                        })
                    }(l)
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            function n(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var r = {};
            if (void 0 !== e)
                for (var i = 0, a = e.length; i < a; i++) {
                    var s = e[i];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    var c = new o(t[s.image]);
                    c.needsUpdate = !0, c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = n(s.mapping, Ys)), void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), void 0 !== s.wrap && (c.wrapS = n(s.wrap[0], Zs), c.wrapT = n(s.wrap[1], Zs)), void 0 !== s.minFilter && (c.minFilter = n(s.minFilter, Js)), void 0 !== s.magFilter && (c.magFilter = n(s.magFilter, Js)), void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), r[s.uuid] = c
                }
            return r
        },
        parseObject: function() {
            var e = new u;
            return function(t, n, r) {
                function i(e) {
                    return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), n[e]
                }

                function o(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            for (var t = [], n = 0, i = e.length; n < i; n++) {
                                var o = e[n];
                                void 0 === r[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(r[o])
                            }
                            return t
                        }
                        return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined material", e), r[e]
                    }
                }
                var a;
                switch (t.type) {
                    case "Scene":
                        a = new yt, void 0 !== t.background && Number.isInteger(t.background) && (a.background = new q(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? a.fog = new vt(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (a.fog = new gt(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        a = new Ne(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (a.focus = t.focus), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset), void 0 !== t.view && (a.view = Object.assign({}, t.view));
                        break;
                    case "OrthographicCamera":
                        a = new Be(t.left, t.right, t.top, t.bottom, t.near, t.far);
                        break;
                    case "AmbientLight":
                        a = new $n(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        a = new Wn(t.color, t.intensity);
                        break;
                    case "PointLight":
                        a = new Vn(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        a = new Xn(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        a = new Hn(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        a = new Fn(t.color, t.groundColor, t.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        var s = i(t.geometry),
                            c = o(t.material);
                        a = s.bones && s.bones.length > 0 ? new Tt(s, c) : new Le(s, c);
                        break;
                    case "LOD":
                        a = new _t;
                        break;
                    case "Line":
                        a = new At(i(t.geometry), o(t.material), t.mode);
                        break;
                    case "LineLoop":
                        a = new Ct(i(t.geometry), o(t.material));
                        break;
                    case "LineSegments":
                        a = new Pt(i(t.geometry), o(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        a = new Rt(i(t.geometry), o(t.material));
                        break;
                    case "Sprite":
                        a = new wt(o(t.material));
                        break;
                    case "Group":
                        a = new It;
                        break;
                    default:
                        a = new he
                }
                if (a.uuid = t.uuid, void 0 !== t.name && (a.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== t.position && a.position.fromArray(t.position), void 0 !== t.rotation && a.rotation.fromArray(t.rotation), void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion), void 0 !== t.scale && a.scale.fromArray(t.scale)), void 0 !== t.castShadow && (a.castShadow = t.castShadow), void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && a.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (a.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (a.visible = t.visible), void 0 !== t.userData && (a.userData = t.userData), void 0 !== t.children)
                    for (var l in t.children) a.add(this.parseObject(t.children[l], n, r));
                if ("LOD" === t.type)
                    for (var h = t.levels, u = 0; u < h.length; u++) {
                        var d = h[u],
                            l = a.getObjectByProperty("uuid", d.object);
                        void 0 !== l && a.addLevel(l, d.distance)
                    }
                return a
            }
        }()
    });
    var Ys = {
            UVMapping: la,
            CubeReflectionMapping: ha,
            CubeRefractionMapping: ua,
            EquirectangularReflectionMapping: da,
            EquirectangularRefractionMapping: pa,
            SphericalReflectionMapping: fa,
            CubeUVReflectionMapping: ma,
            CubeUVRefractionMapping: ga
        },
        Zs = {
            RepeatWrapping: va,
            ClampToEdgeWrapping: ya,
            MirroredRepeatWrapping: ba
        },
        Js = {
            NearestFilter: xa,
            NearestMipMapNearestFilter: wa,
            NearestMipMapLinearFilter: _a,
            LinearFilter: Ma,
            LinearMipMapNearestFilter: Ea,
            LinearMipMapLinearFilter: Ta
        };
    Object.assign(Mr.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getPoint(t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, n, r = [],
                i = this.getPoint(0),
                o = 0;
            for (r.push(0), n = 1; n <= e; n++) t = this.getPoint(n / e), o += t.distanceTo(i), r.push(o), i = t;
            return this.cacheArcLengths = r, r
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var n, r = this.getLengths(),
                i = 0,
                o = r.length;
            n = t || e * r[o - 1];
            for (var a, s = 0, c = o - 1; s <= c;)
                if (i = Math.floor(s + (c - s) / 2), (a = r[i] - n) < 0) s = i + 1;
                else {
                    if (!(a > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            if (i = c, r[i] === n) return i / (o - 1);
            var l = r[i];
            return (i + (n - l) / (r[i + 1] - l)) / (o - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4,
                n = e + 1e-4;
            t < 0 && (t = 0), n > 1 && (n = 1);
            var r = this.getPoint(t);
            return this.getPoint(n).clone().sub(r).normalize()
        },
        getTangentAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function(e, t) {
            var n, r, i, o = new h,
                a = [],
                s = [],
                c = [],
                l = new h,
                d = new u;
            for (n = 0; n <= e; n++) r = n / e, a[n] = this.getTangentAt(r), a[n].normalize();
            s[0] = new h, c[0] = new h;
            var p = Number.MAX_VALUE,
                f = Math.abs(a[0].x),
                m = Math.abs(a[0].y),
                g = Math.abs(a[0].z);
            for (f <= p && (p = f, o.set(1, 0, 0)), m <= p && (p = m, o.set(0, 1, 0)), g <= p && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), l.crossVectors(a[n - 1], a[n]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(Ms.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(d.makeRotationAxis(l, i))), c[n].crossVectors(a[n], s[n]);
            if (!0 === t)
                for (i = Math.acos(Ms.clamp(s[0].dot(s[e]), -1, 1)), i /= e, a[0].dot(l.crossVectors(s[0], s[e])) > 0 && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(d.makeRotationAxis(a[n], i * n)), c[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: c
            }
        }
    }), Er.prototype = Object.create(Mr.prototype), Er.prototype.constructor = Er, Er.prototype.isLineCurve = !0, Er.prototype.getPoint = function(e) {
        if (1 === e) return this.v2.clone();
        var t = this.v2.clone().sub(this.v1);
        return t.multiplyScalar(e).add(this.v1), t
    }, Er.prototype.getPointAt = function(e) {
        return this.getPoint(e)
    }, Er.prototype.getTangent = function(e) {
        return this.v2.clone().sub(this.v1).normalize()
    }, Tr.prototype = Object.assign(Object.create(Mr.prototype), {
        constructor: Tr,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Er(t, e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= t) {
                    var i = n[r] - t,
                        o = this.curves[r],
                        a = o.getLength(),
                        s = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(s)
                }
                r++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e, e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var o = i[r], a = o && o.isEllipseCurve ? 2 * e : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var l = s[c];
                    t && t.equals(l) || (n.push(l), t = l)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        createPointsGeometry: function(e) {
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            for (var t = new Pe, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.vertices.push(new h(i.x, i.y, i.z || 0))
            }
            return t
        }
    }), Sr.prototype = Object.create(Mr.prototype), Sr.prototype.constructor = Sr, Sr.prototype.isEllipseCurve = !0, Sr.prototype.getPoint = function(e) {
        for (var t = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, r = Math.abs(n) < Number.EPSILON; n < 0;) n += t;
        for (; n > t;) n -= t;
        n < Number.EPSILON && (n = r ? 0 : t), !0 !== this.aClockwise || r || (n === t ? n = -t : n -= t);
        var o = this.aStartAngle + e * n,
            a = this.aX + this.xRadius * Math.cos(o),
            s = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            var c = Math.cos(this.aRotation),
                l = Math.sin(this.aRotation),
                h = a - this.aX,
                u = s - this.aY;
            a = h * c - u * l + this.aX, s = h * l + u * c + this.aY
        }
        return new i(a, s)
    }, Ar.prototype = Object.create(Mr.prototype), Ar.prototype.constructor = Ar, Ar.prototype.isSplineCurve = !0, Ar.prototype.getPoint = function(e) {
        var t = this.points,
            n = (t.length - 1) * e,
            r = Math.floor(n),
            o = n - r,
            a = t[0 === r ? r : r - 1],
            s = t[r],
            c = t[r > t.length - 2 ? t.length - 1 : r + 1],
            l = t[r > t.length - 3 ? t.length - 1 : r + 2];
        return new i(pr(o, a.x, s.x, c.x, l.x), pr(o, a.y, s.y, c.y, l.y))
    }, Pr.prototype = Object.create(Mr.prototype), Pr.prototype.constructor = Pr, Pr.prototype.getPoint = function(e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2,
            o = this.v3;
        return new i(_r(e, t.x, n.x, r.x, o.x), _r(e, t.y, n.y, r.y, o.y))
    }, Cr.prototype = Object.create(Mr.prototype), Cr.prototype.constructor = Cr, Cr.prototype.getPoint = function(e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2;
        return new i(vr(e, t.x, n.x, r.x), vr(e, t.y, n.y, r.y))
    };
    var Ks = Object.assign(Object.create(Tr.prototype), {
        fromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var n = new Er(this.currentPoint.clone(), new i(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            var o = new Cr(this.currentPoint.clone(), new i(e, t), new i(n, r));
            this.curves.push(o), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(e, t, n, r, o, a) {
            var s = new Pr(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(o, a));
            this.curves.push(s), this.currentPoint.set(o, a)
        },
        splineThru: function(e) {
            var t = [this.currentPoint.clone()].concat(e),
                n = new Ar(t);
            this.curves.push(n), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, n, r, i, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            this.absarc(e + a, t + s, n, r, i, o)
        },
        absarc: function(e, t, n, r, i, o) {
            this.absellipse(e, t, n, n, r, i, o)
        },
        ellipse: function(e, t, n, r, i, o, a, s) {
            var c = this.currentPoint.x,
                l = this.currentPoint.y;
            this.absellipse(e + c, t + l, n, r, i, o, a, s)
        },
        absellipse: function(e, t, n, r, i, o, a, s) {
            var c = new Sr(e, t, n, r, i, o, a, s);
            if (this.curves.length > 0) {
                var l = c.getPoint(0);
                l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
            }
            this.curves.push(c);
            var h = c.getPoint(1);
            this.currentPoint.copy(h)
        }
    });
    Lr.prototype = Ks, Ks.constructor = Lr, Rr.prototype = Object.assign(Object.create(Ks), {
        constructor: Rr,
        getPointsHoles: function(e) {
            for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
            return t
        },
        extractAllPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        extractPoints: function(e) {
            return this.extractAllPoints(e)
        }
    }), Object.assign(Ir.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new Lr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            this.currentPath.quadraticCurveTo(e, t, n, r)
        },
        bezierCurveTo: function(e, t, n, r, i, o) {
            this.currentPath.bezierCurveTo(e, t, n, r, i, o)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function n(e) {
                for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n],
                        o = new Rr;
                    o.curves = i.curves, t.push(o)
                }
                return t
            }
            var r = js.isClockWise,
                i = this.subPaths;
            if (0 === i.length) return [];
            if (!0 === t) return n(i);
            var o, a, s, c = [];
            if (1 === i.length) return a = i[0], s = new Rr, s.curves = a.curves, c.push(s), c;
            var l = !r(i[0].getPoints());
            l = e ? !l : l;
            var h, u = [],
                d = [],
                p = [],
                f = 0;
            d[f] = void 0, p[f] = [];
            for (var m = 0, g = i.length; m < g; m++) a = i[m], h = a.getPoints(), o = r(h), o = e ? !o : o, o ? (!l && d[f] && f++, d[f] = {
                s: new Rr,
                p: h
            }, d[f].s.curves = a.curves, l && f++, p[f] = []) : p[f].push({
                h: a,
                p: h[0]
            });
            if (!d[0]) return n(i);
            if (d.length > 1) {
                for (var v = !1, y = [], b = 0, x = d.length; b < x; b++) u[b] = [];
                for (var b = 0, x = d.length; b < x; b++)
                    for (var w = p[b], _ = 0; _ < w.length; _++) {
                        for (var M = w[_], E = !0, T = 0; T < d.length; T++)(function(e, t) {
                            for (var n = t.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                                var a = t[i],
                                    s = t[o],
                                    c = s.x - a.x,
                                    l = s.y - a.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (a = t[o], c = -c, s = t[i], l = -l), e.y < a.y || e.y > s.y) continue;
                                    if (e.y === a.y) {
                                        if (e.x === a.x) return !0
                                    } else {
                                        var h = l * (e.x - a.x) - c * (e.y - a.y);
                                        if (0 === h) return !0;
                                        if (h < 0) continue;
                                        r = !r
                                    }
                                } else {
                                    if (e.y !== a.y) continue;
                                    if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                                }
                            }
                            return r
                        })(M.p, d[T].p) && (b !== T && y.push({
                            froms: b,
                            tos: T,
                            hole: _
                        }), E ? (E = !1, u[T].push(M)) : v = !0);
                        E && u[b].push(M)
                    }
                y.length > 0 && (v || (p = u))
            }
            for (var S, m = 0, A = d.length; m < A; m++) {
                s = d[m].s, c.push(s), S = p[m];
                for (var P = 0, C = S.length; P < C; P++) s.holes.push(S[P].h)
            }
            return c
        }
    }), Object.assign(Or.prototype, {
        isFont: !0,
        generateShapes: function(e, t, n) {
            function r(e, t, r, o) {
                var a = i.glyphs[e] || i.glyphs["?"];
                if (a) {
                    var s, c, l, h, u, d, p, f, m, g, v, y = new Ir,
                        b = [];
                    if (a.o)
                        for (var x = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), w = 0, _ = x.length; w < _;) {
                            var M = x[w++];
                            switch (M) {
                                case "m":
                                    s = x[w++] * t + r, c = x[w++] * t + o, y.moveTo(s, c);
                                    break;
                                case "l":
                                    s = x[w++] * t + r, c = x[w++] * t + o, y.lineTo(s, c);
                                    break;
                                case "q":
                                    if (l = x[w++] * t + r, h = x[w++] * t + o, p = x[w++] * t + r, f = x[w++] * t + o, y.quadraticCurveTo(p, f, l, h), v = b[b.length - 1]) {
                                        u = v.x, d = v.y;
                                        for (var E = 1; E <= n; E++) {
                                            var T = E / n;
                                            vr(T, u, p, l), vr(T, d, f, h)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (l = x[w++] * t + r, h = x[w++] * t + o, p = x[w++] * t + r, f = x[w++] * t + o, m = x[w++] * t + r, g = x[w++] * t + o, y.bezierCurveTo(p, f, m, g, l, h), v = b[b.length - 1]) {
                                        u = v.x, d = v.y;
                                        for (var E = 1; E <= n; E++) {
                                            var T = E / n;
                                            _r(T, u, p, m, l), _r(T, d, f, g, h)
                                        }
                                    }
                            }
                        }
                    return {
                        offsetX: a.ha * t,
                        path: y
                    }
                }
            }
            void 0 === t && (t = 100), void 0 === n && (n = 4);
            for (var i = this.data, o = function(e) {
                    for (var n = String(e).split(""), o = t / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * o, s = 0, c = 0, l = [], h = 0; h < n.length; h++) {
                        var u = n[h];
                        if ("\n" === u) s = 0, c -= a;
                        else {
                            var d = r(u, o, s, c);
                            s += d.offsetX, l.push(d.path)
                        }
                    }
                    return l
                }(e), a = [], s = 0, c = o.length; s < c; s++) Array.prototype.push.apply(a, o[s].toShapes());
            return a
        }
    }), Object.assign(kr.prototype, {
        load: function(e, t, n, r) {
            var i = this;
            new In(this.manager).load(e, function(e) {
                var n;
                try {
                    n = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
                }
                var r = i.parse(n);
                t && t(r)
            }, n, r)
        },
        parse: function(e) {
            return new Or(e)
        }
    });
    var Qs, ec = {
        getContext: function() {
            return void 0 === Qs && (Qs = new(window.AudioContext || window.webkitAudioContext)), Qs
        },
        setContext: function(e) {
            Qs = e
        }
    };
    Object.assign(Dr.prototype, {
            load: function(e, t, n, r) {
                var i = new In(this.manager);
                i.setResponseType("arraybuffer"), i.load(e, function(e) {
                    ec.getContext().decodeAudioData(e, function(e) {
                        t(e)
                    })
                }, n, r)
            }
        }), Object.assign(Nr.prototype, {
            update: function() {
                var e, t, n, r, i, o, a, s, c = new u,
                    l = new u;
                return function(h) {
                    if (e !== this || t !== h.focus || n !== h.fov || r !== h.aspect * this.aspect || i !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep) {
                        e = this, t = h.focus, n = h.fov, r = h.aspect * this.aspect, i = h.near, o = h.far, a = h.zoom;
                        var u = h.projectionMatrix.clone();
                        s = this.eyeSep / 2;
                        var d, p, f = s * i / t,
                            m = i * Math.tan(Ms.DEG2RAD * n * .5) / a;
                        l.elements[12] = -s, c.elements[12] = s, d = -m * r + f, p = m * r + f, u.elements[0] = 2 * i / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraL.projectionMatrix.copy(u), d = -m * r - f, p = m * r - f, u.elements[0] = 2 * i / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraR.projectionMatrix.copy(u)
                    }
                    this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c)
                }
            }()
        }), Br.prototype = Object.create(he.prototype), Br.prototype.constructor = Br, Ur.prototype = Object.assign(Object.create(Ne.prototype), {
            constructor: Ur,
            isArrayCamera: !0
        }), Fr.prototype = Object.assign(Object.create(he.prototype), {
            constructor: Fr,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(e) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(e) {
                this.gain.gain.value = e
            },
            updateMatrixWorld: function() {
                var e = new h,
                    t = new l,
                    n = new h,
                    r = new h;
                return function(i) {
                    he.prototype.updateMatrixWorld.call(this, i);
                    var o = this.context.listener,
                        a = this.up;
                    this.matrixWorld.decompose(e, t, n), r.set(0, 0, -1).applyQuaternion(t), o.positionX ? (o.positionX.setValueAtTime(e.x, this.context.currentTime), o.positionY.setValueAtTime(e.y, this.context.currentTime), o.positionZ.setValueAtTime(e.z, this.context.currentTime), o.forwardX.setValueAtTime(r.x, this.context.currentTime), o.forwardY.setValueAtTime(r.y, this.context.currentTime), o.forwardZ.setValueAtTime(r.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(e.x, e.y, e.z), o.setOrientation(r.x, r.y, r.z, a.x, a.y, a.z))
                }
            }()
        }), zr.prototype = Object.assign(Object.create(he.prototype), {
            constructor: zr,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            },
            setBuffer: function(e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                var e = this.context.createBufferSource();
                return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), e.start(0, this.startTime), this.isPlaying = !0, this.source = e, this.connect()
            },
            pause: function() {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this)
            },
            stop: function() {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this)
            },
            connect: function() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(e) {
                return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(e) {
                return this.setFilters(e ? [e] : [])
            },
            setPlaybackRate: function(e) {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this)
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(e) {
                return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this)
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(e) {
                return this.gain.gain.value = e, this
            }
        }), jr.prototype = Object.assign(Object.create(zr.prototype), {
            constructor: jr,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(e) {
                this.panner.refDistance = e
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(e) {
                this.panner.rolloffFactor = e
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(e) {
                this.panner.distanceModel = e
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(e) {
                this.panner.maxDistance = e
            },
            updateMatrixWorld: function() {
                var e = new h;
                return function(t) {
                    he.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
                }
            }()
        }), Object.assign(Hr.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                return e / t.length
            }
        }), Object.assign(Vr.prototype, {
            accumulate: function(e, t) {
                var n = this.buffer,
                    r = this.valueSize,
                    i = e * r + r,
                    o = this.cumulativeWeight;
                if (0 === o) {
                    for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                    o = t
                } else {
                    o += t;
                    var s = t / o;
                    this._mixBufferRegion(n, i, 0, s, r)
                }
                this.cumulativeWeight = o
            },
            apply: function(e) {
                var t = this.valueSize,
                    n = this.buffer,
                    r = e * t + t,
                    i = this.cumulativeWeight,
                    o = this.binding;
                if (this.cumulativeWeight = 0, i < 1) {
                    var a = 3 * t;
                    this._mixBufferRegion(n, r, a, 1 - i, t)
                }
                for (var s = t, c = t + t; s !== c; ++s)
                    if (n[s] !== n[s + t]) {
                        o.setValue(n, r);
                        break
                    }
            },
            saveOriginalState: function() {
                var e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    r = 3 * n;
                e.getValue(t, r);
                for (var i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            },
            _select: function(e, t, n, r, i) {
                if (r >= .5)
                    for (var o = 0; o !== i; ++o) e[t + o] = e[n + o]
            },
            _slerp: function(e, t, n, r) {
                l.slerpFlat(e, t, e, t, e, n, r)
            },
            _lerp: function(e, t, n, r, i) {
                for (var o = 1 - r, a = 0; a !== i; ++a) {
                    var s = t + a;
                    e[s] = e[s] * o + e[n + a] * r
                }
            }
        }), Object.assign(Gr.prototype, {
            getValue: function(e, t) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(e, t)
            },
            setValue: function(e, t) {
                for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
            },
            bind: function() {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            },
            unbind: function() {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }), Object.assign(Wr, {
            Composite: Gr,
            create: function(e, t, n) {
                return e && e.isAnimationObjectGroup ? new Wr.Composite(e, t, n) : new Wr(e, t, n)
            },
            parseTrackName: function() {
                var e = /((?:[\w-]+[\/:])*)/,
                    t = /([\w-\.]+)?/,
                    n = /(?:\.([\w-]+)(?:\[(.+)\])?)?/,
                    r = /\.([\w-]+)(?:\[(.+)\])?/,
                    i = new RegExp("^" + e.source + t.source + n.source + r.source + "$"),
                    o = ["material", "materials", "bones"];
                return function(e) {
                    var t = i.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    var n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var a = n.nodeName.substring(r + 1); - 1 !== o.indexOf(a) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = a)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
            }(),
            findNode: function(e, t) {
                if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    var n = function(e) {
                        for (var n = 0; n < e.bones.length; n++) {
                            var r = e.bones[n];
                            if (r.name === t) return r
                        }
                        return null
                    }(e.skeleton);
                    if (n) return n
                }
                if (e.children) {
                    var r = function(e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                if (i.name === t || i.uuid === t) return i;
                                var o = r(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        i = r(e.children);
                    if (i) return i
                }
                return null
            }
        }), Object.assign(Wr.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(e, t) {
                e[t] = this.node[this.propertyName]
            }, function(e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
            }, function(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }, function(e, t) {
                this.resolvedProperty.toArray(e, t)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(e, t) {
                    this.node[this.propertyName] = e[t]
                }, function(e, t) {
                    this.node[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.node[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }, function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }, function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }, function(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(e, t) {
                this.bind(), this.getValue(e, t)
            },
            setValue: function(e, t) {
                this.bind(), this.setValue(e, t)
            },
            bind: function() {
                var e = this.node,
                    t = this.parsedPath,
                    n = t.objectName,
                    r = t.propertyName,
                    i = t.propertyIndex;
                if (e || (e = Wr.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    var o = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("  can not bind to material as node does not have a material", this);
                            if (!e.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                            e = e.skeleton.bones;
                            for (var a = 0; a < e.length; a++)
                                if (e[a].name === o) {
                                    o = a;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === e[n]) return void console.error("  can not bind to objectName of node, undefined", this);
                            e = e[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === e[o]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, e);
                        e = e[o]
                    }
                }
                var s = e[r];
                if (void 0 === s) {
                    var c = t.nodeName;
                    return void console.error("  trying to update property for track: " + c + "." + r + " but it wasn't found.", e)
                }
                var l = this.Versioning.None;
                void 0 !== e.needsUpdate ? (l = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
                var h = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!e.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        if (!e.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                            if (e.geometry.morphTargets[a].name === i) {
                                i = a;
                                break
                            }
                    }
                    h = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][l]
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Wr.prototype, {
            _getValue_unbound: Wr.prototype.getValue,
            _setValue_unbound: Wr.prototype.setValue
        }), Object.assign($r.prototype, {
            isAnimationObjectGroup: !0,
            add: function(e) {
                for (var t = this._objects, n = t.length, r = this.nCachedObjects_, i = this._indicesByUUID, o = this._paths, a = this._parsedPaths, s = this._bindings, c = s.length, l = 0, h = arguments.length; l !== h; ++l) {
                    var u = arguments[l],
                        d = u.uuid,
                        p = i[d],
                        f = void 0;
                    if (void 0 === p) {
                        p = n++, i[d] = p, t.push(u);
                        for (var m = 0, g = c; m !== g; ++m) s[m].push(new Wr(u, o[m], a[m]))
                    } else if (p < r) {
                        f = t[p];
                        var v = --r,
                            y = t[v];
                        i[y.uuid] = p, t[p] = y, i[d] = v, t[v] = u;
                        for (var m = 0, g = c; m !== g; ++m) {
                            var b = s[m],
                                x = b[v],
                                w = b[p];
                            b[p] = x, void 0 === w && (w = new Wr(u, o[m], a[m])), b[v] = w
                        }
                    } else t[p] !== f && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = r
            },
            remove: function(e) {
                for (var t = this._objects, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var c = arguments[a],
                        l = c.uuid,
                        h = r[l];
                    if (void 0 !== h && h >= n) {
                        var u = n++,
                            d = t[u];
                        r[d.uuid] = h, t[h] = d, r[l] = u, t[u] = c;
                        for (var p = 0, f = o; p !== f; ++p) {
                            var m = i[p],
                                g = m[u],
                                v = m[h];
                            m[h] = g, m[u] = v
                        }
                    }
                }
                this.nCachedObjects_ = n
            },
            uncache: function(e) {
                for (var t = this._objects, n = t.length, r = this.nCachedObjects_, i = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, c = arguments.length; s !== c; ++s) {
                    var l = arguments[s],
                        h = l.uuid,
                        u = i[h];
                    if (void 0 !== u)
                        if (delete i[h], u < r) {
                            var d = --r,
                                p = t[d],
                                f = --n,
                                m = t[f];
                            i[p.uuid] = u, t[u] = p, i[m.uuid] = d, t[d] = m, t.pop();
                            for (var g = 0, v = a; g !== v; ++g) {
                                var y = o[g],
                                    b = y[d],
                                    x = y[f];
                                y[u] = b, y[d] = x, y.pop()
                            }
                        } else {
                            var f = --n,
                                m = t[f];
                            i[m.uuid] = u, t[u] = m, t.pop();
                            for (var g = 0, v = a; g !== v; ++g) {
                                var y = o[g];
                                y[u] = y[f], y.pop()
                            }
                        }
                }
                this.nCachedObjects_ = r
            },
            subscribe_: function(e, t) {
                var n = this._bindingsIndicesByPath,
                    r = n[e],
                    i = this._bindings;
                if (void 0 !== r) return i[r];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    c = s.length,
                    l = this.nCachedObjects_,
                    h = new Array(c);
                r = i.length, n[e] = r, o.push(e), a.push(t), i.push(h);
                for (var u = l, d = s.length; u !== d; ++u) {
                    var p = s[u];
                    h[u] = new Wr(p, e, t)
                }
                return h
            },
            unsubscribe_: function(e) {
                var t = this._bindingsIndicesByPath,
                    n = t[e];
                if (void 0 !== n) {
                    var r = this._paths,
                        i = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    t[e[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                }
            }
        }), Object.assign(Xr.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(e) {
                return this._startTime = e, this
            },
            setLoop: function(e, t) {
                return this.loop = e, this.repetitions = t, this
            },
            setEffectiveWeight: function(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(e) {
                return this._scheduleFading(e, 0, 1)
            },
            fadeOut: function(e) {
                return this._scheduleFading(e, 1, 0)
            },
            crossFadeFrom: function(e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    var r = this._clip.duration,
                        i = e._clip.duration,
                        o = i / r,
                        a = r / i;
                    e.warp(1, o, t), this.warp(a, 1, t)
                }
                return this
            },
            crossFadeTo: function(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            },
            stopFading: function() {
                var e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            setEffectiveTimeScale: function(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            },
            syncWith: function(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            },
            halt: function(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            },
            warp: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    c = o.sampleValues;
                return s[0] = i, s[1] = i + n, c[0] = e / a, c[1] = t / a, this
            },
            stopWarping: function() {
                var e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(e, t, n, r) {
                if (!this.enabled) return void this._updateWeight(e);
                var i = this._startTime;
                if (null !== i) {
                    var o = (e - i) * n;
                    if (o < 0 || 0 === n) return;
                    this._startTime = null, t = n * o
                }
                t *= this._updateTimeScale(e);
                var a = this._updateTime(t),
                    s = this._updateWeight(e);
                if (s > 0)
                    for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h) c[h].evaluate(a), l[h].accumulate(r, s)
            },
            _updateWeight: function(e) {
                var t = 0;
                if (this.enabled) {
                    t = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var r = n.evaluate(e)[0];
                        t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            },
            _updateTimeScale: function(e) {
                var t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) {
                        t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t, t
            },
            _updateTime: function(e) {
                var t = this.time + e;
                if (0 === e) return t;
                var n = this._clip.duration,
                    r = this.loop,
                    i = this._loopCount;
                if (r === ts) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (t >= n) t = n;
                        else {
                            if (!(t < 0)) break e;
                            t = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    var o = r === rs;
                    if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0) {
                        var a = Math.floor(t / n);
                        t -= n * a, i += Math.abs(a);
                        var s = this.repetitions - i;
                        if (s < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (0 === s) {
                                var c = e < 0;
                                this._setEndings(c, !c, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    }
                    if (o && 1 == (1 & i)) return this.time = t, n - t
                }
                return this.time = t, t
            },
            _setEndings: function(e, t, n) {
                var r = this._interpolantSettings;
                n ? (r.endingStart = cs, r.endingEnd = cs) : (r.endingStart = e ? this.zeroSlopeAtStart ? cs : ss : ls, r.endingEnd = t ? this.zeroSlopeAtEnd ? cs : ss : ls)
            },
            _scheduleFading: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
            }
        }), Object.assign(qr.prototype, r.prototype, {
            _bindAction: function(e, t) {
                var n = e._localRoot || this._root,
                    r = e._clip.tracks,
                    i = r.length,
                    o = e._propertyBindings,
                    a = e._interpolants,
                    s = n.uuid,
                    c = this._bindingsByRootAndName,
                    l = c[s];
                void 0 === l && (l = {}, c[s] = l);
                for (var h = 0; h !== i; ++h) {
                    var u = r[h],
                        d = u.name,
                        p = l[d];
                    if (void 0 !== p) o[h] = p;
                    else {
                        if (void 0 !== (p = o[h])) {
                            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                            continue
                        }
                        var f = t && t._propertyBindings[h].binding.parsedPath;
                        p = new Vr(Wr.create(n, d, f), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, d), o[h] = p
                    }
                    a[h].resultBuffer = p.buffer
                }
            },
            _activateAction: function(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        var t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                        var s = i[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            },
            _deactivateAction: function(e) {
                if (this._isActiveAction(e)) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                    }
                    this._takeBackAction(e)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var e = this;
                this.stats = {
                    actions: {get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(e) {
                var t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            },
            _addInactiveAction: function(e, t, n) {
                var r = this._actions,
                    i = this._actionsByClip,
                    o = i[t];
                if (void 0 === o) o = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, i[t] = o;
                else {
                    var a = o.knownActions;
                    e._byClipCacheIndex = a.length, a.push(e)
                }
                e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
            },
            _removeInactiveAction: function(e) {
                var t = this._actions,
                    n = t[t.length - 1],
                    r = e._cacheIndex;
                n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                var i = e._clip.uuid,
                    o = this._actionsByClip,
                    a = o[i],
                    s = a.knownActions,
                    c = s[s.length - 1],
                    l = e._byClipCacheIndex;
                c._byClipCacheIndex = l, s[l] = c, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
            },
            _removeInactiveBindingsForAction: function(e) {
                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                    var i = t[n];
                    0 == --i.referenceCount && this._removeInactiveBinding(i)
                }
            },
            _lendAction: function(e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = this._nActiveActions++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackAction: function(e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = --this._nActiveActions,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _addInactiveBinding: function(e, t, n) {
                var r = this._bindingsByRootAndName,
                    i = r[t],
                    o = this._bindings;
                void 0 === i && (i = {}, r[t] = i), i[n] = e, e._cacheIndex = o.length, o.push(e)
            },
            _removeInactiveBinding: function(e) {
                var t = this._bindings,
                    n = e.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    o = this._bindingsByRootAndName,
                    a = o[r],
                    s = t[t.length - 1],
                    c = e._cacheIndex;
                s._cacheIndex = c, t[c] = s, t.pop(), delete a[i];
                e: {
                    for (var l in a) break e;
                    delete o[r]
                }
            },
            _lendBinding: function(e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = this._nActiveBindings++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackBinding: function(e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = --this._nActiveBindings,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _lendControlInterpolant: function() {
                var e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++,
                    n = e[t];
                return void 0 === n && (n = new Zn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
            },
            _takeBackControlInterpolant: function(e) {
                var t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = t[r];
                e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? sr.findByName(n, e) : e,
                    o = null !== i ? i.uuid : e,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var c = a.actionByRoot[r];
                    if (void 0 !== c) return c;
                    s = a.knownActions[0], null === i && (i = s._clip)
                }
                if (null === i) return null;
                var l = new Xr(this, i, t);
                return this._bindAction(l, s), this._addInactiveAction(l, o, r), l
            },
            existingAction: function(e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? sr.findByName(n, e) : e,
                    o = i ? i.uuid : e,
                    a = this._actionsByClip[o];
                return void 0 !== a ? a.actionByRoot[r] || null : null
            },
            stopAllAction: function() {
                var e = this._actions,
                    t = this._nActiveActions,
                    n = this._bindings,
                    r = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var i = 0; i !== t; ++i) e[i].reset();
                for (var i = 0; i !== r; ++i) n[i].useCount = 0;
                return this
            },
            update: function(e) {
                e *= this.timeScale;
                for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                    t[a]._update(r, e, i, o)
                }
                for (var s = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a) s[a].apply(o);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(e) {
                var t = this._actions,
                    n = e.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var c = o[a];
                        this._deactivateAction(c);
                        var l = c._cacheIndex,
                            h = t[t.length - 1];
                        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, t[l] = h, t.pop(), this._removeInactiveBindingsForAction(c)
                    }
                    delete r[n]
                }
            },
            uncacheRoot: function(e) {
                var t = e.uuid,
                    n = this._actionsByClip;
                for (var r in n) {
                    var i = n[r].actionByRoot,
                        o = i[t];
                    void 0 !== o && (this._deactivateAction(o), this._removeInactiveAction(o))
                }
                var a = this._bindingsByRootAndName,
                    s = a[t];
                if (void 0 !== s)
                    for (var c in s) {
                        var l = s[c];
                        l.restoreOriginalState(), this._removeInactiveBinding(l)
                    }
            },
            uncacheAction: function(e, t) {
                var n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), Yr.prototype.clone = function() {
            return new Yr(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Zr.prototype = Object.assign(Object.create(Ce.prototype), {
            constructor: Zr,
            isInstancedBufferGeometry: !0,
            addGroup: function(e, t, n) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            },
            copy: function(e) {
                var t = e.index;
                null !== t && this.setIndex(t.clone());
                var n = e.attributes;
                for (var r in n) {
                    var i = n[r];
                    this.addAttribute(r, i.clone())
                }
                for (var o = e.groups, a = 0, s = o.length; a < s; a++) {
                    var c = o[a];
                    this.addGroup(c.start, c.count, c.materialIndex)
                }
                return this
            }
        }), Object.defineProperties(Jr.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(Jr.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(e, t) {
                return this.data.array[e * this.data.stride + this.offset] = t, this
            },
            setY: function(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 1] = t, this
            },
            setZ: function(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 2] = t, this
            },
            setW: function(e, t) {
                return this.data.array[e * this.data.stride + this.offset + 3] = t, this
            },
            getX: function(e) {
                return this.data.array[e * this.data.stride + this.offset]
            },
            getY: function(e) {
                return this.data.array[e * this.data.stride + this.offset + 1]
            },
            getZ: function(e) {
                return this.data.array[e * this.data.stride + this.offset + 2]
            },
            getW: function(e) {
                return this.data.array[e * this.data.stride + this.offset + 3]
            },
            setXY: function(e, t, n) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            },
            setXYZ: function(e, t, n, r) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
            },
            setXYZW: function(e, t, n, r, i) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
            }
        }), Object.defineProperty(Kr.prototype, "needsUpdate", {
            set: function(e) {
                !0 === e && this.version++
            }
        }), Object.assign(Kr.prototype, {
            isInterleavedBuffer: !0,
            setArray: function(e) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e
            },
            setDynamic: function(e) {
                return this.dynamic = e, this
            },
            copy: function(e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
            },
            copyAt: function(e, t, n) {
                e *= this.stride, n *= t.stride;
                for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                return this
            },
            set: function(e, t) {
                return void 0 === t && (t = 0), this.array.set(e, t), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(e) {
                return this.onUploadCallback = e, this
            }
        }), Qr.prototype = Object.assign(Object.create(Kr.prototype), {
            constructor: Qr,
            isInstancedInterleavedBuffer: !0,
            copy: function(e) {
                return Kr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }
        }), ei.prototype = Object.assign(Object.create(me.prototype), {
            constructor: ei,
            isInstancedBufferAttribute: !0,
            copy: function(e) {
                return me.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }
        }), Object.assign(ti.prototype, {
            linePrecision: 1,
            set: function(e, t) {
                this.ray.set(e, t)
            },
            setFromCamera: function(e, t) {
                t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(e, t) {
                var n = [];
                return ri(e, this, n, t), n.sort(ni), n
            },
            intersectObjects: function(e, t) {
                var n = [];
                if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                for (var r = 0, i = e.length; r < i; r++) ri(e[r], this, n, t);
                return n.sort(ni), n
            }
        }), Object.assign(ii.prototype, {
            start: function() {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var t = ("undefined" == typeof performance ? Date : performance).now();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        }), Object.assign(oi.prototype, {
            set: function(e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(e) {
                return this.radius = e.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(Ms.clamp(e.y / this.radius, -1, 1))), this
            }
        }), Object.assign(ai.prototype, {
            set: function(e, t, n) {
                return this.radius = e, this.theta = t, this.y = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(e) {
                return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
            },
            setFromVector3: function(e) {
                return this.radius = Math.sqrt(e.x * e.x + e.z * e.z), this.theta = Math.atan2(e.x, e.z), this.y = e.y, this
            }
        }), si.prototype = Object.create(Le.prototype), si.prototype.constructor = si, si.prototype.createAnimation = function(e, t, n, r) {
            var i = {
                start: t,
                end: n,
                length: n - t + 1,
                fps: r,
                duration: (n - t) / r,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            };
            this.animationsMap[e] = i, this.animationsList.push(i)
        }, si.prototype.autoCreateAnimations = function(e) {
            for (var t, n = /([a-z]+)_?(\d+)/i, r = {}, i = this.geometry, o = 0, a = i.morphTargets.length; o < a; o++) {
                var s = i.morphTargets[o],
                    c = s.name.match(n);
                if (c && c.length > 1) {
                    var l = c[1];
                    r[l] || (r[l] = {
                        start: 1 / 0,
                        end: -1 / 0
                    });
                    var h = r[l];
                    o < h.start && (h.start = o), o > h.end && (h.end = o), t || (t = l)
                }
            }
            for (var l in r) {
                var h = r[l];
                this.createAnimation(l, h.start, h.end, e)
            }
            this.firstAnimation = t
        }, si.prototype.setAnimationDirectionForward = function(e) {
            var t = this.animationsMap[e];
            t && (t.direction = 1, t.directionBackwards = !1)
        }, si.prototype.setAnimationDirectionBackward = function(e) {
            var t = this.animationsMap[e];
            t && (t.direction = -1, t.directionBackwards = !0)
        }, si.prototype.setAnimationFPS = function(e, t) {
            var n = this.animationsMap[e];
            n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
        }, si.prototype.setAnimationDuration = function(e, t) {
            var n = this.animationsMap[e];
            n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
        }, si.prototype.setAnimationWeight = function(e, t) {
            var n = this.animationsMap[e];
            n && (n.weight = t)
        }, si.prototype.setAnimationTime = function(e, t) {
            var n = this.animationsMap[e];
            n && (n.time = t)
        }, si.prototype.getAnimationTime = function(e) {
            var t = 0,
                n = this.animationsMap[e];
            return n && (t = n.time), t
        }, si.prototype.getAnimationDuration = function(e) {
            var t = -1,
                n = this.animationsMap[e];
            return n && (t = n.duration), t
        }, si.prototype.playAnimation = function(e) {
            var t = this.animationsMap[e];
            t ? (t.time = 0, t.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
        }, si.prototype.stopAnimation = function(e) {
            var t = this.animationsMap[e];
            t && (t.active = !1)
        }, si.prototype.update = function(e) {
            for (var t = 0, n = this.animationsList.length; t < n; t++) {
                var r = this.animationsList[t];
                if (r.active) {
                    var i = r.duration / r.length;
                    r.time += r.direction * e, r.mirroredLoop ? (r.time > r.duration || r.time < 0) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), r.time < 0 && (r.time = 0, r.directionBackwards = !1)) : (r.time = r.time % r.duration, r.time < 0 && (r.time += r.duration));
                    var o = r.start + Ms.clamp(Math.floor(r.time / i), 0, r.length - 1),
                        a = r.weight;
                    o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, r.lastFrame = r.currentFrame, r.currentFrame = o);
                    var s = r.time % i / i;
                    r.directionBackwards && (s = 1 - s), r.currentFrame !== r.lastFrame ? (this.morphTargetInfluences[r.currentFrame] = s * a, this.morphTargetInfluences[r.lastFrame] = (1 - s) * a) : this.morphTargetInfluences[r.currentFrame] = a
                }
            }
        }, ci.prototype = Object.create(he.prototype), ci.prototype.constructor = ci, ci.prototype.isImmediateRenderObject = !0, li.prototype = Object.create(Pt.prototype), li.prototype.constructor = li, li.prototype.update = function() {
            var e = new h,
                t = new h,
                n = new re;
            return function() {
                var r = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                var i = this.object.matrixWorld,
                    o = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var s = a.vertices, c = a.faces, l = 0, h = 0, u = c.length; h < u; h++)
                        for (var d = c[h], p = 0, f = d.vertexNormals.length; p < f; p++) {
                            var m = s[d[r[p]]],
                                g = d.vertexNormals[p];
                            e.copy(m).applyMatrix4(i), t.copy(g).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(l, e.x, e.y, e.z), l += 1, o.setXYZ(l, t.x, t.y, t.z), l += 1
                        } else if (a && a.isBufferGeometry)
                            for (var v = a.attributes.position, y = a.attributes.normal, l = 0, p = 0, f = v.count; p < f; p++) e.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(i), t.set(y.getX(p), y.getY(p), y.getZ(p)), t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), o.setXYZ(l, e.x, e.y, e.z), l += 1, o.setXYZ(l, t.x, t.y, t.z), l += 1;
                o.needsUpdate = !0
            }
        }(), hi.prototype = Object.create(he.prototype), hi.prototype.constructor = hi, hi.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, hi.prototype.update = function() {
            var e = new h,
                t = new h;
            return function() {
                var n = this.light.distance ? this.light.distance : 1e3,
                    r = n * Math.tan(this.light.angle);
                this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color)
            }
        }(), ui.prototype = Object.create(Pt.prototype), ui.prototype.constructor = ui, ui.prototype.getBoneList = function(e) {
            var t = [];
            e && e.isBone && t.push(e);
            for (var n = 0; n < e.children.length; n++) t.push.apply(t, this.getBoneList(e.children[n]));
            return t
        }, ui.prototype.update = function() {
            var e = new h,
                t = new u,
                n = new u;
            return function() {
                var r = this.geometry,
                    i = r.getAttribute("position");
                n.getInverse(this.root.matrixWorld);
                for (var o = 0, a = 0; o < this.bones.length; o++) {
                    var s = this.bones[o];
                    s.parent && s.parent.isBone && (t.multiplyMatrices(n, s.matrixWorld), e.setFromMatrixPosition(t), i.setXYZ(a, e.x, e.y, e.z), t.multiplyMatrices(n, s.parent.matrixWorld), e.setFromMatrixPosition(t), i.setXYZ(a + 1, e.x, e.y, e.z), a += 2)
                }
                r.getAttribute("position").needsUpdate = !0
            }
        }(), di.prototype = Object.create(Le.prototype), di.prototype.constructor = di, di.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, di.prototype.update = function() {
            this.material.color.copy(this.light.color)
        }, pi.prototype = Object.create(he.prototype), pi.prototype.constructor = pi, pi.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, pi.prototype.update = function() {
            var e = this.children[0];
            e.material.color.copy(this.light.color);
            var t = .5 * this.light.width,
                n = .5 * this.light.height,
                r = e.geometry.attributes.position,
                i = r.array;
            i[0] = t, i[1] = -n, i[2] = 0, i[3] = t, i[4] = n, i[5] = 0, i[6] = -t, i[7] = n, i[8] = 0, i[9] = -t, i[10] = -n, i[11] = 0, i[12] = t, i[13] = -n, i[14] = 0, r.needsUpdate = !0
        }, fi.prototype = Object.create(he.prototype), fi.prototype.constructor = fi, fi.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, fi.prototype.update = function() {
            var e = new h,
                t = new q,
                n = new q;
            return function() {
                var r = this.children[0],
                    i = r.geometry.getAttribute("color");
                t.copy(this.light.color), n.copy(this.light.groundColor);
                for (var o = 0, a = i.count; o < a; o++) {
                    var s = o < a / 2 ? t : n;
                    i.setXYZ(o, s.r, s.g, s.b)
                }
                r.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), i.needsUpdate = !0
            }
        }(), mi.prototype = Object.create(Pt.prototype), mi.prototype.constructor = mi, gi.prototype = Object.create(Pt.prototype), gi.prototype.constructor = gi, vi.prototype = Object.create(Pt.prototype), vi.prototype.constructor = vi, vi.prototype.update = function() {
            var e = new h,
                t = new h,
                n = new re;
            return function() {
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                for (var r = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, h = s.length; l < h; l++) {
                    var u = s[l],
                        d = u.normal;
                    e.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(r), t.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), i.setXYZ(c, e.x, e.y, e.z), c += 1, i.setXYZ(c, t.x, t.y, t.z), c += 1
                }
                i.needsUpdate = !0
            }
        }(), yi.prototype = Object.create(he.prototype), yi.prototype.constructor = yi, yi.prototype.dispose = function() {
            var e = this.children[0],
                t = this.children[1];
            e.geometry.dispose(), e.material.dispose(), t.geometry.dispose(), t.material.dispose()
        }, yi.prototype.update = function() {
            var e = new h,
                t = new h,
                n = new h;
            return function() {
                e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e);
                var r = this.children[0],
                    i = this.children[1];
                r.lookAt(n), r.material.color.copy(this.light.color), i.lookAt(n), i.scale.z = n.length()
            }
        }(), bi.prototype = Object.create(Pt.prototype), bi.prototype.constructor = bi, bi.prototype.update = function() {
            function e(e, o, a, s) {
                r.set(o, a, s).unproject(i);
                var c = n[e];
                if (void 0 !== c)
                    for (var l = t.getAttribute("position"), h = 0, u = c.length; h < u; h++) l.setXYZ(c[h], r.x, r.y, r.z)
            }
            var t, n, r = new h,
                i = new De;
            return function() {
                t = this.geometry, n = this.pointMap;
                i.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            }
        }(), xi.prototype = Object.create(Pt.prototype), xi.prototype.constructor = xi, xi.prototype.update = function() {
            var e = new te;
            return function(t) {
                if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                    var n = e.min,
                        r = e.max,
                        i = this.geometry.attributes.position,
                        o = i.array;
                    o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = n.x, o[4] = r.y, o[5] = r.z, o[6] = n.x, o[7] = n.y, o[8] = r.z, o[9] = r.x, o[10] = n.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = n.z, o[15] = n.x, o[16] = r.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = r.x, o[22] = n.y, o[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), xi.prototype.setFromObject = function(e) {
            return this.object = e, this.update(), this
        };
    var tc, nc;
    wi.prototype = Object.create(he.prototype), wi.prototype.constructor = wi, wi.prototype.setDirection = function() {
        var e, t = new h;
        return function(n) {
            n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), wi.prototype.setLength = function(e, t, n) {
        void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
    }, wi.prototype.setColor = function(e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, _i.prototype = Object.create(Pt.prototype), _i.prototype.constructor = _i;
    var rc = new h,
        ic = new Mi,
        oc = new Mi,
        ac = new Mi;
    Ei.prototype = Object.create(Mr.prototype), Ei.prototype.constructor = Ei, Ei.prototype.getPoint = function(e) {
        var t = this.points,
            n = t.length;
        n < 2 && console.log("duh, you need at least 2 points");
        var r = (n - (this.closed ? 0 : 1)) * e,
            i = Math.floor(r),
            o = r - i;
        this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / t.length) + 1) * t.length : 0 === o && i === n - 1 && (i = n - 2, o = 1);
        var a, s, c, l;
        if (this.closed || i > 0 ? a = t[(i - 1) % n] : (rc.subVectors(t[0], t[1]).add(t[0]), a = rc), s = t[i % n], c = t[(i + 1) % n], this.closed || i + 2 < n ? l = t[(i + 2) % n] : (rc.subVectors(t[n - 1], t[n - 2]).add(t[n - 1]), l = rc), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var u = "chordal" === this.type ? .5 : .25,
                d = Math.pow(a.distanceToSquared(s), u),
                p = Math.pow(s.distanceToSquared(c), u),
                f = Math.pow(c.distanceToSquared(l), u);
            p < 1e-4 && (p = 1), d < 1e-4 && (d = p), f < 1e-4 && (f = p), ic.initNonuniformCatmullRom(a.x, s.x, c.x, l.x, d, p, f), oc.initNonuniformCatmullRom(a.y, s.y, c.y, l.y, d, p, f), ac.initNonuniformCatmullRom(a.z, s.z, c.z, l.z, d, p, f)
        } else if ("catmullrom" === this.type) {
            var m = void 0 !== this.tension ? this.tension : .5;
            ic.initCatmullRom(a.x, s.x, c.x, l.x, m), oc.initCatmullRom(a.y, s.y, c.y, l.y, m), ac.initCatmullRom(a.z, s.z, c.z, l.z, m)
        }
        return new h(ic.calc(o), oc.calc(o), ac.calc(o))
    }, Ti.prototype = Object.create(Mr.prototype), Ti.prototype.constructor = Ti, Ti.prototype.getPoint = function(e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2,
            i = this.v3;
        return new h(_r(e, t.x, n.x, r.x, i.x), _r(e, t.y, n.y, r.y, i.y), _r(e, t.z, n.z, r.z, i.z))
    }, Si.prototype = Object.create(Mr.prototype), Si.prototype.constructor = Si, Si.prototype.getPoint = function(e) {
        var t = this.v0,
            n = this.v1,
            r = this.v2;
        return new h(vr(e, t.x, n.x, r.x), vr(e, t.y, n.y, r.y), vr(e, t.z, n.z, r.z))
    }, Ai.prototype = Object.create(Mr.prototype), Ai.prototype.constructor = Ai, Ai.prototype.getPoint = function(e) {
        if (1 === e) return this.v2.clone();
        var t = new h;
        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
    }, Pi.prototype = Object.create(Sr.prototype), Pi.prototype.constructor = Pi;
    var sc = {
            createMultiMaterialObject: function(e, t) {
                for (var n = new It, r = 0, i = t.length; r < i; r++) n.add(new Le(e, t[r]));
                return n
            },
            detach: function(e, t, n) {
                e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
            },
            attach: function(e, t, n) {
                var r = new u;
                r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e)
            }
        },
        cc = 0,
        lc = 1;
    Mr.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Mr.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Yi.prototype = Object.create(Ei.prototype), Zi.prototype = Object.create(Ei.prototype), Ji.prototype = Object.create(Ei.prototype), Object.assign(Ji.prototype, {
        initFromArray: function(e) {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function(e) {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function(e) {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), mi.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Object.assign(Y.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(te.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), ue.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Ms.random16 = function() {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
    }, Object.assign(re.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
        },
        applyToBuffer: function(e, t, n) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function(e, t, n) {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(u.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new h), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e, t, n) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function(e, t, n) {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, n, r, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, o)
        }
    }), ie.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, l.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(se.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(Rr.prototype, {
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new nn(this, e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new pn(this, e)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function(e, t, n) {
            return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        }
    }), Object.assign(h.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, n) {
            return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        }
    }), Object.assign(a.prototype, {
        fromAttribute: function(e, t, n) {
            return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        }
    }), Pe.prototype.computeTangents = function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.")
    }, Object.assign(he.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        }
    }), Object.defineProperties(he.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(_t.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Mt.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(Mr.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), Ne.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Un.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(me.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }
    }), Object.assign(Ce.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function(e, t, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(Ce.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Yr.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(K.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new q
            }
        }
    }), Object.defineProperties(Sn.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(Q.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(mt.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    }), Object.defineProperties(mt.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = e
            }
        }
    }), Object.defineProperties(ae.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? lo : co
            },
            set: function(e) {
                var t = e !== co;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + t + "."), this.renderReverseSided = t
            }
        }
    }), Object.defineProperties(s.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), zr.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new Dr).load(e, function(e) {
            t.setBuffer(e)
        }), this
    }, Hr.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    };
    var hc = {
            merge: function(e, t, n) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var r;
                t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
            },
            center: function(e) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
            }
        },
        uc = {
            crossOrigin: void 0,
            loadTexture: function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var i = new Bn;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            },
            loadTextureCube: function(e, t, n, r) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var i = new Nn;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(e, n, void 0, r);
                return t && (o.mapping = t), o
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        }
}, , function(e, t, n) {
    "use strict";

    function r(e) {
        return e.match(/(^(https?\:\/)?\/)/) ? e : contentRoute + e
    }
    t.c = r, n.d(t, "a", function() {
        return d
    }), n.d(t, "b", function() {
        return p
    });
    var i = n(0),
        o = n(16),
        a = n(4),
        s = n(17),
        c = n(23),
        l = n(9),
        h = n(18),
        u = a.a.Builder,
        d = function() {
            function e(e, t) {
                var n = window;
                this.language = n.language, this.newUrl = n.newUrl, this.isLoggedIn = n.isLoggedIn, this.serverParameters = t || n.serverParameters, this.loginUrl = n.loginUrl, this.logoUrl = n.logoUrl, this.config = e
            }
            return e
        }(),
        p = function() {
            function e() {
                var e = new o.a;
                this.materials = e;
                var t = new s.a,
                    n = new u(10, e),
                    r = new c.a(n, t);
                this.renderer = r, this.env = this.renderer.env;
                var a = new l.a.Intersector(r.camera),
                    d = new h.a.Builder(8, e);
                this.newBuilder = d, window.newBuilder = d;
                var p = new l.a.DnDBehavior(a);
                this.dragNDrop = p;
                var f = (p.addEventListeners(r.domElement, r.controls), new i.Object3D),
                    m = function(e) {
                        return f.visible = !1
                    },
                    g = function(e) {
                        return f.visible = !0
                    },
                    v = this.env.scene.getObjectByName("sun"),
                    y = v.clone();
                y.position.negate(), y.position.y *= -1, y.intensity /= 4, y.castShadow = !1;
                var b = new i.AmbientLight(16777215, .3);
                b.name = "ambient", this.env.scene.add(y), this.env.scene.add(b);
                this.env;
                this.attachComponent = function() {
                    var e = new i.Object3D;
                    e.name = "front Object", e.add(v.clone()), e.add(y.clone()), e.add(b.clone()), r.setForeGroundScene(e), r.domElement.addEventListener("mousedown", m), r.domElement.addEventListener("mouseup", g), window.renderer = r
                }, this.detachComponent = function() {
                    r.domElement.removeEventListener("mousedown", m), r.domElement.removeEventListener("mouseup", g), r.clearAnimations()
                }, this.updateDraggableElements = function(e) {
                    for (; f.children.length;) f.remove(f.children[0]);
                    e.forEach(function(e, t) {
                        f.add(e.intersectable.object)
                    }), p.draggables = e
                }
            }
            return e
        }()
}, , function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(2),
        o = n(0),
        a = n(21),
        s = (n.n(a), n(22)),
        c = (n.n(s), n(11));
    n.n(c);
    ! function(e) {
        var t = function() {
            function e(e) {
                this.forRange = e || function(e, t) {
                    return [e, t]
                }
            }
            return e.prototype.withCount = function(t) {
                return new e(function(e, n) {
                    var r = [],
                        i = n - e;
                    r.push(e);
                    for (var o = 1; o < t - 1; o++) r.push(o * i / (t - 1) + e);
                    return r.push(n), r
                })
            }, e.prototype.withFunction = function(t) {
                return new e(t)
            }, e.prototype.withMaxWidth = function(t) {
                var n = this;
                return new e(function(e, r) {
                    if (e > r) return n.forRange(r, e).reverse();
                    for (var i = r - e, o = Math.ceil(i / t), a = i / o, s = [e]; o-- > 0;) s.push(r - a * o);
                    return s
                })
            }, e.prototype.withoutBorders = function() {
                var t = this;
                return new e(function(e, n) {
                    var r = t.forRange(e, n);
                    return r.shift(), r.pop(), r
                })
            }, e
        }();
        e.IntervalBuilder = t;
        var n = function() {
            function e(e, n) {
                this.thickness = 8, this.default = {
                    beamShape: [new o.Vector3(-8, -8, 0), new o.Vector3(-6, -10, 0), new o.Vector3(6, -10, 0), new o.Vector3(8, -8, 0), new o.Vector3(8, 6, 0), new o.Vector3(6, 8, 0), new o.Vector3(-6, 8, 0), new o.Vector3(-8, 6, 0), new o.Vector3(-8, -8, 0)].map(function(e) {
                        return e.divideScalar(1.5)
                    }),
                    windowBeamShape: [new o.Vector3(-6, 0, 0), new o.Vector3(-7, 1, 0), new o.Vector3(-7, 4, 0), new o.Vector3(-6, 5, 0), new o.Vector3(0, 5, 0), new o.Vector3(0, 0, 0), new o.Vector3(-6, 0, 0)].reverse(),
                    beamIntervalBuilder: (new t).withMaxWidth(60).withoutBorders()
                }, this.thickness = e || 8, this.materials = n
            }
            return e.prototype.xyVerticesFromArray = function(e) {
                for (var t = [], n = 0; n < e.length; n += 2) t.push(new o.Vector3(e[n], e[n + 1], 0));
                return t
            }, e.prototype.xyzVerticesFromArray = function(e) {
                for (var t = [], n = 0; n < e.length; n += 3) t.push((new o.Vector3).fromArray(e, n));
                return t
            }, e.prototype.xyRectVerts = function(e, t, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = !1);
                var i = e / 2,
                    o = t / 2;
                n = n || 0;
                var a = this.xyzVerticesFromArray([-i, -o, n, i, -o, n, i, o, n, -i, o, n]);
                return r && a.push(a[0]), a
            }, e.prototype.bevelXYVectorArray = function(e, t) {
                if (e.length < 1) return e;
                var n = e[0],
                    r = e[e.length - 1],
                    i = n.x === r.x && n.y === r.y && n.z === r.z,
                    o = e.slice(0);
                o.push(e[0]);
                var a = e.reduce(function(n, r, i) {
                    if (i === e.length - 1) return n;
                    var a = o[i + 1],
                        s = a.clone().sub(r).normalize().multiplyScalar(t);
                    return n.concat([r.clone().add(s), a.clone().sub(s)])
                }, []);
                return i && a.push(a[0]), a
            }, e.prototype.xyFrame = function(e, t, n, r, i) {
                var o = this.xyRectVerts(n, r);
                return this.beamsAroundPoly(e, t, o, i)
            }, e.prototype.xyPanel = function(e, t, n, r) {
                var i = this.xyRectVerts(n, r),
                    a = this.polygonGeometry(i),
                    s = new o.Mesh(a, t);
                return s.name = e, s
            }, e.prototype.xyFramedPanel = function(e, t, n, r, i, o) {
                return this.compose(e, [
                    [this.xyFrame("frame " + e, t, r, i, o)],
                    [this.xyPanel("panel " + e, n, r, i)]
                ])
            }, e.prototype.placeholder = function(e) {
                var t = new o.Object3D;
                return t.name = e, t
            }, e.prototype.loadSprite = function(e, t, n, r, i) {
                var a = new o.TextureLoader,
                    s = this.placeholder("placeholder " + e);
                a.setCrossOrigin("");
                var c = new o.SpriteMaterial({
                    map: a.load(t, function(t) {
                        var a = t.image.width,
                            l = t.image.height,
                            h = n / a,
                            u = r / l;
                        u < h && (h = u), a *= h, l *= h;
                        var d = new o.Sprite(c);
                        d.scale.set(a, l, 1), d.name = e, s.add(d), i && i(s)
                    }),
                    transparent: !0
                });
                return s
            }, e.prototype.loadMesh = function(e, t, n) {
                var r = this.placeholder(e);
                t = Object(i.c)(t);
                var a = t.match(/(^.*\/)([^\.]+)\.(\w+)$/),
                    s = (a[0], a[1]),
                    c = a[2];
                switch (a[3]) {
                    case "dae":
                        (new o.ColladaLoader).load(t, function(e) {
                            e.scene = e.scene, r.add(e.scene), n && n(e.scene, e)
                        }.bind(this));
                        break;
                    case "obj":
                        (new o.OBJLoader).load(t, function(e) {
                            r.add(e), n && n(e, e)
                        }.bind(this));
                        break;
                    case "mtl":
                        var l = new o.MTLLoader;
                        l.setPath(s), l.load(c + ".mtl", function(e) {
                            e.preload();
                            var t = new o.OBJLoader;
                            t.setMaterials(e), t.setPath(s), t.load(c + ".obj", function(e) {
                                r.add(e), n && n(e, e)
                            })
                        }, function() {}, function(e) {
                            throw e
                        });
                        break;
                    default:
                        throw "No loader implemented for '" + t + "'."
                }
                return r
            }, e.prototype.horizontalPlane = function(e, t, n, r) {
                var i = new o.PlaneBufferGeometry(n, r),
                    a = new o.Mesh(i, t);
                a.rotation.x = Math.PI / 2;
                var s = a.clone();
                return s.rotation.x = -Math.PI / 2, this.compose(e, [
                    [a, 0, 0, 0],
                    [s, 0, 0, 0]
                ])
            }, e.prototype.sphere = function(e, t, n) {
                n = n || 1e3;
                var r = new o.SphereGeometry(n, 50, 50),
                    i = new o.Mesh(r, t);
                return i.position.set(0, 0, 0), i.name = e, i
            }, e.prototype.box = function(e, t, n, r, i) {
                if (isNaN(n) || isNaN(r) || isNaN(i)) throw "Invalid parameters for box";
                var a = new o.BoxGeometry(n, r, i),
                    s = new o.Mesh(a, t);
                return s.position.set(0, 0, 0), s.name = e, s
            }, e.prototype.frontBackBox = function(e, t, n, r, i, o) {
                var a = this.box(e + " front", t, r, i, o / 2),
                    s = a.clone();
                return s.name = e + " back", s.material = n, this.compose(e, [
                    [a, 0, 0, o / 2],
                    [s, 0, 0, -o / 2]
                ])
            }, e.prototype.beamInWidth = function(e, t, n) {
                return this.box(e, t, n, this.thickness, this.thickness)
            }, e.prototype.beamInHeight = function(e, t, n) {
                return this.box(e, t, this.thickness, n, this.thickness)
            }, e.prototype.beamInDepth = function(e, t, n) {
                return this.box(e, t, this.thickness, this.thickness, n)
            }, e.prototype.polygonMatrixforYPlane = function(e, t) {
                var n = e.map(function(t, n) {
                        return {
                            v1: t,
                            v2: e[(n + 1) % e.length]
                        }
                    }),
                    r = n[t],
                    i = r.v2.clone().sub(r.v1).normalize(),
                    a = function() {
                        var t = e[1].clone(),
                            n = e[0].clone().sub(t).normalize(),
                            r = e[2].clone().sub(t).normalize().negate();
                        return n.cross(r)
                    }(),
                    s = i.clone().cross(a).normalize(),
                    c = e[t],
                    l = (new o.Matrix4).makeBasis(s, i, a).setPosition(c),
                    h = (new o.Matrix4).makeRotationFromEuler(new o.Euler(0, Math.PI / 2, Math.PI / 2));
                return l.multiply(h)
            }, e.prototype.beamsAroundPoly = function(e, t, n, r) {
                var i = this.polygonMatrixforYPlane(n, 0),
                    a = (new o.Matrix4).getInverse(i),
                    s = n.map(function(e) {
                        return e.clone().applyMatrix4(a)
                    }),
                    c = this.extrudeShapeOnYPlane(e, t, r, s, !1);
                c.applyMatrix(i);
                var l = new o.Object3D;
                return l.add(c), l.name = "rotated " + e, l
            }, e.prototype.polygonGeometry = function(e, t) {
                if (e = e.filter(function(t, n) {
                        return 0 === n || !t.equals(e[n - 1])
                    }), e.length < 3) return t || new o.Geometry;
                var n = this.polygonMatrixforYPlane(e, 0),
                    r = new o.Euler(-Math.PI / 2, 0, 0),
                    i = (new o.Matrix4).makeRotationFromEuler(r);
                if (n.multiply(i), 0 === n.determinant()) return t || new o.Geometry;
                var a = (new o.Matrix4).getInverse(n),
                    s = e.map(function(e) {
                        var t = e.clone().applyMatrix4(a);
                        return new o.Vector2(t.x, t.y)
                    });
                if (s = this.simplifyVerts(s), !s.length) return t || new o.Geometry;
                var c = new o.Shape(s),
                    l = new o.ShapeGeometry(c);
                return l.applyMatrix(n), t ? t.merge(l, void 0) : t = l, t
            }, e.prototype.beamsToLastPointOverTriangle = function(e, t, n, r, i, a, s) {
                var c = r.clone().sub(n),
                    l = c.length();
                c.normalize();
                var h = new o.Vector3(0, 1, 0),
                    u = a.forRange(0, l).map(function(e) {
                        var t = c.clone().multiplyScalar(e).add(n),
                            r = i.clone().sub(t).normalize(),
                            o = r.clone().cross(h),
                            a = o.cross(r);
                        return {
                            v1: t,
                            v2: i,
                            v1Normal: a,
                            v2Normal: a
                        }
                    });
                return this.extrudeEdges(e, t, u, s)
            }, e.prototype.parallelBeamsOverPoly = function(e, t, n, r, i, a) {
                function s(e, t) {
                    return (e + t + h.length) % h.length
                }
                for (var c = this.polygonMatrixforYPlane(n, r), l = (new o.Matrix4).getInverse(c), h = n.map(function(e) {
                        return e.clone().applyMatrix4(l)
                    }), u = h.reduce(function(e, t, n) {
                        var r = h[e.left].x < t.x ? e.left : n,
                            i = h[e.right].x > t.x ? e.right : n;
                        return {
                            left: r,
                            right: i,
                            leftX: h[r].x,
                            rightX: h[i].x
                        }
                    }, {
                        left: 0,
                        right: 0,
                        leftX: 0,
                        rightX: 0
                    }), d = u.left, p = u.left, f = [], m = i.forRange(0, u.rightX - u.leftX), g = function(e, t, n) {
                        var r = s(e, t);
                        if (h[e].x > h[r].x) return g(e, -t, n);
                        for (var i = h.length; i-- > 0 && (h[e].x > n || h[r].x < n);) e = r, r = s(e, t);
                        var o = h[e],
                            a = h[r],
                            c = n - o.x,
                            l = a.x - o.x;
                        return l = 0 !== l ? l : 1, {
                            index: e,
                            v: o.clone().lerp(a, c / l)
                        }
                    }; m.length;) {
                    var v = m.pop() + u.leftX,
                        y = g(d, 1, v),
                        b = g(p, -1, v),
                        x = y.v.z,
                        w = b.v.z;
                    f.push({
                        x: v,
                        tz: x,
                        bz: w
                    }), d = y.index, p = b.index
                }
                var _ = this,
                    M = f.map(function(e) {
                        var n = [new o.Vector3(e.x, 0, e.bz), new o.Vector3(e.x, 0, e.tz)],
                            r = _.extrudeShapeOnYPlane("beam", t, a, n, !0),
                            i = new o.Object3D;
                        return i.name = "beam wrapper", i.add(r), [i, 0, 0, 0]
                    }),
                    E = this.compose(e, M);
                E.applyMatrix(c);
                var T = this.placeholder("rotated " + e);
                return T.add(E), T
            }, e.prototype.compose = function(e, t) {
                var n = new o.Object3D;
                return n.position.set(0, 0, 0), n.name = e, t.map(function(e) {
                    var t = e[0];
                    if (t && t.children) {
                        var r = e[1],
                            i = e[2],
                            o = e[3];
                        r = isNaN(r) ? 0 : r, i = isNaN(i) ? 0 : i, o = isNaN(o) ? 0 : o;
                        var a = t.clone();
                        a.position.set(r, i, o), n.add(a)
                    }
                }), n
            }, e.prototype.setCastsShadow = function(e, t) {
                e.traverse(function(e) {
                    e instanceof o.Mesh && (e.castShadow = t(e), e.receiveShadow = t(e))
                })
            }, e.prototype.remapUV = function(e, t, n) {
                return e.updateMatrixWorld(!1), e.traverse(function(e) {
                    if (e instanceof o.Mesh) {
                        var r = e.geometry;
                        r.isBufferGeometry && (r = (new o.Geometry).fromBufferGeometry(r), e.geometry = r), r.computeFaceNormals(), r.boundingBox || r.computeBoundingBox();
                        var i = r.boundingBox.min;
                        n && (i.x += n.x, i.y += n.y), r.faceVertexUvs[0] = [], r.faces.forEach(function(n) {
                            var a = [n.a, n.b, n.c],
                                s = [];
                            a.forEach(function(a) {
                                var c = e.localToWorld(r.vertices[a].clone()).sub(i),
                                    l = n.normal.toArray().map(Math.abs),
                                    h = 0;
                                l[1] > l[h] && (h = 1), l[2] > l[h] && (h = 2);
                                var u;
                                u = 0 === h ? new o.Vector2(c.z, c.y) : 1 === h ? new o.Vector2(c.x, c.z) : new o.Vector2(c.x, c.y), t && (u = new o.Vector2(u.y, u.x)), s.push(u)
                            }), r.faceVertexUvs[0].push(s)
                        }), r.uvsNeedUpdate = !0
                    }
                }), e
            }, e.prototype.remapUV2 = function(e, t, n) {
                return e.updateMatrixWorld(!1), e.traverse(function(e) {
                    if (e instanceof o.Mesh) {
                        var r = e.geometry;
                        r.isBufferGeometry && (r = (new o.Geometry).fromBufferGeometry(r), e.geometry = r), r.boundingBox || r.computeBoundingBox();
                        var i = r.boundingBox.min;
                        n && (i.x += n.x, i.y += n.y), r.computeFaceNormals(), r.faceVertexUvs[0] = [], r.faces.forEach(function(n) {
                            var a = [n.a, n.b, n.c],
                                s = [];
                            a.forEach(function(a) {
                                var c = e.localToWorld(r.vertices[a].clone()).sub(i),
                                    l = n.normal.toArray().map(Math.abs),
                                    h = 0;
                                l[1] > l[h] && (h = 1), l[2] > l[h] && (h = 2);
                                var u;
                                u = 0 === h ? new o.Vector2(c.y, c.z) : 1 === h ? new o.Vector2(c.x, c.z) : new o.Vector2(c.x, c.y), t && (u = new o.Vector2(u.y, u.x)), s.push(u)
                            }), r.faceVertexUvs[0].push(s)
                        }), r.uvsNeedUpdate = !0
                    }
                }), e
            }, e.prototype.matrixForPathPoint = function(e, t, n) {
                var r = e[t % e.length],
                    i = e[(t + e.length - 1) % e.length],
                    a = e[(t + 1) % e.length];
                i = i.clone().sub(r).normalize(), a = a.clone().sub(r).normalize();
                var s, c, l;
                e.length <= 2 ? (l = e[0].clone().sub(e[1]).normalize(), s = new o.Vector3(0, 1, 0).cross(l), c = l.clone().cross(s)) : (s = i.clone().cross(a), n && 0 === t ? (l = a, c = s.clone().cross(l).normalize()) : n && t === e.length - 1 ? (l = i.clone().negate(), c = s.clone().cross(l).normalize()) : (c = i.clone().add(a).normalize().negate(), l = s.clone().cross(c).normalize())), s.z > 0 && (s.negate(), c.negate(), l.negate()), s.normalize();
                var h = Math.sqrt(Math.sin(Math.acos(c.dot(l))));
                return l.divideScalar(h), c.divideScalar(h), (new o.Matrix4).makeBasis(c, s, l).setPosition(r)
            }, e.prototype.expandPathOnYPlane = function(e, t, n) {
                void 0 === n && (n = !1);
                var r = e.map(function(e, t, r) {
                    return this.matrixForPathPoint(r, t, n)
                }, this);
                return n || (e = e.slice(0), e.push(e[0]), r.push(r[0])), e.map(function(e, n) {
                    return t.clone().applyMatrix4(r[n])
                })
            }, e.prototype.extrudeShapeOnYPlane = function(e, t, n, r, i) {
                var a = r.map(function(e, t, n) {
                    return this.matrixForPathPoint(n, t, i)
                }, this);
                i || (r = r.slice(0), r.push(r[0]), a.push(a[0]));
                for (var s = new o.Geometry, c = n.length - 1, l = [], h = 0, u = 0, d = [], p = 0; p < r.length; p++) {
                    var f = a[p];
                    p > 0 && (u = r[p].distanceTo(r[p - 1]), h += u);
                    var m = 0,
                        g = n.map(function(e, t) {
                            return t > 0 && (m += n[t].distanceTo(n[t - 1])), e = e.clone().applyMatrix4(f), s.vertices.push(e), d.push(new o.Vector2(m, h)), e
                        });
                    for (i && (0 === p ? l.push(g.reverse()) : p === r.length - 1 && l.push(g)); c < s.vertices.length - 1;) {
                        var v = c - n.length,
                            y = c,
                            b = v + 1,
                            x = y + 1;
                        s.faces.push(new o.Face3(b, y, v)), s.faces.push(new o.Face3(x, y, b));
                        var w = d[v],
                            _ = d[y],
                            M = d[b],
                            E = d[x];
                        s.faceVertexUvs[0].push([M, _, w]), s.faceVertexUvs[0].push([E, _, M]), c++
                    }
                    c++
                }
                s.computeFaceNormals(), l.map(function(e) {
                    this.polygonGeometry(e, s)
                }.bind(this));
                var T = new o.Mesh(s, t);
                return T.name = e, T
            }, e.prototype.extrudeEdges = function(e, t, n, r) {
                var i = new o.Geometry;
                i.name = e, n.map(function(e) {
                    this.extrudeEdge(e.v1, e.v2, e.v1Normal, e.v2Normal, r, i)
                }.bind(this)), i.computeFaceNormals();
                var a = new o.Mesh(i, t);
                return a.name = e, a
            }, e.prototype.extrudeEdge = function(e, t, n, r, i, a) {
                n = n || new o.Vector3(0, 1, 0), r = r || new o.Vector3(0, 1, 0), a = a || new o.Geometry;
                var s = a.vertices.length,
                    c = [{
                        v: e,
                        n: n,
                        m: null
                    }, {
                        v: t,
                        n: r,
                        m: null
                    }],
                    l = e.clone().sub(t).normalize();
                c.map(function(e) {
                    var t = e.n.clone().cross(l);
                    e.m = (new o.Matrix4).makeBasis(e.n, t, l).setPosition(e.v)
                });
                var h = 0,
                    u = 0,
                    d = [],
                    p = [];
                u = e.distanceTo(t);
                for (var f = 0; f < c.length; f++) {
                    var m = c[f].m;
                    f > 0 && (h += u);
                    var g = 0,
                        v = i.map(function(e, t) {
                            return t > 0 && (g += i[t].distanceTo(i[t - 1])), e = e.clone().applyMatrix4(m), a.vertices.push(e), p.push(new o.Vector2(g, h)), e
                        });
                    if (0 === f ? d.push(v.reverse()) : 1 === f && d.push(v), f > 0)
                        for (var y = 1; y < i.length; y++) {
                            var b = s + f * i.length + y - 1,
                                x = b - i.length,
                                w = b + 1,
                                _ = x + 1;
                            a.faces.push(new o.Face3(b, x, w)), a.faces.push(new o.Face3(w, x, _));
                            var M = f * i.length + y - 1,
                                E = M - i.length,
                                T = M + 1,
                                S = E + 1,
                                A = p[M],
                                P = p[E],
                                C = p[T],
                                L = p[S];
                            a.faceVertexUvs[0].push([A, P, C]), a.faceVertexUvs[0].push([C, P, L])
                        }
                }
                return d.map(function(e) {
                    this.polygonGeometry(e, a)
                }.bind(this)), a
            }, e.prototype.tableLegs = function(e, t, n, r, i) {
                var o = this.beamInHeight("leg", t, r),
                    a = (n - this.thickness) / 2,
                    s = (i - this.thickness) / 2;
                return this.compose(e, [
                    [o, -a, 0, s],
                    [o, -a, 0, -s],
                    [o, a, 0, -s],
                    [o, a, 0, s]
                ])
            }, e.prototype.horizontalFrame = function(e, t, n, r, i) {
                var o = (n - this.thickness) / 2,
                    a = (i - this.thickness) / 2,
                    s = this.box("depthBeam", t, this.thickness, r, i),
                    c = this.box("widthBeam", t, n, r, this.thickness);
                return this.compose(e, [
                    [s, -o, 0, 0],
                    [s, o, 0, 0],
                    [c, 0, 0, -a],
                    [c, 0, 0, a]
                ])
            }, e.prototype.horizontalShutters = function(e, t, n, r, i, o, a, s, c, l) {
                if (o < a) {
                    var h = this.fixedShutters(e, t, n, r, i, a, o, s, c, l);
                    return h.rotation.y += Math.PI / 2, h
                }
                return this.fixedShutters(e, t, n, r, i, o, a, s, c, l)
            }, e.prototype.fixedShutters = function(e, t, n, r, i, o, a, s, c, l) {
                var h = Math.floor(o / n),
                    u = o / h,
                    d = [],
                    p = this.box("shutter", t, u - .5, r, a);
                p.rotation.z = Math.PI / 2 * c + i * (1 - c);
                var f = [],
                    m = p.clone();
                if (s) {
                    for (var g = Math.floor(o / l), v = Math.floor(l / u), y = v * u, b = o - g * y, x = b / 2 + y / 2, w = 0; w < g; w++, x += y) x < o && f.push(Math.ceil(x / u));
                    var _ = this.box("light", this.materials[s], 2, 1, a);
                    _.position.setY(r / 2 + .5), m.add(_)
                }
                var M = -(o - u) / 2;
                u = (u - r) * (1 - c) + r;
                for (var E = 0; E < h; E++, M += u) d.push([f.indexOf(E + 1) < 0 ? p : m, M, 0, 0]);
                return this.compose(e, d)
            }, e.prototype.curvedShutters = function(e, t, n, r, i, o, a, s) {
                if (s) {
                    var c = this.fixedcurvedShutters(e, t, n, r, o, i, a);
                    return c.rotation.z = -Math.PI / 2, c
                }
                if (i < o) {
                    var c = this.fixedcurvedShutters(e, t, n, r, o, i, a);
                    return c.rotation.z += Math.PI / 2, c
                }
                return this.fixedcurvedShutters(e, t, n, r, i, o, a)
            }, e.prototype.fixedcurvedShutters = function(e, t, n, r, i, a, s) {
                var c = function(e, t, n) {
                        return (t - e) * n + e
                    },
                    l = Math.floor(i / (3 + n)),
                    h = i / l - 3,
                    u = new o.Shape,
                    d = c(.1, .7, s) * h,
                    p = c(1, .01, s) * h,
                    f = c(-.5, .2, s) * h,
                    m = r;
                u.moveTo(0, 0), u.bezierCurveTo(-f, -d, f + p, -d, p, 0), u.moveTo(p - m, 0), u.bezierCurveTo(f + p - m, -d + m, -f + m, -d + m, m, 0);
                var g = {
                        amount: a,
                        bevelEnabled: !1,
                        bevelSegments: 2,
                        steps: 2,
                        bevelSize: 1,
                        bevelThickness: 1
                    },
                    v = new o.ExtrudeGeometry(u, g),
                    y = [],
                    b = new o.Mesh(v, t);
                b.rotation.x = -Math.PI / 2;
                var x = new o.Mesh(new o.BoxBufferGeometry(3, 4, a), t);
                x.position.set(-1.5, -1.2, a / 2), b.add(x);
                var w = new o.Mesh(new o.CylinderBufferGeometry(1.5, 1.5, a, 32), t);
                w.rotation.x = Math.PI / 2, w.position.set(-1.5, -3.2, a / 2), b.add(w);
                var _ = new o.Mesh(new o.BoxBufferGeometry(3, 4, a), t);
                _.position.set(p + 1.5, -1.2, a / 2), b.add(_);
                var M = new o.Mesh(new o.CylinderBufferGeometry(1.5, 1.5, a, 32), t);
                M.rotation.x = Math.PI / 2, M.position.set(p + 1.5, -3.2, a / 2), b.add(M);
                for (var E = -i / 2, T = 0; T < l; T += 1, E += p + 3) y.push([b, E, -a / 2, 0]);
                return this.compose(e, y)
            }, e.prototype.verticalSideFacingPanel = function(e, t, n, r, i) {
                return this.box(e, t, i, r, n)
            }, e.prototype.verticalFrontFacingPanel = function(e, t, n, r, i) {
                return this.box(e, t, n, r, i)
            }, e.prototype.glassSlidersLeftFrontToRightBack = function(e, t, n, r, i, o, a) {
                var s = Math.ceil(n / o);
                if (s > i) {
                    var c = i * o,
                        l = (n - c) / 2,
                        h = this.glassSlidersLeftFrontToRightBack("doors", t, c, r, i, o, a),
                        u = this.verticalFrontFacingPanel("sidepanel", t.glass, l, r, 1);
                    return this.compose(e, [
                        [h, 0, 0, 0],
                        [u, (c + l) / 2, 0, 0],
                        [u, -(c + l) / 2, 0, 0]
                    ])
                }
                for (var d = n / s, p = r - 10, f = this.verticalFrontFacingPanel("glass", t.glass, d + 2, p, 1), m = this.verticalFrontFacingPanel("bottom", t.blackMetal, d + 2, 10, 1), g = this.compose("doorpanel", [
                        [f, 0, 5, 0],
                        [m, 0, (10 - r) / 2, 0]
                    ]), v = [], y = 0; y < s; y++) {
                    var b = y - s / 2 + .5,
                        x = -y * d * a / 100,
                        w = [g, d * b + x, 0, 1.1 * b];
                    v.push(w)
                }
                return this.compose(e, v)
            }, e.prototype.patioFrame = function(e, t, n, r, i, o) {
                var a = r / 2 + o / 2,
                    s = this.tableLegs("legs", t, n, r, i),
                    c = this.horizontalFrame("topframe", t, n, o, i);
                return this.compose(e, [
                    [s, 0, 0, 0],
                    [c, 0, a, 0]
                ])
            }, e.prototype.roofDome = function(e, n, r, i, o, a, s) {
                if ("none" !== n) {
                    if (i > r) {
                        var c = this.roofDome(e, n, i, r, o, a, s);
                        return c = this.compose("rotated " + e, [
                            [c, 0, 0, 0]
                        ]), c.rotation.y += Math.PI / 2, c
                    }
                    a = a || 60, s = s || a;
                    var l = {
                        name: e,
                        width: r,
                        depth: i,
                        beamShape: this.default.beamShape,
                        beamIntervalBuilder: (new t).withMaxWidth(a).withoutBorders(),
                        beamIntervalBuilder2: (new t).withMaxWidth(s).withoutBorders(),
                        glassMaterial: this.materials.glass,
                        beamMaterial: o || this.materials.whiteMetal,
                        angle: 0,
                        sideCount: 0
                    };
                    switch (n) {
                        case "flat":
                            return l.angle = 5, this.__angularDome(l);
                        case "saddle":
                            return l.angle = 30, l.sideCount = 2, this.__nSidedDome(l);
                        case "pyramid":
                        case "pyramid":
                            return l.angle = 30, l.sideCount = 4, this.__nSidedDome(l)
                    }
                }
            }, e.prototype.windowFrame = function(e, t) {
                var n = this.expandPathOnYPlane(t, new o.Vector3(-2, 3, 0)),
                    r = this.polygonGeometry(n),
                    i = new o.Mesh(r, this.materials.glass);
                i.name = e + " glass";
                var a = this.beamsAroundPoly(e + " border", this.materials.whiteMetal, t, this.default.windowBeamShape);
                return this.compose(e, [
                    [i, 0, 0, 0],
                    [a, 0, 0, 0]
                ])
            }, e.prototype.sidePolygons = function(e, t) {
                var n = new o.Vector3(0, t / 2, 0);
                return e.slice(1).map(function(t, r) {
                    var i = e[r];
                    return [i.clone().sub(n), t.clone().sub(n), t.clone().add(n), i.clone().add(n)]
                })
            }, e.prototype.__nSidedDome = function(e) {
                var t = Math.tan(e.angle * Math.PI / 180),
                    n = e.depth / 2 * t;
                1 === e.sideCount && (n *= 2);
                var r = new o.Vector3(0, 1, 0),
                    i = new o.Vector3(-e.width / 2, 0, -e.depth / 2),
                    a = new o.Vector3(e.width / 2, 0, -e.depth / 2),
                    s = new o.Vector3(-e.width / 2, 0, e.depth / 2),
                    c = new o.Vector3(e.width / 2, 0, e.depth / 2),
                    l = new o.Vector3(-e.width / 2, n, 0),
                    h = new o.Vector3(e.width / 2, n, 0);
                4 === e.sideCount && (l.x += e.depth / 2, h.x -= e.depth / 2);
                var u = this.parallelBeamsOverPoly("dome structural beams width", e.beamMaterial, [a, i, l, h], 0, e.beamIntervalBuilder, e.beamShape),
                    d = this.parallelBeamsOverPoly("dome structural beams depth", e.beamMaterial, [i, s, l], 0, e.beamIntervalBuilder2, e.beamShape),
                    p = this.polygonGeometry([a, i, l, h]);
                this.polygonGeometry([i, s, l], p);
                var f = new o.Mesh(p, e.glassMaterial),
                    m = this.compose("dome back and left side", [
                        [u, 0, 0, 0],
                        [d, 0, 0, 0],
                        [f, 0, 0, 0]
                    ]),
                    g = m.clone().rotateY(Math.PI);
                g.name = "dome front and right side";
                var v = this.beamsAroundPoly("dome surround beams", e.beamMaterial, [i, a, c, s], e.beamShape),
                    y = new o.Vector3(6, 0, 0),
                    b = new o.Vector3(0, 1, 0),
                    x = [{
                        v1: i,
                        v2: l
                    }, {
                        v1: s,
                        v2: l
                    }, {
                        v1: a,
                        v2: h
                    }, {
                        v1: c,
                        v2: h
                    }, {
                        v1: l.clone().sub(y).add(b),
                        v2: h.clone().add(y).add(b)
                    }].map(function(e) {
                        var t = e.v2.clone().sub(e.v1).normalize().cross(r).normalize();
                        return {
                            v1: e.v1,
                            v2: e.v2,
                            v1Normal: t,
                            v2Normal: t
                        }
                    }),
                    w = this.extrudeEdges("dome edge", e.beamMaterial, x, e.beamShape);
                return this.compose(e.name, [
                    [m, 0, 0, 0],
                    [g, 0, 0, 0],
                    [v, 0, 0, 0],
                    [w, 0, 0, 0]
                ])
            }, e.prototype.__angularDome = function(e) {
                var t = Math.tan(e.angle * Math.PI / 180),
                    n = new o.Vector3(e.width / 2, 0, -e.depth / 2),
                    r = new o.Vector3(-e.width / 2, 0, -e.depth / 2),
                    i = new o.Vector3(-e.width / 2, 0, e.depth / 2),
                    a = new o.Vector3(e.width / 2, 0, e.depth / 2),
                    s = new o.Vector3(0, e.depth / 2 * t, 0),
                    c = [n, r, i.clone().add(s), a.clone().add(s)],
                    l = this.parallelBeamsOverPoly("roof parallel beams", e.beamMaterial, c, 0, e.beamIntervalBuilder, e.beamShape),
                    h = this.beamsAroundPoly("roof surround beams", e.beamMaterial, c, e.beamShape),
                    u = new o.Mesh(this.polygonGeometry(c), this.materials.glass),
                    d = new o.Vector3(0, -10, 0),
                    p = new o.Vector3(-3, 0, 0),
                    f = [n, n.clone().add(d), a.clone().add(d), a.clone().add(s)],
                    m = f.map(function(e) {
                        return e.clone().sub(p)
                    }).reverse(),
                    g = f.reverse().map(function(e) {
                        return new o.Vector3(-e.x, e.y, e.z)
                    }),
                    v = m.reverse().map(function(e) {
                        return new o.Vector3(-e.x, e.y, e.z)
                    }),
                    y = [i.clone().add(s).add(p), a.clone().add(s).sub(p), a.add(d).sub(p), i.add(d).add(p)],
                    b = this.polygonGeometry(m);
                this.polygonGeometry(f, b), this.polygonGeometry(g, b), this.polygonGeometry(v, b), this.polygonGeometry(y, b), this.polygonGeometry(y.reverse(), b);
                var x = new o.Mesh(b, this.materials.whiteMetal);
                return this.compose(e.name, [
                    [l, 0, 0, 0],
                    [h, 0, 0, 0],
                    [u, 0, 0, 0],
                    [x, 0, 0, 0]
                ])
            }, e.prototype.mergeGeometry = function(e) {
                function t(e) {
                    var t = n[e.material.id];
                    t || (t = new o.Mesh(new o.Geometry, e.material), n[e.material.id] = t, r.add(t)), t.geometry.merge(e.geometry, e.matrixWorld)
                }
                var n = {},
                    r = new o.Object3D;
                return r.name = e.name, e.updateMatrixWorld(), e.traverse(function(e) {
                    e.isMesh && t(e)
                }), r
            }, e.prototype.backgroundSphere = function(e, t) {
                var n = e || 600,
                    r = -t || 160,
                    i = this.materials.environmentSphere,
                    o = this.sphere("backgroundSphere", i, n);
                o.scale.z = -1, o.material.depthWrite = !1;
                var a = o.geometry;
                return a.vertices.map(function(e) {
                    if (e.y < -r) {
                        var t = -r / e.y;
                        e.multiplyScalar(t)
                    }
                }), a.verticesNeedUpdate = !0, o
            }, e.prototype.setEnvironmentTextureFromUrl = function(e, t) {
                this.materials.setEnvironmentTextureFromUrl(e, t)
            }, e.prototype.simplifyVerts = function(e) {
                return e.filter(function(e, t, n) {
                    return n[(t - 1 + n.length) % n.length].distanceToManhattan(e) >= 1
                }).filter(function(e, t, n) {
                    var r = n[(t - 1 + n.length) % n.length],
                        i = n[(t + 1) % n.length],
                        o = e.x,
                        a = e.y,
                        s = r.x,
                        c = r.y,
                        l = i.x,
                        h = i.y;
                    return o * (c - h) + s * (h - a) + l * (a - c) != 0
                })
            }, e
        }();
        e.Builder = n
    }(r || (r = {}))
}, function(e, t, n) {
    var r = n(0);
    r.OrbitControls = function(e, t) {
        function n() {
            return 2 * Math.PI / 60 / 60 * k.autoRotateSpeed
        }

        function i() {
            return Math.pow(.95, k.zoomSpeed)
        }

        function o(e) {
            H.theta -= e
        }

        function a(e) {
            H.phi -= e
        }

        function s(e) {
            k.object instanceof r.PerspectiveCamera ? V /= e : k.object instanceof r.OrthographicCamera ? (k.object.zoom = Math.max(k.minZoom, Math.min(k.maxZoom, k.object.zoom * e)), k.object.updateProjectionMatrix(), W = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), k.enableZoom = !1)
        }

        function c(e) {
            k.object instanceof r.PerspectiveCamera ? V *= e : k.object instanceof r.OrthographicCamera ? (k.object.zoom = Math.max(k.minZoom, Math.min(k.maxZoom, k.object.zoom / e)), k.object.updateProjectionMatrix(), W = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), k.enableZoom = !1)
        }

        function l(e) {
            $.set(e.clientX, e.clientY)
        }

        function h(e) {
            K.set(e.clientX, e.clientY)
        }

        function u(e) {
            Y.set(e.clientX, e.clientY)
        }

        function d(e) {
            X.set(e.clientX, e.clientY), q.subVectors(X, $);
            var t = k.domElement === document ? k.domElement.body : k.domElement;
            o(2 * Math.PI * q.x / t.clientWidth * k.rotateSpeed), a(2 * Math.PI * q.y / t.clientHeight * k.rotateSpeed), $.copy(X), k.update()
        }

        function p(e) {
            Q.set(e.clientX, e.clientY), ee.subVectors(Q, K), ee.y > 0 ? s(i()) : ee.y < 0 && c(i()), K.copy(Q), k.update()
        }

        function f(e) {
            Z.set(e.clientX, e.clientY), J.subVectors(Z, Y), re(J.x, J.y), Y.copy(Z), k.update()
        }

        function m(e) {}

        function g(e) {
            e.deltaY < 0 ? c(i()) : e.deltaY > 0 && s(i()), k.update()
        }

        function v(e) {
            switch (e.keyCode) {
                case k.keys.UP:
                    re(0, k.keyPanSpeed), k.update();
                    break;
                case k.keys.BOTTOM:
                    re(0, -k.keyPanSpeed), k.update();
                    break;
                case k.keys.LEFT:
                    re(k.keyPanSpeed, 0), k.update();
                    break;
                case k.keys.RIGHT:
                    re(-k.keyPanSpeed, 0), k.update()
            }
        }

        function y(e) {
            $.set(e.touches[0].pageX, e.touches[0].pageY)
        }

        function b(e) {
            var t = e.touches[0].pageX - e.touches[1].pageX,
                n = e.touches[0].pageY - e.touches[1].pageY,
                r = Math.sqrt(t * t + n * n);
            K.set(0, r)
        }

        function x(e) {
            Y.set(e.touches[0].pageX, e.touches[0].pageY)
        }

        function w(e) {
            X.set(e.touches[0].pageX, e.touches[0].pageY), q.subVectors(X, $);
            var t = k.domElement === document ? k.domElement.body : k.domElement;
            o(2 * Math.PI * q.x / t.clientWidth * k.rotateSpeed), a(2 * Math.PI * q.y / t.clientHeight * k.rotateSpeed), $.copy(X), k.update()
        }

        function _(e) {
            var t = e.touches[0].pageX - e.touches[1].pageX,
                n = e.touches[0].pageY - e.touches[1].pageY,
                r = Math.sqrt(t * t + n * n);
            Q.set(0, r), ee.subVectors(Q, K), ee.y > 0 ? c(i()) : ee.y < 0 && s(i()), K.copy(Q), k.update()
        }

        function M(e) {
            Z.set(e.touches[0].pageX, e.touches[0].pageY), J.subVectors(Z, Y), re(J.x, J.y), Y.copy(Z), k.update()
        }

        function E(e) {}

        function T(e) {
            if (!1 !== k.enabled) {
                switch (e.preventDefault(), e.button) {
                    case k.mouseButtons.ORBIT:
                        if (!1 === k.enableRotate) return;
                        l(e), F = U.ROTATE;
                        break;
                    case k.mouseButtons.ZOOM:
                        if (!1 === k.enableZoom) return;
                        h(e), F = U.DOLLY;
                        break;
                    case k.mouseButtons.PAN:
                        if (!1 === k.enablePan) return;
                        u(e), F = U.PAN
                }
                F !== U.NONE && (document.addEventListener("mousemove", S, !1), document.addEventListener("mouseup", A, !1), k.dispatchEvent(N))
            }
        }

        function S(e) {
            if (!1 !== k.enabled) switch (e.preventDefault(), F) {
                case U.ROTATE:
                    if (!1 === k.enableRotate) return;
                    d(e);
                    break;
                case U.DOLLY:
                    if (!1 === k.enableZoom) return;
                    p(e);
                    break;
                case U.PAN:
                    if (!1 === k.enablePan) return;
                    f(e)
            }
        }

        function A(e) {
            !1 !== k.enabled && (m(e), document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", A, !1), k.dispatchEvent(B), F = U.NONE)
        }

        function P(e) {
            !1 === k.enabled || !1 === k.enableZoom || F !== U.NONE && F !== U.ROTATE || (e.preventDefault(), e.stopPropagation(), g(e), k.dispatchEvent(N), k.dispatchEvent(B))
        }

        function C(e) {
            !1 !== k.enabled && !1 !== k.enableKeys && !1 !== k.enablePan && v(e)
        }

        function L(e) {
            if (!1 !== k.enabled) {
                switch (e.touches.length) {
                    case 1:
                        if (!1 === k.enableRotate) return;
                        y(e), F = U.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === k.enableZoom) return;
                        b(e), F = U.TOUCH_DOLLY;
                        break;
                    case 3:
                        if (!1 === k.enablePan) return;
                        x(e), F = U.TOUCH_PAN;
                        break;
                    default:
                        F = U.NONE
                }
                F !== U.NONE && k.dispatchEvent(N)
            }
        }

        function R(e) {
            if (!1 !== k.enabled) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) {
                case 1:
                    if (!1 === k.enableRotate) return;
                    if (F !== U.TOUCH_ROTATE) return;
                    w(e);
                    break;
                case 2:
                    if (!1 === k.enableZoom) return;
                    if (F !== U.TOUCH_DOLLY) return;
                    _(e);
                    break;
                case 3:
                    if (!1 === k.enablePan) return;
                    if (F !== U.TOUCH_PAN) return;
                    M(e);
                    break;
                default:
                    F = U.NONE
            }
        }

        function I(e) {
            !1 !== k.enabled && (E(e), k.dispatchEvent(B), F = U.NONE)
        }

        function O(e) {
            e.preventDefault()
        }
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new r.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        }, this.mouseButtons = {
            ORBIT: r.MOUSE.LEFT,
            ZOOM: r.MOUSE.MIDDLE,
            PAN: r.MOUSE.RIGHT
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
            return j.phi
        }, this.getAzimuthalAngle = function() {
            return j.theta
        }, this.saveState = function() {
            k.target0.copy(k.target), k.position0.copy(k.object.position), k.zoom0 = k.object.zoom
        }, this.reset = function() {
            k.target.copy(k.target0), k.object.position.copy(k.position0), k.object.zoom = k.zoom0, k.object.updateProjectionMatrix(), k.dispatchEvent(D), k.update(), F = U.NONE
        }, this.update = function() {
            var t = new r.Vector3,
                i = (new r.Quaternion).setFromUnitVectors(e.up, new r.Vector3(0, 1, 0)),
                a = i.clone().inverse(),
                s = new r.Vector3,
                c = new r.Quaternion;
            return function() {
                var e = k.object.position;
                return t.copy(e).sub(k.target), t.applyQuaternion(i), j.setFromVector3(t), k.autoRotate && F === U.NONE && o(n()), j.theta += H.theta, j.phi += H.phi, j.theta = Math.max(k.minAzimuthAngle, Math.min(k.maxAzimuthAngle, j.theta)), j.phi = Math.max(k.minPolarAngle, Math.min(k.maxPolarAngle, j.phi)), j.makeSafe(), j.radius *= V, j.radius = Math.max(k.minDistance, Math.min(k.maxDistance, j.radius)), k.target.add(G), t.setFromSpherical(j), t.applyQuaternion(a), e.copy(k.target).add(t), k.object.lookAt(k.target), !0 === k.enableDamping ? (H.theta *= 1 - k.dampingFactor, H.phi *= 1 - k.dampingFactor) : H.set(0, 0, 0), V = 1, G.set(0, 0, 0), !!(W || s.distanceToSquared(k.object.position) > z || 8 * (1 - c.dot(k.object.quaternion)) > z) && (k.dispatchEvent(D), s.copy(k.object.position), c.copy(k.object.quaternion), W = !1, !0)
            }
        }(), this.dispose = function() {
            k.domElement.removeEventListener("contextmenu", O, !1), k.domElement.removeEventListener("mousedown", T, !1), k.domElement.removeEventListener("wheel", P, !1), k.domElement.removeEventListener("touchstart", L, !1), k.domElement.removeEventListener("touchend", I, !1), k.domElement.removeEventListener("touchmove", R, !1), document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", A, !1), window.removeEventListener("keydown", C, !1)
        };
        var k = this,
            D = {
                type: "change"
            },
            N = {
                type: "start"
            },
            B = {
                type: "end"
            },
            U = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            },
            F = U.NONE,
            z = 1e-6,
            j = new r.Spherical,
            H = new r.Spherical,
            V = 1,
            G = new r.Vector3,
            W = !1,
            $ = new r.Vector2,
            X = new r.Vector2,
            q = new r.Vector2,
            Y = new r.Vector2,
            Z = new r.Vector2,
            J = new r.Vector2,
            K = new r.Vector2,
            Q = new r.Vector2,
            ee = new r.Vector2,
            te = function() {
                var e = new r.Vector3;
                return function(t, n) {
                    e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), G.add(e)
                }
            }(),
            ne = function() {
                var e = new r.Vector3;
                return function(t, n) {
                    e.setFromMatrixColumn(n, 1), e.multiplyScalar(t), G.add(e)
                }
            }(),
            re = function() {
                var e = new r.Vector3;
                return function(t, n) {
                    var i = k.domElement === document ? k.domElement.body : k.domElement;
                    if (k.object instanceof r.PerspectiveCamera) {
                        var o = k.object.position;
                        e.copy(o).sub(k.target);
                        var a = e.length();
                        a *= Math.tan(k.object.fov / 2 * Math.PI / 180), te(2 * t * a / i.clientHeight, k.object.matrix), ne(2 * n * a / i.clientHeight, k.object.matrix)
                    } else k.object instanceof r.OrthographicCamera ? (te(t * (k.object.right - k.object.left) / k.object.zoom / i.clientWidth, k.object.matrix), ne(n * (k.object.top - k.object.bottom) / k.object.zoom / i.clientHeight, k.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), k.enablePan = !1)
                }
            }();
        k.domElement.addEventListener("contextmenu", O, !1), k.domElement.addEventListener("mousedown", T, !1), k.domElement.addEventListener("wheel", P, !1), k.domElement.addEventListener("touchstart", L, !1), k.domElement.addEventListener("touchend", I, !1), k.domElement.addEventListener("touchmove", R, !1), window.addEventListener("keydown", C, !1), this.update()
    }, r.OrbitControls.prototype = Object.create(r.EventDispatcher.prototype), r.OrbitControls.prototype.constructor = r.OrbitControls, Object.defineProperties(r.OrbitControls.prototype, {
        center: {
            get: function() {
                return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
            }
        },
        noZoom: {
            get: function() {
                return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
            }
        },
        noRotate: {
            get: function() {
                return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
            }
        },
        noPan: {
            get: function() {
                return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
            }
        },
        noKeys: {
            get: function() {
                return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
            }
        },
        staticMoving: {
            get: function() {
                return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
            }
        },
        dynamicDampingFactor: {
            get: function() {
                return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
            },
            set: function(e) {
                console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e
            }
        }
    })
}, function(e, t, n) {
    "use strict";
    (function(e) {
        function r() {
            return o.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function i(e, t) {
            if (r() < t) throw new RangeError("Invalid typed array length");
            return o.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t), e.__proto__ = o.prototype) : (null === e && (e = new o(t)), e.length = t), e
        }

        function o(e, t, n) {
            if (!(o.TYPED_ARRAY_SUPPORT || this instanceof o)) return new o(e, t, n);
            if ("number" == typeof e) {
                if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
                return l(this, e)
            }
            return a(this, e, t, n)
        }

        function a(e, t, n, r) {
            if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? d(e, t, n, r) : "string" == typeof t ? h(e, t, n) : p(e, t)
        }

        function s(e) {
            if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
            if (e < 0) throw new RangeError('"size" argument must not be negative')
        }

        function c(e, t, n, r) {
            return s(t), t <= 0 ? i(e, t) : void 0 !== n ? "string" == typeof r ? i(e, t).fill(n, r) : i(e, t).fill(n) : i(e, t)
        }

        function l(e, t) {
            if (s(t), e = i(e, t < 0 ? 0 : 0 | f(t)), !o.TYPED_ARRAY_SUPPORT)
                for (var n = 0; n < t; ++n) e[n] = 0;
            return e
        }

        function h(e, t, n) {
            if ("string" == typeof n && "" !== n || (n = "utf8"), !o.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
            var r = 0 | g(t, n);
            e = i(e, r);
            var a = e.write(t, n);
            return a !== r && (e = e.slice(0, a)), e
        }

        function u(e, t) {
            var n = t.length < 0 ? 0 : 0 | f(t.length);
            e = i(e, n);
            for (var r = 0; r < n; r += 1) e[r] = 255 & t[r];
            return e
        }

        function d(e, t, n, r) {
            if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError("'offset' is out of bounds");
            if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
            return t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r), o.TYPED_ARRAY_SUPPORT ? (e = t, e.__proto__ = o.prototype) : e = u(e, t), e
        }

        function p(e, t) {
            if (o.isBuffer(t)) {
                var n = 0 | f(t.length);
                return e = i(e, n), 0 === e.length ? e : (t.copy(e, 0, 0, n), e)
            }
            if (t) {
                if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || Y(t.length) ? i(e, 0) : u(e, t);
                if ("Buffer" === t.type && K(t.data)) return u(e, t.data)
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
        }

        function f(e) {
            if (e >= r()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r().toString(16) + " bytes");
            return 0 | e
        }

        function m(e) {
            return +e != e && (e = 0), o.alloc(+e)
        }

        function g(e, t) {
            if (o.isBuffer(e)) return e.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
            "string" != typeof e && (e = "" + e);
            var n = e.length;
            if (0 === n) return 0;
            for (var r = !1;;) switch (t) {
                case "ascii":
                case "latin1":
                case "binary":
                    return n;
                case "utf8":
                case "utf-8":
                case void 0:
                    return G(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * n;
                case "hex":
                    return n >>> 1;
                case "base64":
                    return X(e).length;
                default:
                    if (r) return G(e).length;
                    t = ("" + t).toLowerCase(), r = !0
            }
        }

        function v(e, t, n) {
            var r = !1;
            if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
            if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
            if (n >>>= 0, t >>>= 0, n <= t) return "";
            for (e || (e = "utf8");;) switch (e) {
                case "hex":
                    return I(this, t, n);
                case "utf8":
                case "utf-8":
                    return P(this, t, n);
                case "ascii":
                    return L(this, t, n);
                case "latin1":
                case "binary":
                    return R(this, t, n);
                case "base64":
                    return A(this, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return O(this, t, n);
                default:
                    if (r) throw new TypeError("Unknown encoding: " + e);
                    e = (e + "").toLowerCase(), r = !0
            }
        }

        function y(e, t, n) {
            var r = e[t];
            e[t] = e[n], e[n] = r
        }

        function b(e, t, n, r, i) {
            if (0 === e.length) return -1;
            if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                if (i) return -1;
                n = e.length - 1
            } else if (n < 0) {
                if (!i) return -1;
                n = 0
            }
            if ("string" == typeof t && (t = o.from(t, r)), o.isBuffer(t)) return 0 === t.length ? -1 : x(e, t, n, r, i);
            if ("number" == typeof t) return t &= 255, o.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : x(e, [t], n, r, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function x(e, t, n, r, i) {
            function o(e, t) {
                return 1 === a ? e[t] : e.readUInt16BE(t * a)
            }
            var a = 1,
                s = e.length,
                c = t.length;
            if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (e.length < 2 || t.length < 2) return -1;
                a = 2, s /= 2, c /= 2, n /= 2
            }
            var l;
            if (i) {
                var h = -1;
                for (l = n; l < s; l++)
                    if (o(e, l) === o(t, -1 === h ? 0 : l - h)) {
                        if (-1 === h && (h = l), l - h + 1 === c) return h * a
                    } else -1 !== h && (l -= l - h), h = -1
            } else
                for (n + c > s && (n = s - c), l = n; l >= 0; l--) {
                    for (var u = !0, d = 0; d < c; d++)
                        if (o(e, l + d) !== o(t, d)) {
                            u = !1;
                            break
                        }
                    if (u) return l
                }
            return -1
        }

        function w(e, t, n, r) {
            n = Number(n) || 0;
            var i = e.length - n;
            r ? (r = Number(r)) > i && (r = i) : r = i;
            var o = t.length;
            if (o % 2 != 0) throw new TypeError("Invalid hex string");
            r > o / 2 && (r = o / 2);
            for (var a = 0; a < r; ++a) {
                var s = parseInt(t.substr(2 * a, 2), 16);
                if (isNaN(s)) return a;
                e[n + a] = s
            }
            return a
        }

        function _(e, t, n, r) {
            return q(G(t, e.length - n), e, n, r)
        }

        function M(e, t, n, r) {
            return q(W(t), e, n, r)
        }

        function E(e, t, n, r) {
            return M(e, t, n, r)
        }

        function T(e, t, n, r) {
            return q(X(t), e, n, r)
        }

        function S(e, t, n, r) {
            return q($(t, e.length - n), e, n, r)
        }

        function A(e, t, n) {
            return 0 === t && n === e.length ? Z.fromByteArray(e) : Z.fromByteArray(e.slice(t, n))
        }

        function P(e, t, n) {
            n = Math.min(e.length, n);
            for (var r = [], i = t; i < n;) {
                var o = e[i],
                    a = null,
                    s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                if (i + s <= n) {
                    var c, l, h, u;
                    switch (s) {
                        case 1:
                            o < 128 && (a = o);
                            break;
                        case 2:
                            c = e[i + 1], 128 == (192 & c) && (u = (31 & o) << 6 | 63 & c) > 127 && (a = u);
                            break;
                        case 3:
                            c = e[i + 1], l = e[i + 2], 128 == (192 & c) && 128 == (192 & l) && (u = (15 & o) << 12 | (63 & c) << 6 | 63 & l) > 2047 && (u < 55296 || u > 57343) && (a = u);
                            break;
                        case 4:
                            c = e[i + 1], l = e[i + 2], h = e[i + 3], 128 == (192 & c) && 128 == (192 & l) && 128 == (192 & h) && (u = (15 & o) << 18 | (63 & c) << 12 | (63 & l) << 6 | 63 & h) > 65535 && u < 1114112 && (a = u)
                    }
                }
                null === a ? (a = 65533, s = 1) : a > 65535 && (a -= 65536, r.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), r.push(a), i += s
            }
            return C(r)
        }

        function C(e) {
            var t = e.length;
            if (t <= Q) return String.fromCharCode.apply(String, e);
            for (var n = "", r = 0; r < t;) n += String.fromCharCode.apply(String, e.slice(r, r += Q));
            return n
        }

        function L(e, t, n) {
            var r = "";
            n = Math.min(e.length, n);
            for (var i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
            return r
        }

        function R(e, t, n) {
            var r = "";
            n = Math.min(e.length, n);
            for (var i = t; i < n; ++i) r += String.fromCharCode(e[i]);
            return r
        }

        function I(e, t, n) {
            var r = e.length;
            (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
            for (var i = "", o = t; o < n; ++o) i += V(e[o]);
            return i
        }

        function O(e, t, n) {
            for (var r = e.slice(t, n), i = "", o = 0; o < r.length; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
            return i
        }

        function k(e, t, n) {
            if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
            if (e + t > n) throw new RangeError("Trying to access beyond buffer length")
        }

        function D(e, t, n, r, i, a) {
            if (!o.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > i || t < a) throw new RangeError('"value" argument is out of bounds');
            if (n + r > e.length) throw new RangeError("Index out of range")
        }

        function N(e, t, n, r) {
            t < 0 && (t = 65535 + t + 1);
            for (var i = 0, o = Math.min(e.length - n, 2); i < o; ++i) e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i)
        }

        function B(e, t, n, r) {
            t < 0 && (t = 4294967295 + t + 1);
            for (var i = 0, o = Math.min(e.length - n, 4); i < o; ++i) e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255
        }

        function U(e, t, n, r, i, o) {
            if (n + r > e.length) throw new RangeError("Index out of range");
            if (n < 0) throw new RangeError("Index out of range")
        }

        function F(e, t, n, r, i) {
            return i || U(e, t, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), J.write(e, t, n, r, 23, 4), n + 4
        }

        function z(e, t, n, r, i) {
            return i || U(e, t, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), J.write(e, t, n, r, 52, 8), n + 8
        }

        function j(e) {
            if (e = H(e).replace(ee, ""), e.length < 2) return "";
            for (; e.length % 4 != 0;) e += "=";
            return e
        }

        function H(e) {
            return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
        }

        function V(e) {
            return e < 16 ? "0" + e.toString(16) : e.toString(16)
        }

        function G(e, t) {
            t = t || 1 / 0;
            for (var n, r = e.length, i = null, o = [], a = 0; a < r; ++a) {
                if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {
                    if (!i) {
                        if (n > 56319) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (a + 1 === r) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = n;
                        continue
                    }
                    if (n < 56320) {
                        (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                        continue
                    }
                    n = 65536 + (i - 55296 << 10 | n - 56320)
                } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, n < 128) {
                    if ((t -= 1) < 0) break;
                    o.push(n)
                } else if (n < 2048) {
                    if ((t -= 2) < 0) break;
                    o.push(n >> 6 | 192, 63 & n | 128)
                } else if (n < 65536) {
                    if ((t -= 3) < 0) break;
                    o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                } else {
                    if (!(n < 1114112)) throw new Error("Invalid code point");
                    if ((t -= 4) < 0) break;
                    o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                }
            }
            return o
        }

        function W(e) {
            for (var t = [], n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
            return t
        }

        function $(e, t) {
            for (var n, r, i, o = [], a = 0; a < e.length && !((t -= 2) < 0); ++a) n = e.charCodeAt(a), r = n >> 8, i = n % 256, o.push(i), o.push(r);
            return o
        }

        function X(e) {
            return Z.toByteArray(j(e))
        }

        function q(e, t, n, r) {
            for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i) t[i + n] = e[i];
            return i
        }

        function Y(e) {
            return e !== e
        }
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */
        var Z = n(30),
            J = n(31),
            K = n(32);
        t.Buffer = o, t.SlowBuffer = m, t.INSPECT_MAX_BYTES = 50, o.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function() {
            try {
                var e = new Uint8Array(1);
                return e.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
            } catch (e) {
                return !1
            }
        }(), t.kMaxLength = r(), o.poolSize = 8192, o._augment = function(e) {
            return e.__proto__ = o.prototype, e
        }, o.from = function(e, t, n) {
            return a(null, e, t, n)
        }, o.TYPED_ARRAY_SUPPORT && (o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, {
            value: null,
            configurable: !0
        })), o.alloc = function(e, t, n) {
            return c(null, e, t, n)
        }, o.allocUnsafe = function(e) {
            return l(null, e)
        }, o.allocUnsafeSlow = function(e) {
            return l(null, e)
        }, o.isBuffer = function(e) {
            return !(null == e || !e._isBuffer)
        }, o.compare = function(e, t) {
            if (!o.isBuffer(e) || !o.isBuffer(t)) throw new TypeError("Arguments must be Buffers");
            if (e === t) return 0;
            for (var n = e.length, r = t.length, i = 0, a = Math.min(n, r); i < a; ++i)
                if (e[i] !== t[i]) {
                    n = e[i], r = t[i];
                    break
                }
            return n < r ? -1 : r < n ? 1 : 0
        }, o.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
            }
        }, o.concat = function(e, t) {
            if (!K(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e.length) return o.alloc(0);
            var n;
            if (void 0 === t)
                for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
            var r = o.allocUnsafe(t),
                i = 0;
            for (n = 0; n < e.length; ++n) {
                var a = e[n];
                if (!o.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
                a.copy(r, i), i += a.length
            }
            return r
        }, o.byteLength = g, o.prototype._isBuffer = !0, o.prototype.swap16 = function() {
            var e = this.length;
            if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2) y(this, t, t + 1);
            return this
        }, o.prototype.swap32 = function() {
            var e = this.length;
            if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4) y(this, t, t + 3), y(this, t + 1, t + 2);
            return this
        }, o.prototype.swap64 = function() {
            var e = this.length;
            if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8) y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4);
            return this
        }, o.prototype.toString = function() {
            var e = 0 | this.length;
            return 0 === e ? "" : 0 === arguments.length ? P(this, 0, e) : v.apply(this, arguments)
        }, o.prototype.equals = function(e) {
            if (!o.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === o.compare(this, e)
        }, o.prototype.inspect = function() {
            var e = "",
                n = t.INSPECT_MAX_BYTES;
            return this.length > 0 && (e = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (e += " ... ")), "<Buffer " + e + ">"
        }, o.prototype.compare = function(e, t, n, r, i) {
            if (!o.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError("out of range index");
            if (r >= i && t >= n) return 0;
            if (r >= i) return -1;
            if (t >= n) return 1;
            if (t >>>= 0, n >>>= 0, r >>>= 0, i >>>= 0, this === e) return 0;
            for (var a = i - r, s = n - t, c = Math.min(a, s), l = this.slice(r, i), h = e.slice(t, n), u = 0; u < c; ++u)
                if (l[u] !== h[u]) {
                    a = l[u], s = h[u];
                    break
                }
            return a < s ? -1 : s < a ? 1 : 0
        }, o.prototype.includes = function(e, t, n) {
            return -1 !== this.indexOf(e, t, n)
        }, o.prototype.indexOf = function(e, t, n) {
            return b(this, e, t, n, !0)
        }, o.prototype.lastIndexOf = function(e, t, n) {
            return b(this, e, t, n, !1)
        }, o.prototype.write = function(e, t, n, r) {
            if (void 0 === t) r = "utf8", n = this.length, t = 0;
            else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0;
            else {
                if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
            }
            var i = this.length - t;
            if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            for (var o = !1;;) switch (r) {
                case "hex":
                    return w(this, e, t, n);
                case "utf8":
                case "utf-8":
                    return _(this, e, t, n);
                case "ascii":
                    return M(this, e, t, n);
                case "latin1":
                case "binary":
                    return E(this, e, t, n);
                case "base64":
                    return T(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return S(this, e, t, n);
                default:
                    if (o) throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(), o = !0
            }
        }, o.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };
        var Q = 4096;
        o.prototype.slice = function(e, t) {
            var n = this.length;
            e = ~~e, t = void 0 === t ? n : ~~t, e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
            var r;
            if (o.TYPED_ARRAY_SUPPORT) r = this.subarray(e, t), r.__proto__ = o.prototype;
            else {
                var i = t - e;
                r = new o(i, void 0);
                for (var a = 0; a < i; ++a) r[a] = this[a + e]
            }
            return r
        }, o.prototype.readUIntLE = function(e, t, n) {
            e |= 0, t |= 0, n || k(e, t, this.length);
            for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);) r += this[e + o] * i;
            return r
        }, o.prototype.readUIntBE = function(e, t, n) {
            e |= 0, t |= 0, n || k(e, t, this.length);
            for (var r = this[e + --t], i = 1; t > 0 && (i *= 256);) r += this[e + --t] * i;
            return r
        }, o.prototype.readUInt8 = function(e, t) {
            return t || k(e, 1, this.length), this[e]
        }, o.prototype.readUInt16LE = function(e, t) {
            return t || k(e, 2, this.length), this[e] | this[e + 1] << 8
        }, o.prototype.readUInt16BE = function(e, t) {
            return t || k(e, 2, this.length), this[e] << 8 | this[e + 1]
        }, o.prototype.readUInt32LE = function(e, t) {
            return t || k(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
        }, o.prototype.readUInt32BE = function(e, t) {
            return t || k(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        }, o.prototype.readIntLE = function(e, t, n) {
            e |= 0, t |= 0, n || k(e, t, this.length);
            for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);) r += this[e + o] * i;
            return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r
        }, o.prototype.readIntBE = function(e, t, n) {
            e |= 0, t |= 0, n || k(e, t, this.length);
            for (var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);) o += this[e + --r] * i;
            return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o
        }, o.prototype.readInt8 = function(e, t) {
            return t || k(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
        }, o.prototype.readInt16LE = function(e, t) {
            t || k(e, 2, this.length);
            var n = this[e] | this[e + 1] << 8;
            return 32768 & n ? 4294901760 | n : n
        }, o.prototype.readInt16BE = function(e, t) {
            t || k(e, 2, this.length);
            var n = this[e + 1] | this[e] << 8;
            return 32768 & n ? 4294901760 | n : n
        }, o.prototype.readInt32LE = function(e, t) {
            return t || k(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        }, o.prototype.readInt32BE = function(e, t) {
            return t || k(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        }, o.prototype.readFloatLE = function(e, t) {
            return t || k(e, 4, this.length), J.read(this, e, !0, 23, 4)
        }, o.prototype.readFloatBE = function(e, t) {
            return t || k(e, 4, this.length), J.read(this, e, !1, 23, 4)
        }, o.prototype.readDoubleLE = function(e, t) {
            return t || k(e, 8, this.length), J.read(this, e, !0, 52, 8)
        }, o.prototype.readDoubleBE = function(e, t) {
            return t || k(e, 8, this.length), J.read(this, e, !1, 52, 8)
        }, o.prototype.writeUIntLE = function(e, t, n, r) {
            if (e = +e, t |= 0, n |= 0, !r) {
                D(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
            }
            var i = 1,
                o = 0;
            for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255;
            return t + n
        }, o.prototype.writeUIntBE = function(e, t, n, r) {
            if (e = +e, t |= 0, n |= 0, !r) {
                D(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
            }
            var i = n - 1,
                o = 1;
            for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
            return t + n
        }, o.prototype.writeUInt8 = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 1, 255, 0), o.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1
        }, o.prototype.writeUInt16LE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : N(this, e, t, !0), t + 2
        }, o.prototype.writeUInt16BE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : N(this, e, t, !1), t + 2
        }, o.prototype.writeUInt32LE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : B(this, e, t, !0), t + 4
        }, o.prototype.writeUInt32BE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : B(this, e, t, !1), t + 4
        }, o.prototype.writeIntLE = function(e, t, n, r) {
            if (e = +e, t |= 0, !r) {
                var i = Math.pow(2, 8 * n - 1);
                D(this, e, t, n, i - 1, -i)
            }
            var o = 0,
                a = 1,
                s = 0;
            for (this[t] = 255 & e; ++o < n && (a *= 256);) e < 0 && 0 === s && 0 !== this[t + o - 1] && (s = 1), this[t + o] = (e / a >> 0) - s & 255;
            return t + n
        }, o.prototype.writeIntBE = function(e, t, n, r) {
            if (e = +e, t |= 0, !r) {
                var i = Math.pow(2, 8 * n - 1);
                D(this, e, t, n, i - 1, -i)
            }
            var o = n - 1,
                a = 1,
                s = 0;
            for (this[t + o] = 255 & e; --o >= 0 && (a *= 256);) e < 0 && 0 === s && 0 !== this[t + o + 1] && (s = 1), this[t + o] = (e / a >> 0) - s & 255;
            return t + n
        }, o.prototype.writeInt8 = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 1, 127, -128), o.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
        }, o.prototype.writeInt16LE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : N(this, e, t, !0), t + 2
        }, o.prototype.writeInt16BE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : N(this, e, t, !1), t + 2
        }, o.prototype.writeInt32LE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 4, 2147483647, -2147483648), o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : B(this, e, t, !0), t + 4
        }, o.prototype.writeInt32BE = function(e, t, n) {
            return e = +e, t |= 0, n || D(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : B(this, e, t, !1), t + 4
        }, o.prototype.writeFloatLE = function(e, t, n) {
            return F(this, e, t, !0, n)
        }, o.prototype.writeFloatBE = function(e, t, n) {
            return F(this, e, t, !1, n)
        }, o.prototype.writeDoubleLE = function(e, t, n) {
            return z(this, e, t, !0, n)
        }, o.prototype.writeDoubleBE = function(e, t, n) {
            return z(this, e, t, !1, n)
        }, o.prototype.copy = function(e, t, n, r) {
            if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
            if (0 === e.length || 0 === this.length) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
            if (r < 0) throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
            var i, a = r - n;
            if (this === e && n < t && t < r)
                for (i = a - 1; i >= 0; --i) e[i + t] = this[i + n];
            else if (a < 1e3 || !o.TYPED_ARRAY_SUPPORT)
                for (i = 0; i < a; ++i) e[i + t] = this[i + n];
            else Uint8Array.prototype.set.call(e, this.subarray(n, n + a), t);
            return a
        }, o.prototype.fill = function(e, t, n, r) {
            if ("string" == typeof e) {
                if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
                    var i = e.charCodeAt(0);
                    i < 256 && (e = i)
                }
                if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !o.isEncoding(r)) throw new TypeError("Unknown encoding: " + r)
            } else "number" == typeof e && (e &= 255);
            if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
            if (n <= t) return this;
            t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0);
            var a;
            if ("number" == typeof e)
                for (a = t; a < n; ++a) this[a] = e;
            else {
                var s = o.isBuffer(e) ? e : G(new o(e, r).toString()),
                    c = s.length;
                for (a = 0; a < n - t; ++a) this[a + t] = s[a % c]
            }
            return this
        };
        var ee = /[^+\/0-9A-Za-z-_]/g
    }).call(t, n(7))
}, function(e, t) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || Function("return this")() || (0, eval)("this")
    } catch (e) {
        "object" == typeof window && (n = window)
    }
    e.exports = n
}, function(e, t) {
    function n() {
        for (var e = {}, t = 0; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n) r.call(n, i) && (e[i] = n[i])
        }
        return e
    }
    e.exports = n;
    var r = Object.prototype.hasOwnProperty
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(0),
        o = n(4),
        a = n(2),
        s = n(5),
        c = (n.n(s), this && this.__extends || function() {
            var e = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(e, t) {
                e.__proto__ = t
            } || function(e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            };
            return function(t, n) {
                function r() {
                    this.constructor = t
                }
                e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
            }
        }()),
        l = o.a.Builder;
    ! function(e) {
        var t = function() {
            function e(e, t, n, r) {
                this.asDropTargetId = null, this.asDropTargetUniqueId = null, this.mesh = e, e = e.clone(), e.position.set(0, 0, 0), e.rotation.set(0, 0, 0);
                var o = (new i.Box3).setFromObject(e);
                this.localBoundingBox = new i.Box2(new i.Vector2(o.min.x, o.min.y), new i.Vector2(o.max.x, o.max.y)), this.grid = t, this.asDropTargetId = n, this.asDropTargetUniqueId = r
            }
            return e
        }();
        e.IntersectableMesh = t;
        var n = function(e) {
            function t(t, n, r, o, s, c) {
                var h = this,
                    u = new i.Object3D;
                u.position.copy(t.position), u.rotation.copy(t.rotation), u.name = t.name, t.name += " inner", t.position.set(0, 0, 0), t.rotation.set(0, 0, 0), t.parent && t.parent.add(u), u.add(t);
                var d = t.clone(),
                    p = r || (new i.Box3).setFromObject(d),
                    f = (p.getSize(), [new i.Vector2(p.min.x, p.min.y), new i.Vector2(p.min.x, p.max.y), new i.Vector2(p.max.x, p.max.y), new i.Vector2(p.max.x, p.min.y)]),
                    m = new i.Shape(f),
                    g = new i.ShapeGeometry(m),
                    v = window.canDropMaterial || new i.MeshStandardMaterial({
                        color: 16777215,
                        transparent: !0,
                        opacity: .5,
                        map: (new i.TextureLoader).load(Object(a.c)("textures/uv_grid.html"), function(e) {
                            e.repeat.setScalar(.01), e.wrapS = e.wrapT = i.RepeatWrapping
                        })
                    });
                window.canDropMaterial = v;
                var y = new i.Mesh(g, v);
                return new l(2, null).remapUV(y), y.position.z += 3, u.add(y), h = e.call(this, y, o, s, c) || this, y.visible = !1, h.object = u, h.dropTargetId = n, h
            }
            return c(t, e), Object.defineProperty(t.prototype, "name", {
                get: function() {
                    return this.object.name
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "intersectable", {
                get: function() {
                    return this
                },
                enumerable: !0,
                configurable: !0
            }), t
        }(t);
        e.IntersectableObject = n;
        var r = function() {
            function e(e, t, n) {
                if (!t) {
                    var r = e;
                    return this.localPoint = new i.Vector2(0, 0), this.quadrant = new i.Vector2(0, 0), this.floatingPosition = new i.Vector3(0, 0, .5), void(this.intersected = r)
                }
                var o = e;
                if (this.intersected = t.filter(function(e) {
                        return e.intersectable.mesh === o.object
                    })[0], this.intersected) {
                    var a = this.intersected.intersectable.mesh.worldToLocal(o.point);
                    this.localPoint = new i.Vector2(a.x, a.y);
                    var s = this.intersected.intersectable.localBoundingBox.getSize(),
                        c = new i.Vector2(0, 0);
                    a.x + 10 < -s.width / 4 ? c.x = -1 : a.x - 10 > s.width / 4 ? c.x = 1 : c.x = 0, a.y + 10 < -s.height / 4 ? c.y = -1 : a.y - 10 > s.height / 4 ? c.y = 1 : c.y = 0, this.quadrant = c, this.floatingPosition = n
                }
            }
            return e
        }();
        e.Intersection = r;
        var o = function() {
            function e(e) {
                this.camera = e, this.floatingObjects = this.rootObject.getObjectByName(t);
                var t = "floating objects";
                this.floatingObjects || (this.floatingObjects = new i.Object3D, this.floatingObjects.name = t, this.rootObject.add(this.floatingObjects)), this.rayCaster = new i.Raycaster
            }
            return Object.defineProperty(e.prototype, "camera", {
                get: function() {
                    return this._camera
                },
                set: function(e) {
                    if (this._camera !== e)
                        for (this._camera = e, this.rootObject = this.camera; this.rootObject.parent;) this.rootObject = this.rootObject.parent
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.intersectMouse = function(e, t) {
                var n = e.clientX / window.innerWidth * 2 - 1,
                    o = -e.clientY / window.innerHeight * 2 + 1;
                this.rayCaster.setFromCamera({
                    x: n,
                    y: o
                }, this.camera), this.rootObject.updateMatrixWorld(!1);
                var a = t.map(function(e) {
                        return e.intersectable.mesh
                    }),
                    s = a.map(function(e) {
                        return e.visible
                    });
                a.forEach(function(e) {
                    return e.visible = !0
                });
                var c = this.rayCaster.intersectObjects(a, !1);
                if (a.forEach(function(e, t) {
                        return e.visible = s[t]
                    }), 0 !== c.length) {
                    var l = new i.Vector3(n, o, .5);
                    return l.unproject(this.camera), c.length ? new r(c[0], t, l) : null
                }
            }, e.prototype.floatDraggableAtMousePosition = function(e, t) {
                if (e && e.intersected) {
                    var n = e.intersected;
                    n.shouldClone && (n = Object.assign({}, n, {
                        shouldClone: !1,
                        intersectable: {
                            mesh: n.intersectable.mesh.clone(),
                            localBoundingBox: n.intersectable.localBoundingBox,
                            object: n.intersectable.object.clone(),
                            dropTargetId: n.intersectable.dropTargetId
                        }
                    })), e.intersected = n;
                    var r = n.intersectable.object;
                    this.rootObject.updateMatrixWorld(!1), this.camera.updateMatrixWorld(!1);
                    var i = this.getFloatingPosition(t);
                    for (r.position.copy(i), r.rotation.setFromRotationMatrix(this.camera.matrix); this.floatingObjects.children.length;) this.floatingObjects.remove(this.floatingObjects.children[0]);
                    return r.scale.setScalar(n.screenScale), this.floatingObjects.add(r), e
                }
            }, e.adjustElementPosition = function(e, t, n) {
                function r(e, t, n, r) {
                    return t <= 0 && (t += r), n <= 0 && (n += r), Math.min(n, Math.max(t, e))
                }
                var o = e.getCenter(),
                    a = e.getSize(),
                    s = t.intersectable.localBoundingBox.clone();
                if (t.grid) {
                    var c = t.grid.filter(function(e) {
                        return e.containsPoint(o)
                    });
                    if (0 === c.length) {
                        var l = t.grid.map(function(e) {
                                return e.distanceToPoint(o)
                            }),
                            h = l.reduce(function(e, t, n) {
                                return e.d < t ? {
                                    i: n,
                                    d: t
                                } : e
                            }, {
                                i: 0,
                                d: l[0]
                            }).i;
                        c = [t.grid[h]]
                    }
                    s = c[0].clone()
                }
                var u = s.getSize();
                return a.height = r(a.height, n.minHeight, n.maxHeight, u.height), a.width = r(a.width, n.minWidth, n.maxWidth, u.width), s.expandByVector(a.clone().divideScalar(-2)), s.isEmpty() ? s.getCenter(o) : s.clampPoint(o, o), (new i.Box2).setFromCenterAndSize(o, a)
            }, e.prototype.generateQuickGuid = function() {
                return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
            }, e.prototype.attachDraggableToDropTarget = function(t, n) {
                for (; this.floatingObjects.children.length;) this.floatingObjects.remove(this.floatingObjects.children[0]);
                if (!n || !n.intersected) return null;
                var r = t.intersected.intersectable,
                    o = n.localPoint.clone().sub(t.localPoint),
                    a = t.intersected.originalBoundingBox.getSize(),
                    s = t.intersected.originalBoundingBox.getCenter();
                n.intersected.intersectable.mesh.parent.add(r.object), r.object.scale.copy(t.intersected.originalScale);
                var c = o.sub(s),
                    l = (new i.Box2).setFromCenterAndSize(s, a),
                    h = new i.Vector2(t.intersected.width, t.intersected.height),
                    u = (n.intersected.intersectable.localBoundingBox.getSize(), a.clone().sub(h));
                switch (t.intersected.maxWidth === t.intersected.minWidth && t.intersected.width === t.intersected.minWidth && (t.quadrant.x = 0), t.intersected.maxHeight === t.intersected.minHeight && t.intersected.height === t.intersected.minHeight && (t.quadrant.y = 0), t.quadrant.x) {
                    case -1:
                        l.min.x += c.x, l.max.x - l.min.x + u.width;
                        break;
                    case 1:
                        l.max.x += c.x, l.max.x - l.min.x + u.width;
                        break;
                    case 0:
                        l.min.x += c.x, l.max.x += c.x
                }
                switch (t.quadrant.y) {
                    case -1:
                        l.min.y += c.y, l.max.y - l.min.y + u.height;
                        break;
                    case 1:
                        l.max.y += c.y, l.max.y - l.min.y + u.height;
                        break;
                    case 0:
                        l.min.y += c.y, l.max.y += c.y
                }
                l.copy(e.adjustElementPosition(l, n.intersected, t.intersected)), l.getCenter(o);
                var d = l.getSize();
                return r.object.position.set(o.x, o.y, 5), r.localBoundingBox.min.x = -d.x / 2, r.localBoundingBox.max.x = d.x / 2, r.localBoundingBox.min.y = -d.y / 2, r.localBoundingBox.max.y = d.y / 2, r.object.scale.x = d.x / a.x, r.object.scale.y = d.y / a.y, r.object.rotation.set(0, 0, 0), {
                    droppableId: t.intersected.id,
                    dropTargetId: n.intersected.dropTargetId,
                    dropTargetName: n.intersected.name,
                    position: o.toArray(),
                    rotation: [0, 0, 0],
                    intersectable: t.intersected.intersectable,
                    allowedDropTargets: t.intersected.allowedDropTargets,
                    elementId: t.intersected.elementId,
                    extendDropArea: t.intersected.extendDropArea,
                    id: t.intersected.id,
                    localBoundingBox: r.localBoundingBox,
                    originalScale: t.intersected.originalScale,
                    shouldClone: !1,
                    screenScale: t.intersected.screenScale,
                    screenPosition: t.intersected.screenPosition,
                    minWidth: t.intersected.minWidth,
                    maxWidth: t.intersected.maxWidth,
                    width: d.width,
                    height: d.height,
                    minHeight: t.intersected.minHeight,
                    maxHeight: t.intersected.maxHeight,
                    originalBoundingBox: t.intersected.originalBoundingBox,
                    opts: t.intersected.opts,
                    windowOpts: t.intersected.windowOpts,
                    float: !!t.intersected.float,
                    grid: n.intersected.grid,
                    useMaterialFromDropTarget: t.intersected.useMaterialFromDropTarget,
                    asDropTargetId: t.intersected.asDropTargetId,
                    asDropTargetUniqueId: t.intersected.asDropTargetUniqueId || this.generateQuickGuid(),
                    droppedOnUniqueId: n.intersected.asDropTargetUniqueId
                }
            }, e.prototype.getFloatingPosition = function(e) {
                var t = e.clientX / window.innerWidth * 2 - 1,
                    n = -e.clientY / window.innerHeight * 2 + 1,
                    r = new i.Vector3(t, n, .5);
                return r = r.unproject(this.camera)
            }, e
        }();
        e.Intersector = o;
        var s = function() {
            function e(e) {
                this.dropped = [], this.dropTargets = [], this.draggables = [], this.activeDropTargetIds = [], this.emitEvent = function(e) {}, this.intersector = e
            }
            return e.prototype.addEventListeners = function(e, t) {
                var n = this,
                    r = ["mousedown", "mousemove", "mouseup", "dragover", "drop", "mouseleave"].map(function(r) {
                        var i = function(r) {
                            n.activeDropTargetIds.length && r.target === e && (n.processMouseEvent(r), t.enabled = !(n.draggableIntersection && n.draggableIntersection.intersected), window.env.camera.isOrthographicCamera && (t.enableRotate = !1))
                        };
                        return e.addEventListener(r, i), {
                            evt: r,
                            handler: i
                        }
                    }),
                    i = ["touchstart", "touchmove", "touchend"].map(function(r) {
                        var i = {
                                clientX: 0,
                                clientY: 0,
                                preventDefault: function() {},
                                target: e,
                                type: "unknown"
                            },
                            o = function(r) {
                                n.activeDropTargetIds.length && r.target === e && ("touchend" !== r.type ? i = {
                                    type: {
                                        touchstart: "mousedown",
                                        touchmove: "mousemove"
                                    }[r.type],
                                    clientX: r.touches[0].clientX,
                                    clientY: r.touches[0].clientY,
                                    preventDefault: function() {
                                        return r.preventDefault()
                                    },
                                    target: r.target
                                } : (i.type = "mouseup", i.preventDefault = function() {
                                    return r.preventDefault()
                                }), n.processMouseEvent(i), t.enabled = !(n.draggableIntersection && n.draggableIntersection.intersected), window.env.camera.isOrthographicCamera && (t.enableRotate = !1))
                            };
                        return e.addEventListener(r, o), {
                            evt: r,
                            handler: o
                        }
                    });
                return r = r.concat(i),
                    function() {
                        return r.forEach(function(t) {
                            return e.removeEventListener(t.evt, t.handler)
                        })
                    }
            }, Object.defineProperty(e.prototype, "activeDraggables", {
                get: function() {
                    var e = this;
                    return this.draggables.concat(this.dropped).filter(function(t) {
                        return t.allowedDropTargets === [] || t.allowedDropTargets.some(function(t) {
                            return e.activeDropTargetIds.indexOf(t) > -1
                        })
                    })
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "activeDropTargets", {
                get: function() {
                    var e = this;
                    return this.dropTargets.filter(function(t) {
                        return e.draggableIntersection.intersected.allowedDropTargets.indexOf(t.dropTargetId) > -1
                    })
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.beginDrag = function(e, t) {
                var n = this.draggables.filter(function(t) {
                    return t.elementId == e
                })[0];
                this.draggableIntersection = new r(n, null, null), this.draggableIntersection = this.intersector.floatDraggableAtMousePosition(this.draggableIntersection, t), this.targetIntersection = null, this.currentDropped = null
            }, e.prototype.processMouseEvent = function(e) {
                var t = this;
                if (this.activeDropTargetIds.length) {
                    switch (this.intersector.camera = window.env.camera, e.preventDefault(), e.type) {
                        case "mousedown":
                            if (this.draggableIntersection) return void e.preventDefault();
                            this.draggableIntersection = this.intersector.intersectMouse(e, this.activeDraggables), this.draggableIntersection && (this.draggableIntersection = this.intersector.floatDraggableAtMousePosition(this.draggableIntersection, e), this.dropped = this.dropped.filter(function(e) {
                                return e.intersectable.mesh !== t.draggableIntersection.intersected.intersectable.mesh
                            }));
                        case "mousemove":
                        case "dragover":
                            this.draggableIntersection && (this.targetIntersection && this.targetIntersection.intersected.intersectable.mesh.parent.remove(this.draggableIntersection.intersected.intersectable.object), this.targetIntersection = this.intersector.intersectMouse(e, this.activeDropTargets), this.targetIntersection ? this.currentDropped = this.intersector.attachDraggableToDropTarget(this.draggableIntersection, this.targetIntersection) : (this.intersector.floatDraggableAtMousePosition(this.draggableIntersection, e), this.currentDropped = null));
                            break;
                        case "mouseup":
                        case "drop":
                        case "mouseleave":
                            if (!this.draggableIntersection) return;
                            this.currentDropped ? (this.dropped = this.dropped.filter(function(e) {
                                if (e.dropTargetId !== t.currentDropped.dropTargetId || e.dropTargetName !== t.currentDropped.dropTargetName) return !0;
                                var n = e.intersectable.localBoundingBox.clone().translate((new i.Vector2).fromArray(e.position)).intersect(t.currentDropped.localBoundingBox.clone().translate((new i.Vector2).fromArray(t.currentDropped.position)));
                                if (n.isEmpty()) return !0;
                                var r = n.getSize();
                                return r.width < 80 || r.height < 80
                            }), this.dropped.push(this.currentDropped)) : this.dropped = this.dropped.filter(function(e) {
                                return e.intersectable.mesh !== t.draggableIntersection.intersected.intersectable.mesh
                            });
                            var n = this.draggableIntersection.intersected.intersectable.object;
                            n.parent.remove(n), this.emitEvent(this.dragDropChangedEvent), this.draggableIntersection = null, this.targetIntersection = null
                    }
                    this.updateGUI(e)
                }
            }, e.prototype.updateGUI = function(e) {
                var t = this;
                this.draggableIntersection && (this.targetIntersection && this.targetIntersection.intersected.intersectable.mesh.parent.add(this.draggableIntersection.intersected.intersectable.object), this.dropTargets.forEach(function(e) {
                    e.intersectable.mesh.visible = !!t.draggableIntersection && t.draggableIntersection.intersected.allowedDropTargets.indexOf(e.dropTargetId) > -1
                }));
                var n = this.draggableIntersection || this.intersector.intersectMouse(e, this.activeDraggables);
                if (n) {
                    var r = n.intersected;
                    (r.maxWidth || r.width) === r.width && (r.minWidth || r.width) === r.width && (n.quadrant.x = 0), (r.maxHeight || r.height) === r.height && (r.minHeight || r.height) === r.height && (n.quadrant.y = 0);
                    var i = [
                        ["neswnwse-resize", "ns-resize", "nwse-resize"],
                        ["ew-resize", "move", "ew-resize"],
                        ["nwse-resize", "ns-resize", "nesw-resize"]
                    ];
                    e.target.style.cursor = i[n.quadrant.y + 1][n.quadrant.x + 1]
                } else e.target.style.cursor = ""
            }, Object.defineProperty(e.prototype, "dragDropChangedEvent", {
                get: function() {
                    var e = {
                        type: "mouseup",
                        dropped: []
                    };
                    return e.dropped = this.dropped.map(function(e) {
                        return Object.assign({}, e, {
                            intersectable: {
                                localBoundingBox: e.intersectable.localBoundingBox,
                                mesh: null
                            }
                        })
                    }), e
                },
                enumerable: !0,
                configurable: !0
            }), e
        }();
        e.DnDBehavior = s
    }(r || (r = {}))
}, , function(e, t, n) {
    var r = n(0);
    r.ColladaLoader = function() {
        function e(e, n, r, i) {
            var o = 0;
            if (document.implementation && document.implementation.createDocument) {
                var a = new XMLHttpRequest;
                a.onreadystatechange = function() {
                    4 === a.readyState ? 0 === a.status || 200 === a.status ? a.response ? (Fe = n, t(a.response, void 0, e)) : i ? i({
                        type: "error",
                        url: e
                    }) : console.error("ColladaLoader: Empty or non-existing file (" + e + ")") : i ? i({
                        type: "error",
                        url: e
                    }) : console.error("ColladaLoader: Couldn't load \"" + e + '" (' + a.status + ")") : 3 === a.readyState && r && (0 === o && (o = a.getResponseHeader("Content-Length")), r({
                        total: o,
                        loaded: a.responseText.length
                    }))
                }, a.open("GET.html", e, !0), a.send(null)
            } else alert("Don't know how to parse XML!")
        }

        function t(e, t, n) {
            if (Be = (new DOMParser).parseFromString(e, "text/xml"), t = t || Fe, void 0 !== n) {
                var l = n.split("https://productconfigurator.virtualsaleslab.com/");
                l.pop(), ke = (l.length < 1 ? "." : l.join("https://productconfigurator.virtualsaleslab.com/")) + "/"
            }
            i(), we(), je = o("library_images image", A, "image"), We = o("library_materials material", X, "material"), $e = o("library_effects effect", K, "effect"), Ge = o("library_geometries geometry", B, "geometry"), Xe = o("library_cameras camera", ie, "camera"), qe = o("library_lights light", ae, "light"), Ve = o("library_controllers controller", P, "controller"), He = o("library_animations animation", ee, "animation"), Ie = o("library_visual_scenes visual_scene", R, "visual_scene"), Oe = o("library_kinematics_models kinematics_model", ce, "kinematics_model"), De = [], Ne = [], Pe = a(), Ue = new r.Group;
            for (var h = 0; h < Pe.nodes.length; h++) Ue.add(y(Pe.nodes[h]));
            Ue.scale.multiplyScalar(Je), c(), Ce = s(), v();
            var u = {
                scene: Ue,
                morphs: De,
                skins: Ne,
                animations: Le,
                kinematics: Re,
                dae: {
                    images: je,
                    materials: We,
                    cameras: Xe,
                    lights: qe,
                    effects: $e,
                    geometries: Ge,
                    controllers: Ve,
                    animations: He,
                    visualScenes: Ie,
                    visualScene: Pe,
                    scene: Pe,
                    kinematicsModels: Oe,
                    kinematicsModel: Ce
                }
            };
            return t && t(u), u
        }

        function n(e) {
            Ye = e
        }

        function i() {
            var e = Be.querySelectorAll("asset"),
                t = e[0];
            if (t && t.childNodes)
                for (var n = 0; n < t.childNodes.length; n++) {
                    var r = t.childNodes[n];
                    switch (r.nodeName) {
                        case "unit":
                            var i = r.getAttribute("meter");
                            i && (Je = parseFloat(i));
                            break;
                        case "up_axis":
                            Ke = r.textContent.charAt(0)
                    }
                }
        }

        function o(e, t, n) {
            for (var r = Be.querySelectorAll(e), i = {}, o = 0, a = r.length, s = 0; s < a; s++) {
                var c = r[s],
                    l = (new t).parse(c);
                l.id && 0 !== l.id.length || (l.id = n + o++), i[l.id] = l
            }
            return i
        }

        function a() {
            var e = Be.querySelectorAll("scene instance_visual_scene")[0];
            if (e) {
                var t = e.getAttribute("url").replace(/^#/, "");
                return Ie[t.length > 0 ? t : "visual_scene0"]
            }
            return null
        }

        function s() {
            var e = Be.querySelectorAll("instance_kinematics_model")[0];
            if (e) {
                var t = e.getAttribute("url").replace(/^#/, "");
                return Oe[t.length > 0 ? t : "kinematics_model0"]
            }
            return null
        }

        function c() {
            Le = [], l(Ue)
        }

        function l(e) {
            var t = Pe.getChildById(e.colladaId, !0),
                n = null;
            if (t && t.keys) {
                n = {
                    fps: 60,
                    hierarchy: [{
                        node: t,
                        keys: t.keys,
                        sids: t.sids
                    }],
                    node: e,
                    name: "animation_" + e.name,
                    length: 0
                }, Le.push(n);
                for (var r = 0, i = t.keys.length; r < i; r++) n.length = Math.max(n.length, t.keys[r].time)
            } else n = {
                hierarchy: [{
                    keys: [],
                    sids: []
                }]
            };
            for (var r = 0, i = e.children.length; r < i; r++)
                for (var o = l(e.children[r]), a = 0, s = o.hierarchy.length; a < s; a++) n.hierarchy.push({
                    keys: [],
                    sids: []
                });
            return n
        }

        function h() {
            var e, t = 1e6,
                n = -t,
                r = 0;
            for (var i in He) {
                var o = He[i];
                e = e || o.id;
                for (var a = 0; a < o.sampler.length; a++) {
                    var s = o.sampler[a];
                    s.create(), t = Math.min(t, s.startTime), n = Math.max(n, s.endTime), r = Math.max(r, s.input.length)
                }
            }
            return {
                start: t,
                end: n,
                frames: r,
                ID: e
            }
        }

        function u(e, t) {
            var n = t instanceof k ? Ve[t.url] : t;
            if (!n || !n.morph) return void console.log("could not find morph controller!");
            for (var r = n.morph, i = 0; i < r.targets.length; i++) {
                var o = r.targets[i],
                    a = Ge[o];
                if (a.mesh && a.mesh.primitives && a.mesh.primitives.length) {
                    var s = a.mesh.primitives[0].geometry;
                    s.vertices.length === e.vertices.length && e.morphTargets.push({
                        name: "target_1",
                        vertices: s.vertices
                    })
                }
            }
            e.morphTargets.push({
                name: "target_Z",
                vertices: e.vertices
            })
        }

        function d(e, t, n, i) {
            if (e.world = e.world || new r.Matrix4, e.localworld = e.localworld || new r.Matrix4, e.world.copy(e.matrix), e.localworld.copy(e.matrix), e.channels && e.channels.length) {
                var o = e.channels[0],
                    a = o.sampler.output[n];
                a instanceof r.Matrix4 && (e.world.copy(a), e.localworld.copy(a), 0 === n && e.matrix.copy(a))
            }
            i && e.world.multiplyMatrices(i, e.world), t.push(e);
            for (var s = 0; s < e.nodes.length; s++) d(e.nodes[s], t, n, e.world)
        }

        function p(e, t) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n],
                    o = -1;
                if ("JOINT" == i.type) {
                    for (var a = 0; a < t.joints.length; a++)
                        if (i.sid === t.joints[a]) {
                            o = a;
                            break
                        }
                    if (o >= 0) {
                        var s = t.invBindMatrices[o];
                        i.invBindMatrix = s, i.skinningMatrix = new r.Matrix4, i.skinningMatrix.multiplyMatrices(i.world, s), i.animatrix = new r.Matrix4, i.animatrix.copy(i.localworld), i.weights = [];
                        for (var a = 0; a < t.weights.length; a++)
                            for (var c = 0; c < t.weights[a].length; c++) {
                                var l = t.weights[a][c];
                                l.joint === o && i.weights.push(l)
                            }
                    } else console.warn("ColladaLoader: Could not find joint '" + i.sid + "'."), i.skinningMatrix = new r.Matrix4, i.weights = []
                }
            }
        }

        function f(e) {
            var t = [],
                n = function(e, t, i) {
                    var o = {};
                    o.name = t.sid, o.parent = e, o.matrix = t.matrix;
                    var a = [new r.Vector3, new r.Quaternion, new r.Vector3];
                    o.matrix.decompose(a[0], a[1], a[2]), o.pos = [a[0].x, a[0].y, a[0].z], o.scl = [a[2].x, a[2].y, a[2].z], o.rotq = [a[1].x, a[1].y, a[1].z, a[1].w], i.push(o);
                    for (var s in t.nodes) n(t.sid, t.nodes[s], i)
                };
            return n(-1, e, t), t
        }

        function m(e, t, n) {
            var i = [];
            d(t, i, -1), p(i, n.skin);
            for (var o = new r.Vector3, a = [], s = 0; s < e.vertices.length; s++) a.push(new r.Vector3);
            for (s = 0; s < i.length; s++)
                if ("JOINT" == i[s].type)
                    for (var c = 0; c < i[s].weights.length; c++) {
                        var l = i[s].weights[c],
                            h = l.index,
                            u = l.weight,
                            f = e.vertices[h],
                            m = a[h];
                        o.x = f.x, o.y = f.y, o.z = f.z, o.applyMatrix4(i[s].skinningMatrix), m.x += o.x * u, m.y += o.y * u, m.z += o.z * u
                    }
                for (var s = 0; s < e.vertices.length; s++) e.vertices[s] = a[s]
        }

        function g(e, t, n) {
            var i = Ve[t.url];
            if (n = void 0 !== n ? n : 40, !i || !i.skin) return void console.log("ColladaLoader: Could not find skin controller.");
            if (!t.skeleton || !t.skeleton.length) return void console.log("ColladaLoader: Could not find the skeleton for the skin. ");
            for (var o = h(), a = Pe.getChildById(t.skeleton[0], !0) || Pe.getChildBySid(t.skeleton[0], !0), s = f(a), c = i.skin.joints, l = [], u = 0; u < c.length; u++)
                for (var g = 0; g < s.length; g++) s[g].name === c[u] && (l[u] = s[g]);
            for (var u = 0; u < l.length; u++)
                for (var g = 0; g < l.length; g++) l[u].parent === l[g].name && (l[u].parent = g);
            var u, g, v;
            new r.Vector3;
            for (u = 0; u < e.vertices.length; u++) e.vertices[u].applyMatrix4(i.skin.bindShapeMatrix);
            for (var y = [], b = [], x = i.skin.weights, u = 0; u < x.length; u++) {
                var w = new r.Vector4(x[u][0] ? x[u][0].joint : 0, x[u][1] ? x[u][1].joint : 0, x[u][2] ? x[u][2].joint : 0, x[u][3] ? x[u][3].joint : 0),
                    v = new r.Vector4(x[u][0] ? x[u][0].weight : 0, x[u][1] ? x[u][1].weight : 0, x[u][2] ? x[u][2].weight : 0, x[u][3] ? x[u][3].weight : 0);
                y.push(w), b.push(v)
            }
            e.skinIndices = y, e.skinWeights = b, e.bones = l;
            for (var _ = {
                    name: o.ID,
                    fps: 30,
                    length: o.frames / 30,
                    hierarchy: []
                }, g = 0; g < l.length; g++) _.hierarchy.push({
                parent: l[g].parent,
                name: l[g].name,
                keys: []
            });
            for (console.log("ColladaLoader:", o.ID + " has " + l.length + " bones."), m(e, a, i), n = 0; n < o.frames; n++) {
                var M = [];
                d(a, M, n), p(M, i.skin);
                for (var u = 0; u < M.length; u++)
                    for (var g = 0; g < _.hierarchy.length; g++)
                        if (_.hierarchy[g].name === M[u].sid) {
                            var E = {};
                            E.time = n / 30, E.matrix = M[u].animatrix, 0 === n && (M[u].matrix = E.matrix);
                            var T = [new r.Vector3, new r.Quaternion, new r.Vector3];
                            E.matrix.decompose(T[0], T[1], T[2]), E.pos = [T[0].x, T[0].y, T[0].z], E.scl = [T[2].x, T[2].y, T[2].z], E.rot = T[1], _.hierarchy[g].keys.push(E)
                        }
                e.animation = _
            }
        }

        function v() {
            if (Ce && 0 === Ce.joints.length) return void(Re = void 0);
            var e = {};
            Re = {
                joints: Ce && Ce.joints,
                getJointValue: function(t) {
                    var n = e[t];
                    if (n) return n.position;
                    console.log("getJointValue: joint " + t + " doesn't exist")
                },
                setJointValue: function(t, i) {
                    var o = e[t];
                    if (o) {
                        var a = o.joint;
                        if (i > a.limits.max || i < a.limits.min) console.log("setJointValue: joint " + t + " value " + i + " outside of limits (min: " + a.limits.min + ", max: " + a.limits.max + ")");
                        else if (a.static) console.log("setJointValue: joint " + t + " is static");
                        else {
                            var s = o.node,
                                c = a.axis,
                                l = o.transforms,
                                h = new r.Matrix4,
                                u = new r.Matrix4;
                            for (n = 0; n < l.length; n++) {
                                var d = l[n];
                                if (d.sid && -1 !== d.sid.indexOf("joint" + t)) switch (a.type) {
                                    case "revolute":
                                        h.multiply(u.makeRotationAxis(c, r.Math.degToRad(i)));
                                        break;
                                    case "prismatic":
                                        h.multiply(u.makeTranslation(c.x * i, c.y * i, c.z * i));
                                        break;
                                    default:
                                        console.warn("setJointValue: unknown joint type: " + a.type)
                                } else switch (d.type) {
                                    case "matrix":
                                        h.multiply(d.obj);
                                        break;
                                    case "translate":
                                        h.multiply(u.makeTranslation(d.obj.x, d.obj.y, d.obj.z));
                                        break;
                                    case "rotate":
                                        h.multiply(u.makeRotationAxis(d.obj, d.angle))
                                }
                            }
                            var p = h.elements,
                                f = Array.prototype.slice.call(p),
                                m = [f[0], f[4], f[8], f[12], f[1], f[5], f[9], f[13], f[2], f[6], f[10], f[14], f[3], f[7], f[11], f[15]];
                            s.matrix.set.apply(s.matrix, m), s.matrix.decompose(s.position, s.quaternion, s.scale), e[t].position = i
                        }
                    } else console.log("setJointValue: joint " + t + " doesn't exist")
                }
            };
            var t = Be.querySelector("scene instance_kinematics_scene");
            if (t)
                for (var n = 0; n < t.childNodes.length; n++) {
                    var i = t.childNodes[n];
                    if (1 == i.nodeType) switch (i.nodeName) {
                        case "bind_joint_axis":
                            var o = i.getAttribute("target").split("https://productconfigurator.virtualsaleslab.com/").pop(),
                                a = i.querySelector("axis param").textContent,
                                s = parseInt(a.split("joint").pop().split(".")[0]),
                                c = Be.querySelector('[sid="' + o + '"]');
                            if (c) {
                                var l = c.parentElement;
                                ! function(t, n) {
                                    var r = n.getAttribute("id"),
                                        i = Pe.getChildById(r, !0),
                                        o = Ce.joints[t];
                                    Ue.traverse(function(n) {
                                        n.colladaId == r && (e[t] = {
                                            node: n,
                                            transforms: i.transforms,
                                            joint: o,
                                            position: o.zeroPosition
                                        })
                                    })
                                }(s, l)
                            }
                    }
                }
        }

        function y(e, t) {
            var n, i, o, a, s = new r.Object3D;
            for (o = 0; o < e.controllers.length; o++) {
                var c = Ve[e.controllers[o].url];
                switch (c.type) {
                    case "skin":
                        if (Ge[c.skin.source]) {
                            var l = new N;
                            l.url = c.skin.source, l.instance_material = e.controllers[o].instance_material, e.geometries.push(l), !0, n = e.controllers[o]
                        } else if (Ve[c.skin.source]) {
                            var h = Ve[c.skin.source];
                            if (i = h, h.morph && Ge[h.morph.source]) {
                                var l = new N;
                                l.url = h.morph.source, l.instance_material = e.controllers[o].instance_material, e.geometries.push(l)
                            }
                        }
                        break;
                    case "morph":
                        if (Ge[c.morph.source]) {
                            var l = new N;
                            l.url = c.morph.source, l.instance_material = e.controllers[o].instance_material, e.geometries.push(l), i = e.controllers[o]
                        }
                        console.log("ColladaLoader: Morph-controller partially supported.")
                }
            }
            var d = {};
            for (o = 0; o < e.geometries.length; o++) {
                var p, f = e.geometries[o],
                    m = f.instance_material,
                    v = Ge[f.url],
                    b = {},
                    x = [],
                    w = 0;
                if (v) {
                    if (!v.mesh || !v.mesh.primitives) continue;
                    if (0 === s.name.length && (s.name = v.id), m)
                        for (a = 0; a < m.length; a++) {
                            var _ = m[a],
                                M = We[_.target],
                                E = M.instance_effect.url,
                                T = $e[E].shader,
                                S = T.material;
                            if (v.doubleSided) {
                                if (!(_.symbol in d)) {
                                    var A = S.clone();
                                    A.side = r.DoubleSide, d[_.symbol] = A
                                }
                                S = d[_.symbol]
                            }
                            S.opacity = S.opacity ? S.opacity : 1, b[_.symbol] = w, x.push(S), p = S, p.name = null === M.name || "" === M.name ? M.id : M.name, w++
                        }
                    var P, C = p || new r.MeshLambertMaterial({
                            color: 14540253,
                            side: v.doubleSided ? r.DoubleSide : r.FrontSide
                        }),
                        L = v.mesh.geometry3js;
                    if (w > 1)
                        for (C = new r.MultiMaterial(x), a = 0; a < L.faces.length; a++) {
                            var R = L.faces[a];
                            R.materialIndex = b[R.daeMaterial]
                        }
                    void 0 !== n ? (g(L, n), L.morphTargets.length > 0 ? (C.morphTargets = !0, C.skinning = !1) : (C.morphTargets = !1, C.skinning = !0), P = new r.SkinnedMesh(L, C, !1), P.name = "skin_" + Ne.length, Ne.push(P)) : void 0 !== i ? (u(L, i), C.morphTargets = !0, P = new r.Mesh(L, C), P.name = "morph_" + De.length, De.push(P)) : P = !0 === L.isLineStrip ? new r.Line(L) : new r.Mesh(L, C), s.add(P)
                }
            }
            for (o = 0; o < e.cameras.length; o++) {
                var I = e.cameras[o],
                    O = Xe[I.url],
                    k = new r.PerspectiveCamera(O.yfov, parseFloat(O.aspect_ratio), parseFloat(O.znear), parseFloat(O.zfar));
                s.add(k)
            }
            for (o = 0; o < e.lights.length; o++) {
                var D = null,
                    B = e.lights[o],
                    U = qe[B.url];
                if (U && U.technique) {
                    var F = U.color.getHex(),
                        z = U.intensity,
                        j = U.distance,
                        H = U.falloff_angle;
                    switch (U.technique) {
                        case "directional":
                            D = new r.DirectionalLight(F, z, j), D.position.set(0, 0, 1);
                            break;
                        case "point":
                            D = new r.PointLight(F, z, j);
                            break;
                        case "spot":
                            D = new r.SpotLight(F, z, j, H), D.position.set(0, 0, 1);
                            break;
                        case "ambient":
                            D = new r.AmbientLight(F)
                    }
                }
                D && s.add(D)
            }
            if (s.name = e.name || e.id || "", s.colladaId = e.id || "", s.layer = e.layer || "", s.matrix = e.matrix, s.matrix.decompose(s.position, s.quaternion, s.scale), Ze.centerGeometry && s.geometry) {
                var V = s.geometry.center();
                V.multiply(s.scale), V.applyQuaternion(s.quaternion), s.position.sub(V)
            }
            for (o = 0; o < e.nodes.length; o++) s.add(y(e.nodes[o], e));
            return s
        }

        function b(e) {
            for (var t = Be.querySelectorAll("library_nodes node"), n = 0; n < t.length; n++) {
                var r = t[n].attributes.getNamedItem("id");
                if (r && r.value === e) return t[n]
            }
        }

        function x(e) {
            var t = [],
                n = 1e6,
                r = -1e6;
            for (var i in He)
                for (var o = He[i], a = 0; a < o.channel.length; a++) {
                    var s = o.channel[a],
                        c = o.sampler[a],
                        i = s.target.split("https://productconfigurator.virtualsaleslab.com/")[0];
                    i == e.id && (c.create(), s.sampler = c, n = Math.min(n, c.startTime), r = Math.max(r, c.endTime), t.push(s))
                }
            return t.length && (e.startTime = n, e.endTime = r), t
        }

        function w(e) {
            if (e.channels && e.channels.length) {
                for (var t = [], n = [], r = 0, i = e.channels.length; r < i; r++) {
                    var o, a = e.channels[r],
                        s = a.fullSid,
                        c = a.sampler,
                        l = c.input,
                        h = e.getTransformBySid(a.sid);
                    if (a.arrIndices) {
                        o = [];
                        for (var u = 0, d = a.arrIndices.length; u < d; u++) o[u] = Se(a.arrIndices[u])
                    } else o = Ae(a.member);
                    if (h) {
                        -1 === n.indexOf(s) && n.push(s);
                        for (var u = 0, d = l.length; u < d; u++) {
                            var p = l[u],
                                f = c.getData(h.type, u, o),
                                m = _(t, p);
                            if (!m) {
                                m = new re(p);
                                var g = M(t, p);
                                t.splice(-1 === g ? t.length : g, 0, m)
                            }
                            m.addTarget(s, h, o, f)
                        }
                    } else console.log('Could not find transform "' + a.sid + '" in node ' + e.id)
                }
                for (var r = 0; r < n.length; r++)
                    for (var v = n[r], u = 0; u < t.length; u++) {
                        var m = t[u];
                        m.hasTarget(v) || E(t, m, u, v)
                    }
                e.keys = t, e.sids = n
            }
        }

        function _(e, t) {
            for (var n = null, r = 0, i = e.length; r < i && null === n; r++) {
                var o = e[r];
                if (o.time === t) n = o;
                else if (o.time > t) break
            }
            return n
        }

        function M(e, t) {
            for (var n = -1, r = 0, i = e.length; r < i && -1 === n; r++) {
                e[r].time >= t && (n = r)
            }
            return n
        }

        function E(e, t, n, r) {
            var i = S(e, r, n ? n - 1 : 0),
                o = T(e, r, n + 1);
            if (i && o) {
                var a, s = (t.time - i.time) / (o.time - i.time),
                    c = i.getTarget(r),
                    l = o.getTarget(r).data,
                    h = c.data;
                if ("matrix" === c.type) a = h;
                else if (h.length) {
                    a = [];
                    for (var u = 0; u < h.length; ++u) a[u] = h[u] + (l[u] - h[u]) * s
                } else a = h + (l - h) * s;
                t.addTarget(r, c.transform, c.member, a)
            }
        }

        function T(e, t, n) {
            for (; n < e.length; n++) {
                var r = e[n];
                if (r.hasTarget(t)) return r
            }
            return null
        }

        function S(e, t, n) {
            for (n = n >= 0 ? n : n + e.length; n >= 0; n--) {
                var r = e[n];
                if (r.hasTarget(t)) return r
            }
            return null
        }

        function A() {
            this.id = "", this.init_from = ""
        }

        function P() {
            this.id = "", this.name = "", this.type = "", this.skin = null, this.morph = null
        }

        function C() {
            this.method = null, this.source = null, this.targets = null, this.weights = null
        }

        function L() {
            this.source = "", this.bindShapeMatrix = null, this.invBindMatrices = [], this.joints = [], this.weights = []
        }

        function R() {
            this.id = "", this.name = "", this.nodes = [], this.scene = new r.Group
        }

        function I() {
            this.id = "", this.name = "", this.sid = "", this.nodes = [], this.controllers = [], this.transforms = [], this.geometries = [], this.channels = [], this.matrix = new r.Matrix4
        }

        function O() {
            this.sid = "", this.type = "", this.data = [], this.obj = null
        }

        function k() {
            this.url = "", this.skeleton = [], this.instance_material = []
        }

        function D() {
            this.symbol = "", this.target = ""
        }

        function N() {
            this.url = "", this.instance_material = []
        }

        function B() {
            this.id = "", this.mesh = null
        }

        function U(e) {
            this.geometry = e.id, this.primitives = [], this.vertices = null, this.geometry3js = null
        }

        function F() {
            this.material = "", this.count = 0, this.inputs = [], this.vcount = null, this.p = [], this.geometry = new r.Geometry
        }

        function z() {
            F.call(this), this.vcount = []
        }

        function j() {
            F.call(this), this.vcount = 1
        }

        function H() {
            F.call(this), this.vcount = 3
        }

        function V() {
            this.source = "", this.count = 0, this.stride = 0, this.params = []
        }

        function G() {
            this.input = {}
        }

        function W() {
            this.semantic = "", this.offset = 0, this.source = "", this.set = 0
        }

        function $(e) {
            this.id = e, this.type = null
        }

        function X() {
            this.id = "", this.name = "", this.instance_effect = null
        }

        function q() {
            this.color = new r.Color, this.color.setRGB(Math.random(), Math.random(), Math.random()), this.color.a = 1, this.texture = null, this.texcoord = null, this.texOpts = null
        }

        function Y(e, t) {
            this.type = e, this.effect = t, this.material = null
        }

        function Z(e) {
            this.effect = e, this.init_from = null, this.format = null
        }

        function J(e) {
            this.effect = e, this.source = null, this.wrap_s = null, this.wrap_t = null, this.minfilter = null, this.magfilter = null, this.mipfilter = null
        }

        function K() {
            this.id = "", this.name = "", this.shader = null, this.surface = {}, this.sampler = {}
        }

        function Q() {
            this.url = ""
        }

        function ee() {
            this.id = "", this.name = "", this.source = {}, this.sampler = [], this.channel = []
        }

        function te(e) {
            this.animation = e, this.source = "", this.target = "", this.fullSid = null, this.sid = null, this.dotSyntax = null, this.arrSyntax = null, this.arrIndices = null, this.member = null
        }

        function ne(e) {
            this.id = "", this.animation = e, this.inputs = [], this.input = null, this.output = null, this.strideOut = null, this.interpolation = null, this.startTime = null, this.endTime = null, this.duration = 0
        }

        function re(e) {
            this.targets = [], this.time = e
        }

        function ie() {
            this.id = "", this.name = "", this.technique = ""
        }

        function oe() {
            this.url = ""
        }

        function ae() {
            this.id = "", this.name = "", this.technique = ""
        }

        function se() {
            this.url = ""
        }

        function ce() {
            this.id = "", this.name = "", this.joints = [], this.links = []
        }

        function le() {
            this.sid = "", this.name = "", this.axis = new r.Vector3, this.limits = {
                min: 0,
                max: 0
            }, this.type = "", this.static = !1, this.zeroPosition = 0, this.middlePosition = 0
        }

        function he() {
            this.sid = "", this.name = "", this.transforms = [], this.attachments = []
        }

        function ue() {
            this.joint = "", this.transforms = [], this.links = []
        }

        function de(e) {
            var t = e.getAttribute("id");
            return void 0 != ze[t] ? ze[t] : (ze[t] = new $(t).parse(e), ze[t])
        }

        function pe(e) {
            for (var t = ge(e), n = [], r = 0, i = t.length; r < i; r++) n.push("true" === t[r] || "1" === t[r]);
            return n
        }

        function fe(e) {
            for (var t = ge(e), n = [], r = 0, i = t.length; r < i; r++) n.push(parseFloat(t[r]));
            return n
        }

        function me(e) {
            for (var t = ge(e), n = [], r = 0, i = t.length; r < i; r++) n.push(parseInt(t[r], 10));
            return n
        }

        function ge(e) {
            return e.length > 0 ? ve(e).split(/\s+/) : []
        }

        function ve(e) {
            return e.replace(/^\s+/, "").replace(/\s+$/, "")
        }

        function ye(e, t, n) {
            return e.hasAttribute(t) ? parseInt(e.getAttribute(t), 10) : n
        }

        function be(e, t) {
            (new r.ImageLoader).load(t, function(t) {
                e.image = t, e.needsUpdate = !0
            })
        }

        function xe(e, t) {
            e.doubleSided = !1;
            var n = t.querySelectorAll("extra double_sided")[0];
            n && n && 1 === parseInt(n.textContent, 10) && (e.doubleSided = !0)
        }

        function we() {
            if (!0 !== Ze.convertUpAxis || Ke === Ze.upAxis) Qe = null;
            else switch (Ke) {
                case "X":
                    Qe = "Y" === Ze.upAxis ? "XtoY" : "XtoZ";
                    break;
                case "Y":
                    Qe = "X" === Ze.upAxis ? "YtoX" : "YtoZ";
                    break;
                case "Z":
                    Qe = "X" === Ze.upAxis ? "ZtoX" : "ZtoY"
            }
        }

        function _e(e, t) {
            if (!0 === Ze.convertUpAxis && Ke !== Ze.upAxis) switch (Qe) {
                case "XtoY":
                    var n = e[0];
                    e[0] = t * e[1], e[1] = n;
                    break;
                case "XtoZ":
                    var n = e[2];
                    e[2] = e[1], e[1] = e[0], e[0] = n;
                    break;
                case "YtoX":
                    var n = e[0];
                    e[0] = e[1], e[1] = t * n;
                    break;
                case "YtoZ":
                    var n = e[1];
                    e[1] = t * e[2], e[2] = n;
                    break;
                case "ZtoX":
                    var n = e[0];
                    e[0] = e[1], e[1] = e[2], e[2] = n;
                    break;
                case "ZtoY":
                    var n = e[1];
                    e[1] = e[2], e[2] = t * n
            }
        }

        function Me(e, t) {
            if (!0 !== Ze.convertUpAxis || Ke === Ze.upAxis) return t;
            switch (e) {
                case "X":
                    t = "XtoY" === Qe ? -1 * t : t;
                    break;
                case "Y":
                    t = "YtoZ" === Qe || "YtoX" === Qe ? -1 * t : t;
                    break;
                case "Z":
                    t = "ZtoY" === Qe ? -1 * t : t
            }
            return t
        }

        function Ee(e, t) {
            var n = [e[t], e[t + 1], e[t + 2]];
            return _e(n, -1), new r.Vector3(n[0], n[1], n[2])
        }

        function Te(e) {
            if (Ze.convertUpAxis) {
                var t = [e[0], e[4], e[8]];
                _e(t, -1), e[0] = t[0], e[4] = t[1], e[8] = t[2], t = [e[1], e[5], e[9]], _e(t, -1), e[1] = t[0], e[5] = t[1], e[9] = t[2], t = [e[2], e[6], e[10]], _e(t, -1), e[2] = t[0], e[6] = t[1], e[10] = t[2], t = [e[0], e[1], e[2]], _e(t, -1), e[0] = t[0], e[1] = t[1], e[2] = t[2], t = [e[4], e[5], e[6]], _e(t, -1), e[4] = t[0], e[5] = t[1], e[6] = t[2], t = [e[8], e[9], e[10]], _e(t, -1), e[8] = t[0], e[9] = t[1], e[10] = t[2], t = [e[3], e[7], e[11]], _e(t, -1), e[3] = t[0], e[7] = t[1], e[11] = t[2]
            }
            return (new r.Matrix4).set(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
        }

        function Se(e) {
            if (e > -1 && e < 3) {
                var t = ["X", "Y", "Z"],
                    n = {
                        X: 0,
                        Y: 1,
                        Z: 2
                    };
                e = Ae(t[e]), e = n[e]
            }
            return e
        }

        function Ae(e) {
            if (Ze.convertUpAxis) switch (e) {
                case "X":
                    switch (Qe) {
                        case "XtoY":
                        case "XtoZ":
                        case "YtoX":
                            e = "Y";
                            break;
                        case "ZtoX":
                            e = "Z"
                    }
                    break;
                case "Y":
                    switch (Qe) {
                        case "XtoY":
                        case "YtoX":
                        case "ZtoX":
                            e = "X";
                            break;
                        case "XtoZ":
                        case "YtoZ":
                        case "ZtoY":
                            e = "Z"
                    }
                    break;
                case "Z":
                    switch (Qe) {
                        case "XtoZ":
                            e = "X";
                            break;
                        case "YtoZ":
                        case "ZtoX":
                        case "ZtoY":
                            e = "Y"
                    }
            }
            return e
        }
        var Pe, Ce, Le, Re, Ie, Oe, ke, De, Ne, Be = null,
            Ue = null,
            Fe = null,
            ze = {},
            je = {},
            He = {},
            Ve = {},
            Ge = {},
            We = {},
            $e = {},
            Xe = {},
            qe = {},
            Ye = r.SmoothShading,
            Ze = {
                centerGeometry: !1,
                convertUpAxis: !1,
                subdivideFaces: !0,
                upAxis: "Y",
                defaultEnvMap: null
            },
            Je = 1,
            Ke = "Y",
            Qe = null;
        return A.prototype.parse = function(e) {
            this.id = e.getAttribute("id");
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                "init_from" === n.nodeName && (this.init_from = n.textContent)
            }
            return this
        }, P.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name"), this.type = "none";
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "skin":
                        this.skin = (new L).parse(n), this.type = n.nodeName;
                        break;
                    case "morph":
                        this.morph = (new C).parse(n), this.type = n.nodeName
                }
            }
            return this
        }, C.prototype.parse = function(e) {
            var t, n = {},
                r = [];
            for (this.method = e.getAttribute("method"), this.source = e.getAttribute("source").replace(/^#/, ""), t = 0; t < e.childNodes.length; t++) {
                var i = e.childNodes[t];
                if (1 == i.nodeType) switch (i.nodeName) {
                    case "source":
                        var o = (new $).parse(i);
                        n[o.id] = o;
                        break;
                    case "targets":
                        r = this.parseInputs(i);
                        break;
                    default:
                        console.log(i.nodeName)
                }
            }
            for (t = 0; t < r.length; t++) {
                var a = r[t],
                    o = n[a.source];
                switch (a.semantic) {
                    case "MORPH_TARGET":
                        this.targets = o.read();
                        break;
                    case "MORPH_WEIGHT":
                        this.weights = o.read()
                }
            }
            return this
        }, C.prototype.parseInputs = function(e) {
            for (var t = [], n = 0; n < e.childNodes.length; n++) {
                var r = e.childNodes[n];
                if (1 == r.nodeType) switch (r.nodeName) {
                    case "input":
                        t.push((new W).parse(r))
                }
            }
            return t
        }, L.prototype.parse = function(e) {
            var t, n, r = {};
            this.source = e.getAttribute("source").replace(/^#/, ""), this.invBindMatrices = [], this.joints = [], this.weights = [];
            for (var i = 0; i < e.childNodes.length; i++) {
                var o = e.childNodes[i];
                if (1 == o.nodeType) switch (o.nodeName) {
                    case "bind_shape_matrix":
                        var a = fe(o.textContent);
                        this.bindShapeMatrix = Te(a);
                        break;
                    case "source":
                        var s = (new $).parse(o);
                        r[s.id] = s;
                        break;
                    case "joints":
                        t = o;
                        break;
                    case "vertex_weights":
                        n = o;
                        break;
                    default:
                        console.log(o.nodeName)
                }
            }
            return this.parseJoints(t, r), this.parseWeights(n, r), this
        }, L.prototype.parseJoints = function(e, t) {
            for (var n = 0; n < e.childNodes.length; n++) {
                var r = e.childNodes[n];
                if (1 == r.nodeType) switch (r.nodeName) {
                    case "input":
                        var i = (new W).parse(r),
                            o = t[i.source];
                        "JOINT" === i.semantic ? this.joints = o.read() : "INV_BIND_MATRIX" === i.semantic && (this.invBindMatrices = o.read())
                }
            }
        }, L.prototype.parseWeights = function(e, t) {
            for (var n, r, i = [], o = 0; o < e.childNodes.length; o++) {
                var a = e.childNodes[o];
                if (1 == a.nodeType) switch (a.nodeName) {
                    case "input":
                        i.push((new W).parse(a));
                        break;
                    case "v":
                        n = me(a.textContent);
                        break;
                    case "vcount":
                        r = me(a.textContent)
                }
            }
            for (var s = 0, o = 0; o < r.length; o++) {
                for (var c = r[o], l = [], h = 0; h < c; h++) {
                    for (var u = {}, d = 0; d < i.length; d++) {
                        var p = i[d],
                            f = n[s + p.offset];
                        switch (p.semantic) {
                            case "JOINT":
                                u.joint = f;
                                break;
                            case "WEIGHT":
                                u.weight = t[p.source].data[f]
                        }
                    }
                    l.push(u), s += i.length
                }
                for (var h = 0; h < l.length; h++) l[h].index = o;
                this.weights.push(l)
            }
        }, R.prototype.getChildById = function(e, t) {
            for (var n = 0; n < this.nodes.length; n++) {
                var r = this.nodes[n].getChildById(e, t);
                if (r) return r
            }
            return null
        }, R.prototype.getChildBySid = function(e, t) {
            for (var n = 0; n < this.nodes.length; n++) {
                var r = this.nodes[n].getChildBySid(e, t);
                if (r) return r
            }
            return null
        }, R.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name"), this.nodes = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "node":
                        this.nodes.push((new I).parse(n))
                }
            }
            return this
        }, I.prototype.getChannelForTransform = function(e) {
            for (var t = 0; t < this.channels.length; t++) {
                var n, r = this.channels[t],
                    i = r.target.split("https://productconfigurator.virtualsaleslab.com/"),
                    o = (i.shift(), i.shift()),
                    a = o.indexOf(".") >= 0,
                    s = o.indexOf("(") >= 0;
                if (a) i = o.split("."), o = i.shift(), i.shift();
                else if (s) {
                    n = o.split("("), o = n.shift();
                    for (var c = 0; c < n.length; c++) n[c] = parseInt(n[c].replace(/\)/, ""))
                }
                if (o === e) return r.info = {
                    sid: o,
                    dotSyntax: a,
                    arrSyntax: s,
                    arrIndices: n
                }, r
            }
            return null
        }, I.prototype.getChildById = function(e, t) {
            if (this.id === e) return this;
            if (t)
                for (var n = 0; n < this.nodes.length; n++) {
                    var r = this.nodes[n].getChildById(e, t);
                    if (r) return r
                }
            return null
        }, I.prototype.getChildBySid = function(e, t) {
            if (this.sid === e) return this;
            if (t)
                for (var n = 0; n < this.nodes.length; n++) {
                    var r = this.nodes[n].getChildBySid(e, t);
                    if (r) return r
                }
            return null
        }, I.prototype.getTransformBySid = function(e) {
            for (var t = 0; t < this.transforms.length; t++)
                if (this.transforms[t].sid === e) return this.transforms[t];
            return null
        }, I.prototype.parse = function(e) {
            var t;
            this.id = e.getAttribute("id"), this.sid = e.getAttribute("sid"), this.name = e.getAttribute("name"), this.type = e.getAttribute("type"), this.layer = e.getAttribute("layer"), this.type = "JOINT" === this.type ? this.type : "NODE", this.nodes = [], this.transforms = [], this.geometries = [], this.cameras = [], this.lights = [], this.controllers = [], this.matrix = new r.Matrix4;
            for (var n = 0; n < e.childNodes.length; n++) {
                var i = e.childNodes[n];
                if (1 == i.nodeType) switch (i.nodeName) {
                    case "node":
                        this.nodes.push((new I).parse(i));
                        break;
                    case "instance_camera":
                        this.cameras.push((new oe).parse(i));
                        break;
                    case "instance_controller":
                        this.controllers.push((new k).parse(i));
                        break;
                    case "instance_geometry":
                        this.geometries.push((new N).parse(i));
                        break;
                    case "instance_light":
                        this.lights.push((new se).parse(i));
                        break;
                    case "instance_node":
                        t = i.getAttribute("url").replace(/^#/, "");
                        var o = b(t);
                        o && this.nodes.push((new I).parse(o));
                        break;
                    case "rotate":
                    case "translate":
                    case "scale":
                    case "matrix":
                    case "lookat":
                    case "skew":
                        this.transforms.push((new O).parse(i));
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(i.nodeName)
                }
            }
            return this.channels = x(this), w(this), this.updateMatrix(), this
        }, I.prototype.updateMatrix = function() {
            this.matrix.identity();
            for (var e = 0; e < this.transforms.length; e++) this.transforms[e].apply(this.matrix)
        }, O.prototype.parse = function(e) {
            return this.sid = e.getAttribute("sid"), this.type = e.nodeName, this.data = fe(e.textContent), this.convert(), this
        }, O.prototype.convert = function() {
            switch (this.type) {
                case "matrix":
                    this.obj = Te(this.data);
                    break;
                case "rotate":
                    this.angle = r.Math.degToRad(this.data[3]);
                case "translate":
                    _e(this.data, -1), this.obj = new r.Vector3(this.data[0], this.data[1], this.data[2]);
                    break;
                case "scale":
                    _e(this.data, 1), this.obj = new r.Vector3(this.data[0], this.data[1], this.data[2]);
                    break;
                default:
                    console.log("Can not convert Transform of type " + this.type)
            }
        }, O.prototype.apply = function() {
            var e = new r.Matrix4;
            return function(t) {
                switch (this.type) {
                    case "matrix":
                        t.multiply(this.obj);
                        break;
                    case "translate":
                        t.multiply(e.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
                        break;
                    case "rotate":
                        t.multiply(e.makeRotationAxis(this.obj, this.angle));
                        break;
                    case "scale":
                        t.scale(this.obj)
                }
            }
        }(), O.prototype.update = function(e, t) {
            var n = ["X", "Y", "Z", "ANGLE"];
            switch (this.type) {
                case "matrix":
                    if (t)
                        if (1 === t.length) switch (t[0]) {
                            case 0:
                                this.obj.n11 = e[0], this.obj.n21 = e[1], this.obj.n31 = e[2], this.obj.n41 = e[3];
                                break;
                            case 1:
                                this.obj.n12 = e[0], this.obj.n22 = e[1], this.obj.n32 = e[2], this.obj.n42 = e[3];
                                break;
                            case 2:
                                this.obj.n13 = e[0], this.obj.n23 = e[1], this.obj.n33 = e[2], this.obj.n43 = e[3];
                                break;
                            case 3:
                                this.obj.n14 = e[0], this.obj.n24 = e[1], this.obj.n34 = e[2], this.obj.n44 = e[3]
                        } else if (2 === t.length) {
                            var i = "n" + (t[0] + 1) + (t[1] + 1);
                            this.obj[i] = e
                        } else console.log("Incorrect addressing of matrix in transform.");
                    else this.obj.copy(e);
                    break;
                case "translate":
                case "scale":
                    switch ("[object Array]" === Object.prototype.toString.call(t) && (t = n[t[0]]), t) {
                        case "X":
                            this.obj.x = e;
                            break;
                        case "Y":
                            this.obj.y = e;
                            break;
                        case "Z":
                            this.obj.z = e;
                            break;
                        default:
                            this.obj.x = e[0], this.obj.y = e[1], this.obj.z = e[2]
                    }
                    break;
                case "rotate":
                    switch ("[object Array]" === Object.prototype.toString.call(t) && (t = n[t[0]]), t) {
                        case "X":
                            this.obj.x = e;
                            break;
                        case "Y":
                            this.obj.y = e;
                            break;
                        case "Z":
                            this.obj.z = e;
                            break;
                        case "ANGLE":
                            this.angle = r.Math.degToRad(e);
                            break;
                        default:
                            this.obj.x = e[0], this.obj.y = e[1], this.obj.z = e[2], this.angle = r.Math.degToRad(e[3])
                    }
            }
        }, k.prototype.parse = function(e) {
            this.url = e.getAttribute("url").replace(/^#/, ""), this.skeleton = [], this.instance_material = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 === n.nodeType) switch (n.nodeName) {
                    case "skeleton":
                        this.skeleton.push(n.textContent.replace(/^#/, ""));
                        break;
                    case "bind_material":
                        for (var r = n.querySelectorAll("instance_material"), i = 0; i < r.length; i++) {
                            var o = r[i];
                            this.instance_material.push((new D).parse(o))
                        }
                }
            }
            return this
        }, D.prototype.parse = function(e) {
            return this.symbol = e.getAttribute("symbol"), this.target = e.getAttribute("target").replace(/^#/, ""), this
        }, N.prototype.parse = function(e) {
            this.url = e.getAttribute("url").replace(/^#/, ""), this.instance_material = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType && "bind_material" === n.nodeName) {
                    for (var r = n.querySelectorAll("instance_material"), i = 0; i < r.length; i++) {
                        var o = r[i];
                        this.instance_material.push((new D).parse(o))
                    }
                    break
                }
            }
            return this
        }, B.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), xe(this, e);
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "mesh":
                        this.mesh = new U(this).parse(n)
                }
            }
            return this
        }, U.prototype.parse = function(e) {
            this.primitives = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "source":
                        de(n);
                        break;
                    case "vertices":
                        this.vertices = (new G).parse(n);
                        break;
                    case "linestrips":
                        this.primitives.push((new j).parse(n));
                        break;
                    case "triangles":
                        this.primitives.push((new H).parse(n));
                        break;
                    case "polygons":
                        this.primitives.push((new F).parse(n));
                        break;
                    case "polylist":
                        this.primitives.push((new z).parse(n))
                }
            }
            if (this.geometry3js = new r.Geometry, null === this.vertices) return this;
            for (var i = ze[this.vertices.input.POSITION.source].data, t = 0; t < i.length; t += 3) this.geometry3js.vertices.push(Ee(i, t).clone());
            for (var t = 0; t < this.primitives.length; t++) {
                var o = this.primitives[t];
                o.setVertices(this.vertices), this.handlePrimitive(o, this.geometry3js)
            }
            return this.geometry3js.calcNormals && (this.geometry3js.computeVertexNormals(), delete this.geometry3js.calcNormals), this
        }, U.prototype.handlePrimitive = function(e, t) {
            if (e instanceof j) return void(t.isLineStrip = !0);
            var n, i, o, a, s, c, l, h = e.p,
                u = e.inputs,
                d = 0,
                p = 3,
                f = 0,
                m = [];
            for (n = 0; n < u.length; n++) {
                o = u[n];
                var g = o.offset + 1;
                switch (f = f < g ? g : f, o.semantic) {
                    case "TEXCOORD":
                        m.push(o.set)
                }
            }
            for (var v = 0; v < h.length; ++v)
                for (var y = h[v], b = 0; b < y.length;) {
                    var x = [],
                        w = [],
                        _ = null,
                        M = [];
                    for (p = e.vcount ? e.vcount.length ? e.vcount[d++] : e.vcount : y.length / f, n = 0; n < p; n++)
                        for (i = 0; i < u.length; i++) switch (o = u[i], c = ze[o.source], a = y[b + n * f + o.offset], l = c.accessor.params.length, s = a * l, o.semantic) {
                            case "VERTEX":
                                x.push(a);
                                break;
                            case "NORMAL":
                                w.push(Ee(c.data, s));
                                break;
                            case "TEXCOORD":
                                _ = _ || {}, void 0 === _[o.set] && (_[o.set] = []), _[o.set].push(new r.Vector2(c.data[s], c.data[s + 1]));
                                break;
                            case "COLOR":
                                M.push((new r.Color).setRGB(c.data[s], c.data[s + 1], c.data[s + 2]))
                        }
                    if (0 === w.length)
                        if (o = this.vertices.input.NORMAL) {
                            c = ze[o.source], l = c.accessor.params.length;
                            for (var E = 0, T = x.length; E < T; E++) w.push(Ee(c.data, x[E] * l))
                        } else t.calcNormals = !0;
                    if (!_ && (_ = {}, o = this.vertices.input.TEXCOORD)) {
                        m.push(o.set), c = ze[o.source], l = c.accessor.params.length;
                        for (var E = 0, T = x.length; E < T; E++) s = x[E] * l, void 0 === _[o.set] && (_[o.set] = []), _[o.set].push(new r.Vector2(c.data[s], 1 - c.data[s + 1]))
                    }
                    if (0 === M.length && (o = this.vertices.input.COLOR)) {
                        c = ze[o.source], l = c.accessor.params.length;
                        for (var E = 0, T = x.length; E < T; E++) s = x[E] * l, M.push((new r.Color).setRGB(c.data[s], c.data[s + 1], c.data[s + 2]))
                    }
                    var S, A, P = null,
                        C = [];
                    if (3 === p) C.push(new r.Face3(x[0], x[1], x[2], w, M.length ? M : new r.Color));
                    else if (4 === p) C.push(new r.Face3(x[0], x[1], x[3], w.length ? [w[0].clone(), w[1].clone(), w[3].clone()] : [], M.length ? [M[0], M[1], M[3]] : new r.Color)), C.push(new r.Face3(x[1], x[2], x[3], w.length ? [w[1].clone(), w[2].clone(), w[3].clone()] : [], M.length ? [M[1], M[2], M[3]] : new r.Color));
                    else if (p > 4 && Ze.subdivideFaces) {
                        var L = M.length ? M : new r.Color;
                        for (i = 1; i < p - 1;) C.push(new r.Face3(x[0], x[i], x[i + 1], w.length ? [w[0].clone(), w[i++].clone(), w[i].clone()] : [], L))
                    }
                    if (C.length)
                        for (var E = 0, T = C.length; E < T; E++)
                            for (P = C[E], P.daeMaterial = e.material, t.faces.push(P), i = 0; i < m.length; i++) S = _[m[i]], A = p > 4 ? [S[0], S[E + 1], S[E + 2]] : 4 === p ? 0 === E ? [S[0], S[1], S[3]] : [S[1].clone(), S[2], S[3].clone()] : [S[0], S[1], S[2]], void 0 === t.faceVertexUvs[i] && (t.faceVertexUvs[i] = []), t.faceVertexUvs[i].push(A);
                    else console.log("dropped face with vcount " + p + " for geometry with id: " + t.id);
                    b += f * p
                }
        }, F.prototype.setVertices = function(e) {
            for (var t = 0; t < this.inputs.length; t++) this.inputs[t].source === e.id && (this.inputs[t].source = e.input.POSITION.source)
        }, F.prototype.parse = function(e) {
            this.material = e.getAttribute("material"), this.count = ye(e, "count", 0);
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "input":
                        this.inputs.push((new W).parse(e.childNodes[t]));
                        break;
                    case "vcount":
                        this.vcount = me(n.textContent);
                        break;
                    case "p":
                        this.p.push(me(n.textContent));
                        break;
                    case "ph":
                        console.warn("polygon holes not yet supported!")
                }
            }
            return this
        }, z.prototype = Object.create(F.prototype), z.prototype.constructor = z, j.prototype = Object.create(F.prototype), j.prototype.constructor = j, H.prototype = Object.create(F.prototype), H.prototype.constructor = H, V.prototype.parse = function(e) {
            this.params = [], this.source = e.getAttribute("source"), this.count = ye(e, "count", 0), this.stride = ye(e, "stride", 0);
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if ("param" === n.nodeName) {
                    var r = {};
                    r.name = n.getAttribute("name"), r.type = n.getAttribute("type"), this.params.push(r)
                }
            }
            return this
        }, G.prototype.parse = function(e) {
            this.id = e.getAttribute("id");
            for (var t = 0; t < e.childNodes.length; t++)
                if ("input" === e.childNodes[t].nodeName) {
                    var n = (new W).parse(e.childNodes[t]);
                    this.input[n.semantic] = n
                }
            return this
        }, W.prototype.parse = function(e) {
            return this.semantic = e.getAttribute("semantic"), this.source = e.getAttribute("source").replace(/^#/, ""), this.set = ye(e, "set", -1), this.offset = ye(e, "offset", 0), "TEXCOORD" === this.semantic && this.set < 0 && (this.set = 0), this
        }, $.prototype.parse = function(e) {
            this.id = e.getAttribute("id");
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "bool_array":
                        this.data = pe(n.textContent), this.type = n.nodeName;
                        break;
                    case "float_array":
                        this.data = fe(n.textContent), this.type = n.nodeName;
                        break;
                    case "int_array":
                        this.data = me(n.textContent), this.type = n.nodeName;
                        break;
                    case "IDREF_array":
                    case "Name_array":
                        this.data = ge(n.textContent), this.type = n.nodeName;
                        break;
                    case "technique_common":
                        for (var r = 0; r < n.childNodes.length; r++)
                            if ("accessor" === n.childNodes[r].nodeName) {
                                this.accessor = (new V).parse(n.childNodes[r]);
                                break
                            }
                }
            }
            return this
        }, $.prototype.read = function() {
            var e = [],
                t = this.accessor.params[0];
            switch (t.type) {
                case "IDREF":
                case "Name":
                case "name":
                case "float":
                    return this.data;
                case "float4x4":
                    for (var n = 0; n < this.data.length; n += 16) {
                        var r = this.data.slice(n, n + 16),
                            i = Te(r);
                        e.push(i)
                    }
                    break;
                default:
                    console.log("ColladaLoader: Source: Read dont know how to read " + t.type + ".")
            }
            return e
        }, X.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name");
            for (var t = 0; t < e.childNodes.length; t++)
                if ("instance_effect" === e.childNodes[t].nodeName) {
                    this.instance_effect = (new Q).parse(e.childNodes[t]);
                    break
                }
            return this
        }, q.prototype.isColor = function() {
            return null === this.texture
        }, q.prototype.isTexture = function() {
            return null != this.texture
        }, q.prototype.parse = function(e) {
            "transparent" === e.nodeName && (this.opaque = e.getAttribute("opaque"));
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "color":
                        var i = fe(n.textContent);
                        this.color = new r.Color, this.color.setRGB(i[0], i[1], i[2]), this.color.a = i[3];
                        break;
                    case "texture":
                        this.texture = n.getAttribute("texture"), this.texcoord = n.getAttribute("texcoord"), this.texOpts = {
                            offsetU: 0,
                            offsetV: 0,
                            repeatU: 1,
                            repeatV: 1,
                            wrapU: 1,
                            wrapV: 1
                        }, this.parseTexture(n)
                }
            }
            return this
        }, q.prototype.parseTexture = function(e) {
            if (!e.childNodes) return this;
            e.childNodes[1] && "extra" === e.childNodes[1].nodeName && (e = e.childNodes[1], e.childNodes[1] && "technique" === e.childNodes[1].nodeName && (e = e.childNodes[1]));
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "offsetU":
                    case "offsetV":
                    case "repeatU":
                    case "repeatV":
                        this.texOpts[n.nodeName] = parseFloat(n.textContent);
                        break;
                    case "wrapU":
                    case "wrapV":
                        "TRUE" === n.textContent.toUpperCase() ? this.texOpts[n.nodeName] = 1 : this.texOpts[n.nodeName] = parseInt(n.textContent);
                        break;
                    default:
                        this.texOpts[n.nodeName] = n.textContent
                }
            }
            return this
        }, Y.prototype.parse = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "emission":
                    case "diffuse":
                    case "specular":
                    case "transparent":
                        this[n.nodeName] = (new q).parse(n);
                        break;
                    case "bump":
                        var r = n.getAttribute("bumptype");
                        r ? "heightfield" === r.toLowerCase() ? this.bump = (new q).parse(n) : "normalmap" === r.toLowerCase() ? this.normal = (new q).parse(n) : (console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + r + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'"), this.bump = (new q).parse(n)) : (console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'"), this.bump = (new q).parse(n));
                        break;
                    case "shininess":
                    case "reflectivity":
                    case "index_of_refraction":
                    case "transparency":
                        var i = n.querySelectorAll("float");
                        i.length > 0 && (this[n.nodeName] = parseFloat(i[0].textContent))
                }
            }
            return this.create(), this
        }, Y.prototype.create = function() {
            var e = {},
                t = !1;
            if (void 0 !== this.transparency && void 0 !== this.transparent) {
                var n = (this.transparent, (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency);
                n > 0 && (t = !0, e.transparent = !0, e.opacity = 1 - n)
            }
            var i = {
                diffuse: "map",
                ambient: "lightMap",
                specular: "specularMap",
                emission: "emissionMap",
                bump: "bumpMap",
                normal: "normalMap"
            };
            for (var o in this) switch (o) {
                case "ambient":
                case "emission":
                case "diffuse":
                case "specular":
                case "bump":
                case "normal":
                    var a = this[o];
                    if (a instanceof q)
                        if (a.isTexture()) {
                            var s = a.texture,
                                c = this.effect.sampler[s];
                            if (void 0 !== c && void 0 !== c.source) {
                                var l = this.effect.surface[c.source];
                                if (void 0 !== l) {
                                    var h = je[l.init_from];
                                    if (h) {
                                        var u, d = ke + h.init_from,
                                            p = r.Loader.Handlers.get(d);
                                        null !== p ? u = p.load(d) : (u = new r.Texture, be(u, d)), "MIRROR" === c.wrap_s ? u.wrapS = r.MirroredRepeatWrapping : "WRAP" === c.wrap_s || a.texOpts.wrapU ? u.wrapS = r.RepeatWrapping : u.wrapS = r.ClampToEdgeWrapping, "MIRROR" === c.wrap_t ? u.wrapT = r.MirroredRepeatWrapping : "WRAP" === c.wrap_t || a.texOpts.wrapV ? u.wrapT = r.RepeatWrapping : u.wrapT = r.ClampToEdgeWrapping, u.offset.x = a.texOpts.offsetU, u.offset.y = a.texOpts.offsetV, u.repeat.x = a.texOpts.repeatU, u.repeat.y = a.texOpts.repeatV, e[i[o]] = u, "emission" === o && (e.emissive = 16777215)
                                    }
                                }
                            }
                        } else "diffuse" !== o && t || ("emission" === o ? e.emissive = a.color.getHex() : e[o] = a.color.getHex());
                    break;
                case "shininess":
                    e[o] = this[o];
                    break;
                case "reflectivity":
                    e[o] = this[o], e[o] > 0 && (e.envMap = Ze.defaultEnvMap), e.combine = r.MixOperation;
                    break;
                case "index_of_refraction":
                    e.refractionRatio = this[o], 1 !== this[o] && (e.envMap = Ze.defaultEnvMap)
            }
            switch (e.shading = Ye, e.side = this.effect.doubleSided ? r.DoubleSide : r.FrontSide, void 0 !== e.diffuse && (e.color = e.diffuse, delete e.diffuse), this.type) {
                case "constant":
                    void 0 != e.emissive && (e.color = e.emissive), this.material = new r.MeshBasicMaterial(e);
                    break;
                case "phong":
                case "blinn":
                    this.material = new r.MeshPhongMaterial(e);
                    break;
                case "lambert":
                default:
                    this.material = new r.MeshLambertMaterial(e)
            }
            return this.material
        }, Z.prototype.parse = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "init_from":
                        this.init_from = n.textContent;
                        break;
                    case "format":
                        this.format = n.textContent;
                        break;
                    default:
                        console.log("unhandled Surface prop: " + n.nodeName)
                }
            }
            return this
        }, J.prototype.parse = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "source":
                        this.source = n.textContent;
                        break;
                    case "minfilter":
                        this.minfilter = n.textContent;
                        break;
                    case "magfilter":
                        this.magfilter = n.textContent;
                        break;
                    case "mipfilter":
                        this.mipfilter = n.textContent;
                        break;
                    case "wrap_s":
                        this.wrap_s = n.textContent;
                        break;
                    case "wrap_t":
                        this.wrap_t = n.textContent;
                        break;
                    default:
                        console.log("unhandled Sampler2D prop: " + n.nodeName)
                }
            }
            return this
        }, K.prototype.create = function() {
            if (null === this.shader) return null
        }, K.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name"), xe(this, e), this.shader = null;
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "profile_COMMON":
                        this.parseTechnique(this.parseProfileCOMMON(n))
                }
            }
            return this
        }, K.prototype.parseNewparam = function(e) {
            for (var t = e.getAttribute("sid"), n = 0; n < e.childNodes.length; n++) {
                var r = e.childNodes[n];
                if (1 == r.nodeType) switch (r.nodeName) {
                    case "surface":
                        this.surface[t] = new Z(this).parse(r);
                        break;
                    case "sampler2D":
                        this.sampler[t] = new J(this).parse(r);
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(r.nodeName)
                }
            }
        }, K.prototype.parseProfileCOMMON = function(e) {
            for (var t, n = 0; n < e.childNodes.length; n++) {
                var r = e.childNodes[n];
                if (1 == r.nodeType) switch (r.nodeName) {
                    case "profile_COMMON":
                        this.parseProfileCOMMON(r);
                        break;
                    case "technique":
                        t = r;
                        break;
                    case "newparam":
                        this.parseNewparam(r);
                        break;
                    case "image":
                        var i = (new A).parse(r);
                        je[i.id] = i;
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(r.nodeName)
                }
            }
            return t
        }, K.prototype.parseTechnique = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "constant":
                    case "lambert":
                    case "blinn":
                    case "phong":
                        this.shader = new Y(n.nodeName, this).parse(n);
                        break;
                    case "extra":
                        this.parseExtra(n)
                }
            }
        }, K.prototype.parseExtra = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "technique":
                        this.parseExtraTechnique(n)
                }
            }
        }, K.prototype.parseExtraTechnique = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "bump":
                        this.shader.parse(e)
                }
            }
        }, Q.prototype.parse = function(e) {
            return this.url = e.getAttribute("url").replace(/^#/, ""), this
        }, ee.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name"), this.source = {};
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "animation":
                        var r = (new ee).parse(n);
                        for (var i in r.source) this.source[i] = r.source[i];
                        for (var o = 0; o < r.channel.length; o++) this.channel.push(r.channel[o]), this.sampler.push(r.sampler[o]);
                        break;
                    case "source":
                        var i = (new $).parse(n);
                        this.source[i.id] = i;
                        break;
                    case "sampler":
                        this.sampler.push(new ne(this).parse(n));
                        break;
                    case "channel":
                        this.channel.push(new te(this).parse(n))
                }
            }
            return this
        }, te.prototype.parse = function(e) {
            this.source = e.getAttribute("source").replace(/^#/, ""), this.target = e.getAttribute("target");
            var t = this.target.split("https://productconfigurator.virtualsaleslab.com/"),
                n = (t.shift(), t.shift()),
                r = n.indexOf(".") >= 0,
                i = n.indexOf("(") >= 0;
            if (r) t = n.split("."), this.sid = t.shift(), this.member = t.shift();
            else if (i) {
                var o = n.split("(");
                this.sid = o.shift();
                for (var a = 0; a < o.length; a++) o[a] = parseInt(o[a].replace(/\)/, ""));
                this.arrIndices = o
            } else this.sid = n;
            return this.fullSid = n, this.dotSyntax = r, this.arrSyntax = i, this
        }, ne.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.inputs = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "input":
                        this.inputs.push((new W).parse(n))
                }
            }
            return this
        }, ne.prototype.create = function() {
            for (var e = 0; e < this.inputs.length; e++) {
                var t = this.inputs[e],
                    n = this.animation.source[t.source];
                switch (t.semantic) {
                    case "INPUT":
                        this.input = n.read();
                        break;
                    case "OUTPUT":
                        this.output = n.read(), this.strideOut = n.accessor.stride;
                        break;
                    case "INTERPOLATION":
                        this.interpolation = n.read();
                        break;
                    case "IN_TANGENT":
                    case "OUT_TANGENT":
                        break;
                    default:
                        console.log(t.semantic)
                }
            }
            if (this.startTime = 0, this.endTime = 0, this.duration = 0, this.input.length) {
                this.startTime = 1e8, this.endTime = -1e8;
                for (var e = 0; e < this.input.length; e++) this.startTime = Math.min(this.startTime, this.input[e]), this.endTime = Math.max(this.endTime, this.input[e]);
                this.duration = this.endTime - this.startTime
            }
        }, ne.prototype.getData = function(e, t, n) {
            var r;
            if ("matrix" === e && 16 === this.strideOut) r = this.output[t];
            else if (this.strideOut > 1) {
                r = [], t *= this.strideOut;
                for (var i = 0; i < this.strideOut; ++i) r[i] = this.output[t + i];
                if (3 === this.strideOut) switch (e) {
                    case "rotate":
                    case "translate":
                        _e(r, -1);
                        break;
                    case "scale":
                        _e(r, 1)
                } else 4 === this.strideOut && "matrix" === e && _e(r, -1)
            } else r = this.output[t], n && "translate" === e && (r = Me(n, r));
            return r
        }, re.prototype.addTarget = function(e, t, n, r) {
            this.targets.push({
                sid: e,
                member: n,
                transform: t,
                data: r
            })
        }, re.prototype.apply = function(e) {
            for (var t = 0; t < this.targets.length; ++t) {
                var n = this.targets[t];
                e && n.sid !== e || n.transform.update(n.data, n.member)
            }
        }, re.prototype.getTarget = function(e) {
            for (var t = 0; t < this.targets.length; ++t)
                if (this.targets[t].sid === e) return this.targets[t];
            return null
        }, re.prototype.hasTarget = function(e) {
            for (var t = 0; t < this.targets.length; ++t)
                if (this.targets[t].sid === e) return !0;
            return !1
        }, re.prototype.interpolate = function(e, t) {
            for (var n = 0, r = this.targets.length; n < r; n++) {
                var i, o = this.targets[n],
                    a = e.getTarget(o.sid);
                if ("matrix" !== o.transform.type && a) {
                    var s = (t - this.time) / (e.time - this.time),
                        c = a.data,
                        l = o.data;
                    if (s < 0 && (s = 0), s > 1 && (s = 1), l.length) {
                        i = [];
                        for (var h = 0; h < l.length; ++h) i[h] = l[h] + (c[h] - l[h]) * s
                    } else i = l + (c - l) * s
                } else i = o.data;
                o.transform.update(i, o.member)
            }
        }, ie.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name");
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "optics":
                        this.parseOptics(n)
                }
            }
            return this
        }, ie.prototype.parseOptics = function(e) {
            for (var t = 0; t < e.childNodes.length; t++)
                if ("technique_common" === e.childNodes[t].nodeName)
                    for (var n = e.childNodes[t], r = 0; r < n.childNodes.length; r++)
                        if (this.technique = n.childNodes[r].nodeName, "perspective" === this.technique)
                            for (var i = n.childNodes[r], o = 0; o < i.childNodes.length; o++) {
                                var a = i.childNodes[o];
                                switch (a.nodeName) {
                                    case "yfov":
                                        this.yfov = a.textContent;
                                        break;
                                    case "xfov":
                                        this.xfov = a.textContent;
                                        break;
                                    case "znear":
                                        this.znear = a.textContent;
                                        break;
                                    case "zfar":
                                        this.zfar = a.textContent;
                                        break;
                                    case "aspect_ratio":
                                        this.aspect_ratio = a.textContent
                                }
                            } else if ("orthographic" === this.technique)
                                for (var s = n.childNodes[r], o = 0; o < s.childNodes.length; o++) {
                                    var a = s.childNodes[o];
                                    switch (a.nodeName) {
                                        case "xmag":
                                            this.xmag = a.textContent;
                                            break;
                                        case "ymag":
                                            this.ymag = a.textContent;
                                            break;
                                        case "znear":
                                            this.znear = a.textContent;
                                            break;
                                        case "zfar":
                                            this.zfar = a.textContent;
                                            break;
                                        case "aspect_ratio":
                                            this.aspect_ratio = a.textContent
                                    }
                                }
                            return this
        }, oe.prototype.parse = function(e) {
            return this.url = e.getAttribute("url").replace(/^#/, ""), this
        }, ae.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name");
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "technique_common":
                        this.parseCommon(n);
                        break;
                    case "technique":
                        this.parseTechnique(n)
                }
            }
            return this
        }, ae.prototype.parseCommon = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) switch (e.childNodes[t].nodeName) {
                case "directional":
                case "point":
                case "spot":
                case "ambient":
                    this.technique = e.childNodes[t].nodeName;
                    for (var n = e.childNodes[t], i = 0; i < n.childNodes.length; i++) {
                        var o = n.childNodes[i];
                        switch (o.nodeName) {
                            case "color":
                                var a = fe(o.textContent);
                                this.color = new r.Color(0), this.color.setRGB(a[0], a[1], a[2]), this.color.a = a[3];
                                break;
                            case "falloff_angle":
                                this.falloff_angle = parseFloat(o.textContent);
                                break;
                            case "quadratic_attenuation":
                                var s = parseFloat(o.textContent);
                                this.distance = s ? Math.sqrt(1 / s) : 0
                        }
                    }
            }
            return this
        }, ae.prototype.parseTechnique = function(e) {
            this.profile = e.getAttribute("profile");
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                switch (n.nodeName) {
                    case "intensity":
                        this.intensity = parseFloat(n.textContent)
                }
            }
            return this
        }, se.prototype.parse = function(e) {
            return this.url = e.getAttribute("url").replace(/^#/, ""), this
        }, ce.prototype.parse = function(e) {
            this.id = e.getAttribute("id"), this.name = e.getAttribute("name"), this.joints = [], this.links = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "technique_common":
                        this.parseCommon(n)
                }
            }
            return this
        }, ce.prototype.parseCommon = function(e) {
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (e.childNodes[t].nodeName) {
                    case "joint":
                        this.joints.push((new le).parse(n));
                        break;
                    case "link":
                        this.links.push((new he).parse(n))
                }
            }
            return this
        }, le.prototype.parse = function(e) {
            this.sid = e.getAttribute("sid"), this.name = e.getAttribute("name"), this.axis = new r.Vector3, this.limits = {
                min: 0,
                max: 0
            }, this.type = "", this.static = !1, this.zeroPosition = 0, this.middlePosition = 0;
            var t = e.querySelector("axis"),
                n = fe(t.textContent);
            this.axis = Ee(n, 0);
            var i = e.querySelector("limits min") ? parseFloat(e.querySelector("limits min").textContent) : -360,
                o = e.querySelector("limits max") ? parseFloat(e.querySelector("limits max").textContent) : 360;
            this.limits = {
                min: i,
                max: o
            };
            for (var a = ["prismatic", "revolute"], s = 0; s < a.length; s++) {
                var c = a[s];
                e.querySelector(c) && (this.type = c)
            }
            return this.limits.min >= this.limits.max && (this.static = !0), this.middlePosition = (this.limits.min + this.limits.max) / 2, this
        }, he.prototype.parse = function(e) {
            this.sid = e.getAttribute("sid"), this.name = e.getAttribute("name"), this.transforms = [], this.attachments = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "attachment_full":
                        this.attachments.push((new ue).parse(n));
                        break;
                    case "rotate":
                    case "translate":
                    case "matrix":
                        this.transforms.push((new O).parse(n))
                }
            }
            return this
        }, ue.prototype.parse = function(e) {
            this.joint = e.getAttribute("joint").split("https://productconfigurator.virtualsaleslab.com/").pop(), this.links = [];
            for (var t = 0; t < e.childNodes.length; t++) {
                var n = e.childNodes[t];
                if (1 == n.nodeType) switch (n.nodeName) {
                    case "link":
                        this.links.push((new he).parse(n));
                        break;
                    case "rotate":
                    case "translate":
                    case "matrix":
                        this.transforms.push((new O).parse(n))
                }
            }
            return this
        }, {
            load: e,
            parse: t,
            setPreferredShading: n,
            applySkin: g,
            geometries: Ge,
            options: Ze
        }
    }
}, function(e, t, n) {
    function r(e) {
        if (null === e || void 0 === e) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(e)
    }
    var i = (n(0), Object.getOwnPropertySymbols),
        o = Object.prototype.hasOwnProperty,
        a = Object.prototype.propertyIsEnumerable;
    e.exports = function() {
        try {
            if (!Object.assign) return !1;
            var e = new String("abc");
            if (e[5] = "de", "5" === Object.getOwnPropertyNames(e)[0]) return !1;
            for (var t = {}, n = 0; n < 10; n++) t["_" + String.fromCharCode(n)] = n;
            if ("0123456789" !== Object.getOwnPropertyNames(t).map(function(e) {
                    return t[e]
                }).join("")) return !1;
            var r = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(e) {
                r[e] = e
            }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
        } catch (e) {
            return !1
        }
    }() ? Object.assign : function(e, t) {
        for (var n, s, c = r(e), l = 1; l < arguments.length; l++) {
            n = Object(arguments[l]);
            for (var h in n) o.call(n, h) && (c[h] = n[h]);
            if (i) {
                s = i(n);
                for (var u = 0; u < s.length; u++) a.call(n, s[u]) && (c[s[u]] = n[s[u]])
            }
        }
        return c
    }
}, function(e, t) {
    function n(e) {
        var t = r.call(e);
        return "[object Function]" === t || "function" == typeof e && "[object RegExp]" !== t || "undefined" != typeof window && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt)
    }
    e.exports = n;
    var r = Object.prototype.toString
}, function(e, t) {
    e.exports = function(e) {
        switch (e) {
            case "int8":
                return Int8Array;
            case "int16":
                return Int16Array;
            case "int32":
                return Int32Array;
            case "uint8":
                return Uint8Array;
            case "uint16":
                return Uint16Array;
            case "uint32":
                return Uint32Array;
            case "float32":
                return Float32Array;
            case "float64":
                return Float64Array;
            case "array":
                return Array;
            case "uint8_clamped":
                return Uint8ClampedArray
        }
    }
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r;
    ! function(e) {
        function t() {
            var e = {
                1000: {
                    code: "1000",
                    rgbApprox: "214-199-148",
                    rgbHex: "#BEBD7F",
                    name: "Green beige"
                },
                1001: {
                    code: "1001",
                    rgbApprox: "217-186-140",
                    rgbHex: "#C2B078",
                    name: "Beige"
                },
                1002: {
                    code: "1002",
                    rgbApprox: "198-166-100",
                    rgbHex: "#C6A664",
                    name: "Sand yellow"
                },
                1003: {
                    code: "1003",
                    rgbApprox: "229-190-001",
                    rgbHex: "#E5BE01",
                    name: "Signal yellow"
                },
                1004: {
                    code: "1004",
                    rgbApprox: "205-164-052",
                    rgbHex: "#CDA434",
                    name: "Golden yellow"
                },
                1005: {
                    code: "1005",
                    rgbApprox: "169-131-007",
                    rgbHex: "#A98307",
                    name: "Honey yellow"
                },
                1006: {
                    code: "1006",
                    rgbApprox: "228-160-016",
                    rgbHex: "#E4A010",
                    name: "Maize yellow"
                },
                1007: {
                    code: "1007",
                    rgbApprox: "220-156-000",
                    rgbHex: "#DC9D00",
                    name: "Daffodil yellow"
                },
                1011: {
                    code: "1011",
                    rgbApprox: "138-102-066",
                    rgbHex: "#8A6642",
                    name: "Brown beige"
                },
                1012: {
                    code: "1012",
                    rgbApprox: "199-180-070",
                    rgbHex: "#C7B446",
                    name: "Lemon yellow"
                },
                1013: {
                    code: "1013",
                    rgbApprox: "234-230-202",
                    rgbHex: "#EAE6CA",
                    name: "Oyster white"
                },
                1014: {
                    code: "1014",
                    rgbApprox: "225-204-079",
                    rgbHex: "#E1CC4F",
                    name: "Ivory"
                },
                1015: {
                    code: "1015",
                    rgbApprox: "230-214-144",
                    rgbHex: "#E6D690",
                    name: "Light ivory"
                },
                1016: {
                    code: "1016",
                    rgbApprox: "237-255-033",
                    rgbHex: "#EDFF21",
                    name: "Sulfur yellow"
                },
                1017: {
                    code: "1017",
                    rgbApprox: "245-208-051",
                    rgbHex: "#F5D033",
                    name: "Saffron yellow"
                },
                1018: {
                    code: "1018",
                    rgbApprox: "248-243-053",
                    rgbHex: "#F8F32B",
                    name: "Zinc yellow"
                },
                1019: {
                    code: "1019",
                    rgbApprox: "158-151-100",
                    rgbHex: "#9E9764",
                    name: "Grey beige"
                },
                1020: {
                    code: "1020",
                    rgbApprox: "153-153-080",
                    rgbHex: "#999950",
                    name: "Olive yellow"
                },
                1021: {
                    code: "1021",
                    rgbApprox: "243-218-011",
                    rgbHex: "#F3DA0B",
                    name: "Rape yellow"
                },
                1023: {
                    code: "1023",
                    rgbApprox: "250-210-001",
                    rgbHex: "#FAD201",
                    name: "Traffic yellow"
                },
                1024: {
                    code: "1024",
                    rgbApprox: "174-160-075",
                    rgbHex: "#AEA04B",
                    name: "Ochre yellow"
                },
                1026: {
                    code: "1026",
                    rgbApprox: "255-255-000",
                    rgbHex: "#FFFF00",
                    name: "Luminous yellow"
                },
                1027: {
                    code: "1027",
                    rgbApprox: "157-145-001",
                    rgbHex: "#9D9101",
                    name: "Curry"
                },
                1028: {
                    code: "1028",
                    rgbApprox: "244-169-000",
                    rgbHex: "#F4A900",
                    name: "Melon yellow"
                },
                1032: {
                    code: "1032",
                    rgbApprox: "214-174-001",
                    rgbHex: "#D6AE01",
                    name: "Broom yellow"
                },
                1033: {
                    code: "1033",
                    rgbApprox: "243-165-005",
                    rgbHex: "#F3A505",
                    name: "Dahlia yellow"
                },
                1034: {
                    code: "1034",
                    rgbApprox: "239-169-074",
                    rgbHex: "#EFA94A",
                    name: "Pastel yellow"
                },
                1035: {
                    code: "1035",
                    rgbApprox: "106-093-077",
                    rgbHex: "#6A5D4D",
                    name: "Pearl beige"
                },
                1036: {
                    code: "1036",
                    rgbApprox: "112-083-053",
                    rgbHex: "#705335",
                    name: "Pearl gold"
                },
                1037: {
                    code: "1037",
                    rgbApprox: "243-159-024",
                    rgbHex: "#F39F18",
                    name: "Sun yellow"
                },
                2000: {
                    code: "2000",
                    rgbApprox: "237-118-014",
                    rgbHex: "#ED760E",
                    name: "Yellow orange"
                },
                2001: {
                    code: "2001",
                    rgbApprox: "201-060-032",
                    rgbHex: "#C93C20",
                    name: "Red orange"
                },
                2002: {
                    code: "2002",
                    rgbApprox: "203-040-033",
                    rgbHex: "#CB2821",
                    name: "Vermilion"
                },
                2003: {
                    code: "2003",
                    rgbApprox: "255-117-020",
                    rgbHex: "#FF7514",
                    name: "Pastel orange"
                },
                2004: {
                    code: "2004",
                    rgbApprox: "244-070-017",
                    rgbHex: "#F44611",
                    name: "Pure orange"
                },
                2005: {
                    code: "2005",
                    rgbApprox: "255-035-001",
                    rgbHex: "#FF2301",
                    name: "Luminous orange"
                },
                2007: {
                    code: "2007",
                    rgbApprox: "255-164-032",
                    rgbHex: "#FFA420",
                    name: "Luminous bright orange"
                },
                2008: {
                    code: "2008",
                    rgbApprox: "247-094-037",
                    rgbHex: "#F75E25",
                    name: "Bright red orange"
                },
                2009: {
                    code: "2009",
                    rgbApprox: "245-064-033",
                    rgbHex: "#F54021",
                    name: "Traffic orange"
                },
                2010: {
                    code: "2010",
                    rgbApprox: "216-075-032",
                    rgbHex: "#D84B20",
                    name: "Signal orange"
                },
                2011: {
                    code: "2011",
                    rgbApprox: "236-124-038",
                    rgbHex: "#EC7C26",
                    name: "Deep orange"
                },
                2012: {
                    code: "2012",
                    rgbApprox: "235-106-014",
                    rgbHex: "#E55137",
                    name: "Salmon range"
                },
                2013: {
                    code: "2013",
                    rgbApprox: "195-088-049",
                    rgbHex: "#C35831",
                    name: "Pearl orange"
                },
                3000: {
                    code: "3000",
                    rgbApprox: "175-043-030",
                    rgbHex: "#AF2B1E",
                    name: "Flame red"
                },
                3001: {
                    code: "3001",
                    rgbApprox: "165-032-025",
                    rgbHex: "#A52019",
                    name: "Signal red"
                },
                3002: {
                    code: "3002",
                    rgbApprox: "162-035-029",
                    rgbHex: "#A2231D",
                    name: "Carmine red"
                },
                3003: {
                    code: "3003",
                    rgbApprox: "155-017-030",
                    rgbHex: "#9B111E",
                    name: "Ruby red"
                },
                3004: {
                    code: "3004",
                    rgbApprox: "117-021-030",
                    rgbHex: "#75151E",
                    name: "Purple red"
                },
                3005: {
                    code: "3005",
                    rgbApprox: "094-033-041",
                    rgbHex: "#5E2129",
                    name: "Wine red"
                },
                3007: {
                    code: "3007",
                    rgbApprox: "065-034-039",
                    rgbHex: "#412227",
                    name: "Black red"
                },
                3009: {
                    code: "3009",
                    rgbApprox: "100-036-036",
                    rgbHex: "#642424",
                    name: "Oxide red"
                },
                3011: {
                    code: "3011",
                    rgbApprox: "120-031-025",
                    rgbHex: "#781F19",
                    name: "Brown red"
                },
                3012: {
                    code: "3012",
                    rgbApprox: "193-135-107",
                    rgbHex: "#C1876B",
                    name: "Beige red"
                },
                3013: {
                    code: "3013",
                    rgbApprox: "161-035-018",
                    rgbHex: "#A12312",
                    name: "Tomato red"
                },
                3014: {
                    code: "3014",
                    rgbApprox: "211-110-112",
                    rgbHex: "#D36E70",
                    name: "Antique pink"
                },
                3015: {
                    code: "3015",
                    rgbApprox: "234-137-154",
                    rgbHex: "#EA899A",
                    name: "Light pink"
                },
                3016: {
                    code: "3016",
                    rgbApprox: "179-040-033",
                    rgbHex: "#B32821",
                    name: "Coral red"
                },
                3017: {
                    code: "3017",
                    rgbApprox: "230-050-068",
                    rgbHex: "#E63244",
                    name: "Rose"
                },
                3018: {
                    code: "3018",
                    rgbApprox: "213-048-050",
                    rgbHex: "#D53032",
                    name: "Strawberry red"
                },
                3020: {
                    code: "3020",
                    rgbApprox: "204-006-005",
                    rgbHex: "#CC0605",
                    name: "Traffic red"
                },
                3022: {
                    code: "3022",
                    rgbApprox: "217-080-048",
                    rgbHex: "#D95030",
                    name: "Salmon pink"
                },
                3024: {
                    code: "3024",
                    rgbApprox: "248-000-000",
                    rgbHex: "#F80000",
                    name: "Luminous red"
                },
                3026: {
                    code: "3026",
                    rgbApprox: "254-000-000",
                    rgbHex: "#FE0000",
                    name: "Luminous bright red"
                },
                3027: {
                    code: "3027",
                    rgbApprox: "197-029-052",
                    rgbHex: "#C51D34",
                    name: "Raspberry red"
                },
                3028: {
                    code: "3028",
                    rgbApprox: "203-050-052",
                    rgbHex: "#CB3234",
                    name: "Pure  red"
                },
                3031: {
                    code: "3031",
                    rgbApprox: "179-036-040",
                    rgbHex: "#B32428",
                    name: "Orient red"
                },
                3032: {
                    code: "3032",
                    rgbApprox: "114-020-034",
                    rgbHex: "#721422",
                    name: "Pearl ruby red"
                },
                3033: {
                    code: "3033",
                    rgbApprox: "180-076-067",
                    rgbHex: "#B44C43",
                    name: "Pearl pink"
                },
                4001: {
                    code: "4001",
                    rgbApprox: "109-063-091",
                    rgbHex: "#6D3F5B",
                    name: "Red lilac"
                },
                4002: {
                    code: "4002",
                    rgbApprox: "146-043-062",
                    rgbHex: "#922B3E",
                    name: "Red violet"
                },
                4003: {
                    code: "4003",
                    rgbApprox: "222-076-138",
                    rgbHex: "#DE4C8A",
                    name: "Heather violet"
                },
                4004: {
                    code: "4004",
                    rgbApprox: "110-028-052",
                    rgbHex: "#641C34",
                    name: "Claret violet"
                },
                4005: {
                    code: "4005",
                    rgbApprox: "108-070-117",
                    rgbHex: "#6C4675",
                    name: "Blue lilac"
                },
                4006: {
                    code: "4006",
                    rgbApprox: "160-052-114",
                    rgbHex: "#A03472",
                    name: "Traffic purple"
                },
                4007: {
                    code: "4007",
                    rgbApprox: "074-025-044",
                    rgbHex: "#4A192C",
                    name: "Purple violet"
                },
                4008: {
                    code: "4008",
                    rgbApprox: "146-078-125",
                    rgbHex: "#924E7D",
                    name: "Signal violet"
                },
                4009: {
                    code: "4009",
                    rgbApprox: "164-125-144",
                    rgbHex: "#A18594",
                    name: "Pastel violet"
                },
                4010: {
                    code: "4010",
                    rgbApprox: "215-045-109",
                    rgbHex: "#CF3476",
                    name: "Telemagenta"
                },
                4011: {
                    code: "4011",
                    rgbApprox: "134-115-161",
                    rgbHex: "#8673A1",
                    name: "Pearl violet"
                },
                4012: {
                    code: "4012",
                    rgbApprox: "108-104-129",
                    rgbHex: "#6C6874",
                    name: "Pearl black berry"
                },
                5000: {
                    code: "5000",
                    rgbApprox: "042-046-075",
                    rgbHex: "#354D73",
                    name: "Violet blue"
                },
                5001: {
                    code: "5001",
                    rgbApprox: "031-052-056",
                    rgbHex: "#1F3438",
                    name: "Green blue"
                },
                5002: {
                    code: "5002",
                    rgbApprox: "032-033-079",
                    rgbHex: "#20214F",
                    name: "Ultramarine blue"
                },
                5003: {
                    code: "5003",
                    rgbApprox: "029-030-051",
                    rgbHex: "#1D1E33",
                    name: "Saphire blue"
                },
                5004: {
                    code: "5004",
                    rgbApprox: "032-033-079",
                    rgbHex: "#18171C",
                    name: "Black blue"
                },
                5005: {
                    code: "5005",
                    rgbApprox: "030-045-110",
                    rgbHex: "#1E2460",
                    name: "Signal blue"
                },
                5007: {
                    code: "5007",
                    rgbApprox: "062-095-138",
                    rgbHex: "#3E5F8A",
                    name: "Brillant blue"
                },
                5008: {
                    code: "5008",
                    rgbApprox: "038-037-045",
                    rgbHex: "#26252D",
                    name: "Grey blue"
                },
                5009: {
                    code: "5009",
                    rgbApprox: "002-086-105",
                    rgbHex: "#025669",
                    name: "Azure blue"
                },
                5010: {
                    code: "5010",
                    rgbApprox: "014-041-075",
                    rgbHex: "#0E294B",
                    name: "Gentian blue"
                },
                5011: {
                    code: "5011",
                    rgbApprox: "035-026-036",
                    rgbHex: "#231A24",
                    name: "Steel blue"
                },
                5012: {
                    code: "5012",
                    rgbApprox: "059-131-189",
                    rgbHex: "#3B83BD",
                    name: "Light blue"
                },
                5013: {
                    code: "5013",
                    rgbApprox: "037-041-074",
                    rgbHex: "#1E213D",
                    name: "Cobalt blue"
                },
                5014: {
                    code: "5014",
                    rgbApprox: "096-111-140",
                    rgbHex: "#606E8C",
                    name: "Pigeon blue"
                },
                5015: {
                    code: "5015",
                    rgbApprox: "034-113-179",
                    rgbHex: "#2271B3",
                    name: "Sky blue"
                },
                5017: {
                    code: "5017",
                    rgbApprox: "006-057-113",
                    rgbHex: "#063971",
                    name: "Traffic blue"
                },
                5018: {
                    code: "5018",
                    rgbApprox: "063-136-143",
                    rgbHex: "#3F888F",
                    name: "Turquoise blue"
                },
                5019: {
                    code: "5019",
                    rgbApprox: "027-085-131",
                    rgbHex: "#1B5583",
                    name: "Capri blue"
                },
                5020: {
                    code: "5020",
                    rgbApprox: "029-051-074",
                    rgbHex: "#1D334A",
                    name: "Ocean blue"
                },
                5021: {
                    code: "5021",
                    rgbApprox: "037-109-123",
                    rgbHex: "#256D7B",
                    name: "Water blue"
                },
                5022: {
                    code: "5022",
                    rgbApprox: "037-040-080",
                    rgbHex: "#252850",
                    name: "Night blue"
                },
                5023: {
                    code: "5023",
                    rgbApprox: "073-103-141",
                    rgbHex: "#49678D",
                    name: "Distant blue"
                },
                5024: {
                    code: "5024",
                    rgbApprox: "093-155-155",
                    rgbHex: "#5D9B9B",
                    name: "Pastel blue"
                },
                5025: {
                    code: "5025",
                    rgbApprox: "042-100-120",
                    rgbHex: "#2A6478",
                    name: "Pearl gentian blue"
                },
                5026: {
                    code: "5026",
                    rgbApprox: "016-044-084",
                    rgbHex: "#102C54",
                    name: "Pearl night blue"
                },
                6000: {
                    code: "6000",
                    rgbApprox: "049-102-080",
                    rgbHex: "#316650",
                    name: "Patina green"
                },
                6001: {
                    code: "6001",
                    rgbApprox: "040-114-051",
                    rgbHex: "#287233",
                    name: "Emerald green"
                },
                6002: {
                    code: "6002",
                    rgbApprox: "045-087-044",
                    rgbHex: "#2D572C",
                    name: "Leaf green"
                },
                6003: {
                    code: "6003",
                    rgbApprox: "066-070-050",
                    rgbHex: "#424632",
                    name: "Olive green"
                },
                6004: {
                    code: "6004",
                    rgbApprox: "031-058-061",
                    rgbHex: "#1F3A3D",
                    name: "Blue green"
                },
                6005: {
                    code: "6005",
                    rgbApprox: "047-069-056",
                    rgbHex: "#2F4538",
                    name: "Moss green"
                },
                6006: {
                    code: "6006",
                    rgbApprox: "062-059-050",
                    rgbHex: "#3E3B32",
                    name: "Grey olive"
                },
                6007: {
                    code: "6007",
                    rgbApprox: "052-059-041",
                    rgbHex: "#343B29",
                    name: "Bottle green"
                },
                6008: {
                    code: "6008",
                    rgbApprox: "057-053-042",
                    rgbHex: "#39352A",
                    name: "Brown green"
                },
                6009: {
                    code: "6009",
                    rgbApprox: "049-055-043",
                    rgbHex: "#31372B",
                    name: "Fir green"
                },
                6010: {
                    code: "6010",
                    rgbApprox: "053-104-045",
                    rgbHex: "#35682D",
                    name: "Grass green"
                },
                6011: {
                    code: "6011",
                    rgbApprox: "088-114-070",
                    rgbHex: "#587246",
                    name: "Reseda green"
                },
                6012: {
                    code: "6012",
                    rgbApprox: "052-062-064",
                    rgbHex: "#343E40",
                    name: "Black green"
                },
                6013: {
                    code: "6013",
                    rgbApprox: "108-113-086",
                    rgbHex: "#6C7156",
                    name: "Reed green"
                },
                6014: {
                    code: "6014",
                    rgbApprox: "071-064-046",
                    rgbHex: "#47402E",
                    name: "Yellow olive"
                },
                6015: {
                    code: "6015",
                    rgbApprox: "059-060-054",
                    rgbHex: "#3B3C36",
                    name: "Black olive"
                },
                6016: {
                    code: "6016",
                    rgbApprox: "030-089-069",
                    rgbHex: "#1E5945",
                    name: "Turquoise green"
                },
                6017: {
                    code: "6017",
                    rgbApprox: "076-145-065",
                    rgbHex: "#4C9141",
                    name: "May green"
                },
                6018: {
                    code: "6018",
                    rgbApprox: "087-166-057",
                    rgbHex: "#57A639",
                    name: "Yellow green"
                },
                6019: {
                    code: "6019",
                    rgbApprox: "189-236-182",
                    rgbHex: "#BDECB6",
                    name: "Pastel green"
                },
                6020: {
                    code: "6020",
                    rgbApprox: "046-058-035",
                    rgbHex: "#2E3A23",
                    name: "Chrome green"
                },
                6021: {
                    code: "6021",
                    rgbApprox: "137-172-118",
                    rgbHex: "#89AC76",
                    name: "Pale green"
                },
                6022: {
                    code: "6022",
                    rgbApprox: "037-034-027",
                    rgbHex: "#25221B",
                    name: "Olive drab"
                },
                6024: {
                    code: "6024",
                    rgbApprox: "048-132-070",
                    rgbHex: "#308446",
                    name: "Traffic green"
                },
                6025: {
                    code: "6025",
                    rgbApprox: "061-100-045",
                    rgbHex: "#3D642D",
                    name: "Fern green"
                },
                6026: {
                    code: "6026",
                    rgbApprox: "001-093-082",
                    rgbHex: "#015D52",
                    name: "Opal green"
                },
                6027: {
                    code: "6027",
                    rgbApprox: "132-195-190",
                    rgbHex: "#84C3BE",
                    name: "Light green"
                },
                6028: {
                    code: "6028",
                    rgbApprox: "044-085-069",
                    rgbHex: "#2C5545",
                    name: "Pine green"
                },
                6029: {
                    code: "6029",
                    rgbApprox: "032-096-061",
                    rgbHex: "#20603D",
                    name: "Mint green"
                },
                6032: {
                    code: "6032",
                    rgbApprox: "049-127-067",
                    rgbHex: "#317F43",
                    name: "Signal green"
                },
                6033: {
                    code: "6033",
                    rgbApprox: "073-126-118",
                    rgbHex: "#497E76",
                    name: "Mint turquoise"
                },
                6034: {
                    code: "6034",
                    rgbApprox: "127-181-181",
                    rgbHex: "#7FB5B5",
                    name: "Pastel turquoise"
                },
                6035: {
                    code: "6035",
                    rgbApprox: "028-084-045",
                    rgbHex: "#1C542D",
                    name: "Pearl green"
                },
                6036: {
                    code: "6036",
                    rgbApprox: "022-053-055",
                    rgbHex: "#193737",
                    name: "Pearl opal green"
                },
                6037: {
                    code: "6037",
                    rgbApprox: "000-143-057",
                    rgbHex: "#008F39",
                    name: "Pure green"
                },
                6038: {
                    code: "6038",
                    rgbApprox: "000-187-045",
                    rgbHex: "#00BB2D",
                    name: "Luminous green"
                },
                7000: {
                    code: "7000",
                    rgbApprox: "120-133-139",
                    rgbHex: "#78858B",
                    name: "Squirrel grey"
                },
                7001: {
                    code: "7001",
                    rgbApprox: "138-149-151",
                    rgbHex: "#8A9597",
                    name: "Silver grey"
                },
                7002: {
                    code: "7002",
                    rgbApprox: "126-123-082",
                    rgbHex: "#7E7B52",
                    name: "Olive grey"
                },
                7003: {
                    code: "7003",
                    rgbApprox: "108-112-089",
                    rgbHex: "#6C7059",
                    name: "Moss grey"
                },
                7004: {
                    code: "7004",
                    rgbApprox: "150-153-146",
                    rgbHex: "#969992",
                    name: "Signal grey"
                },
                7005: {
                    code: "7005",
                    rgbApprox: "100-107-099",
                    rgbHex: "#646B63",
                    name: "Mouse grey"
                },
                7006: {
                    code: "7006",
                    rgbApprox: "109-101-082",
                    rgbHex: "#6D6552",
                    name: "Beige grey"
                },
                7008: {
                    code: "7008",
                    rgbApprox: "106-095-049",
                    rgbHex: "#6A5F31",
                    name: "Khaki grey"
                },
                7009: {
                    code: "7009",
                    rgbApprox: "077-086-069",
                    rgbHex: "#4D5645",
                    name: "Green grey"
                },
                7010: {
                    code: "7010",
                    rgbApprox: "076-081-074",
                    rgbHex: "#4C514A",
                    name: "Tarpaulin grey"
                },
                7011: {
                    code: "7011",
                    rgbApprox: "067-075-077",
                    rgbHex: "#434B4D",
                    name: "Iron grey"
                },
                7012: {
                    code: "7012",
                    rgbApprox: "078-087-084",
                    rgbHex: "#4E5754",
                    name: "Basalt grey"
                },
                7013: {
                    code: "7013",
                    rgbApprox: "070-069-049",
                    rgbHex: "#464531",
                    name: "Brown grey"
                },
                7015: {
                    code: "7015",
                    rgbApprox: "067-071-080",
                    rgbHex: "#434750",
                    name: "Slate grey"
                },
                7016: {
                    code: "7016",
                    rgbApprox: "041-049-051",
                    rgbHex: "#293133",
                    name: "Anthracite grey"
                },
                7021: {
                    code: "7021",
                    rgbApprox: "035-040-043",
                    rgbHex: "#23282B",
                    name: "Black grey"
                },
                7022: {
                    code: "7022",
                    rgbApprox: "051-047-044",
                    rgbHex: "#332F2C",
                    name: "Umbra grey"
                },
                7023: {
                    code: "7023",
                    rgbApprox: "104-108-094",
                    rgbHex: "#686C5E",
                    name: "Concrete grey"
                },
                7024: {
                    code: "7024",
                    rgbApprox: "071-074-081",
                    rgbHex: "#474A51",
                    name: "Graphite grey"
                },
                7026: {
                    code: "7026",
                    rgbApprox: "047-053-059",
                    rgbHex: "#2F353B",
                    name: "Granite grey"
                },
                7030: {
                    code: "7030",
                    rgbApprox: "139-140-122",
                    rgbHex: "#8B8C7A",
                    name: "Stone grey"
                },
                7031: {
                    code: "7031",
                    rgbApprox: "071-075-078",
                    rgbHex: "#474B4E",
                    name: "Blue grey"
                },
                7032: {
                    code: "7032",
                    rgbApprox: "184-183-153",
                    rgbHex: "#B8B799",
                    name: "Pebble grey"
                },
                7033: {
                    code: "7033",
                    rgbApprox: "125-132-113",
                    rgbHex: "#7D8471",
                    name: "Cement grey"
                },
                7034: {
                    code: "7034",
                    rgbApprox: "143-139-102",
                    rgbHex: "#8F8B66",
                    name: "Yellow grey"
                },
                7035: {
                    code: "7035",
                    rgbApprox: "215-215-215",
                    rgbHex: "#D7D7D7",
                    name: "Light grey"
                },
                7036: {
                    code: "7036",
                    rgbApprox: "127-118-121",
                    rgbHex: "#7F7679",
                    name: "Platinum grey"
                },
                7037: {
                    code: "7037",
                    rgbApprox: "125-127-120",
                    rgbHex: "#7D7F7D",
                    name: "Dusty grey"
                },
                7038: {
                    code: "7038",
                    rgbApprox: "195-195-195",
                    rgbHex: "#B5B8B1",
                    name: "Agate grey"
                },
                7039: {
                    code: "7039",
                    rgbApprox: "108-105-096",
                    rgbHex: "#6C6960",
                    name: "Quartz grey"
                },
                7040: {
                    code: "7040",
                    rgbApprox: "157-161-170",
                    rgbHex: "#9DA1AA",
                    name: "Window grey"
                },
                7042: {
                    code: "7042",
                    rgbApprox: "141-148-141",
                    rgbHex: "#8D948D",
                    name: "Traffic grey A"
                },
                7043: {
                    code: "7043",
                    rgbApprox: "078-084-082",
                    rgbHex: "#4E5452",
                    name: "Traffic grey B"
                },
                7044: {
                    code: "7044",
                    rgbApprox: "202-196-176",
                    rgbHex: "#CAC4B0",
                    name: "Silk grey"
                },
                7045: {
                    code: "7045",
                    rgbApprox: "144-144-144",
                    rgbHex: "#909090",
                    name: "Telegrey 1"
                },
                7046: {
                    code: "7046",
                    rgbApprox: "130-137-143",
                    rgbHex: "#82898F",
                    name: "Telegrey 2"
                },
                7047: {
                    code: "7047",
                    rgbApprox: "208-208-208",
                    rgbHex: "#D0D0D0",
                    name: "Telegrey 4"
                },
                7048: {
                    code: "7048",
                    rgbApprox: "137-129-118",
                    rgbHex: "#898176",
                    name: "Pearl mouse grey"
                },
                8000: {
                    code: "8000",
                    rgbApprox: "130-108-052",
                    rgbHex: "#826C34",
                    name: "Green brown"
                },
                8001: {
                    code: "8001",
                    rgbApprox: "149-095-032",
                    rgbHex: "#955F20",
                    name: "Ochre brown"
                },
                8002: {
                    code: "8002",
                    rgbApprox: "108-059-042",
                    rgbHex: "#6C3B2A",
                    name: "Signal brown"
                },
                8003: {
                    code: "8003",
                    rgbApprox: "115-066-034",
                    rgbHex: "#734222",
                    name: "Clay brown"
                },
                8004: {
                    code: "8004",
                    rgbApprox: "142-064-042",
                    rgbHex: "#8E402A",
                    name: "Copper brown"
                },
                8007: {
                    code: "8007",
                    rgbApprox: "089-053-031",
                    rgbHex: "#59351F",
                    name: "Fawn brown"
                },
                8008: {
                    code: "8008",
                    rgbApprox: "111-079-040",
                    rgbHex: "#6F4F28",
                    name: "Olive brown"
                },
                8011: {
                    code: "8011",
                    rgbApprox: "091-058-041",
                    rgbHex: "#5B3A29",
                    name: "Nut brown"
                },
                8012: {
                    code: "8012",
                    rgbApprox: "089-035-033",
                    rgbHex: "#592321",
                    name: "Red brown"
                },
                8014: {
                    code: "8014",
                    rgbApprox: "056-044-030",
                    rgbHex: "#382C1E",
                    name: "Sepia brown"
                },
                8015: {
                    code: "8015",
                    rgbApprox: "099-058-052",
                    rgbHex: "#633A34",
                    name: "Chestnut brown"
                },
                8016: {
                    code: "8016",
                    rgbApprox: "076-047-039",
                    rgbHex: "#4C2F27",
                    name: "Mahogany brown"
                },
                8017: {
                    code: "8017",
                    rgbApprox: "069-050-046",
                    rgbHex: "#45322E",
                    name: "Chocolate brown"
                },
                8019: {
                    code: "8019",
                    rgbApprox: "064-058-058",
                    rgbHex: "#403A3A",
                    name: "Grey brown"
                },
                8022: {
                    code: "8022",
                    rgbApprox: "033-033-033",
                    rgbHex: "#212121",
                    name: "Black brown"
                },
                8023: {
                    code: "8023",
                    rgbApprox: "166-094-046",
                    rgbHex: "#A65E2E",
                    name: "Orange brown"
                },
                8024: {
                    code: "8024",
                    rgbApprox: "121-085-061",
                    rgbHex: "#79553D",
                    name: "Beige brown"
                },
                8025: {
                    code: "8025",
                    rgbApprox: "117-092-072",
                    rgbHex: "#755C48",
                    name: "Pale brown"
                },
                8028: {
                    code: "8028",
                    rgbApprox: "078-059-049",
                    rgbHex: "#4E3B31",
                    name: "Terra brown"
                },
                8029: {
                    code: "8029",
                    rgbApprox: "118-060-040",
                    rgbHex: "#763C28",
                    name: "Pearl copper"
                },
                9001: {
                    code: "9001",
                    rgbApprox: "250-244-227",
                    rgbHex: "#FDF4E3",
                    name: "Cream"
                },
                9002: {
                    code: "9002",
                    rgbApprox: "231-235-218",
                    rgbHex: "#E7EBDA",
                    name: "Grey white"
                },
                9003: {
                    code: "9003",
                    rgbApprox: "244-244-244",
                    rgbHex: "#F4F4F4",
                    name: "Signal white"
                },
                9004: {
                    code: "9004",
                    rgbApprox: "040-040-040",
                    rgbHex: "#282828",
                    name: "Signal black"
                },
                9005: {
                    code: "9005",
                    rgbApprox: "010-010-010",
                    rgbHex: "#0A0A0A",
                    name: "Jet black"
                },
                9006: {
                    code: "9006",
                    rgbApprox: "165-165-165",
                    rgbHex: "#A5A5A5",
                    name: "White aluminium"
                },
                9007: {
                    code: "9007",
                    rgbApprox: "143-143-143",
                    rgbHex: "#8F8F8F",
                    name: "Grey aluminium"
                },
                9010: {
                    code: "9010",
                    rgbApprox: "255-255-255",
                    rgbHex: "#FFFFFF",
                    name: "Pure white"
                },
                9011: {
                    code: "9011",
                    rgbApprox: "028-028-028",
                    rgbHex: "#1C1C1C",
                    name: "Graphite black"
                },
                9016: {
                    code: "9016",
                    rgbApprox: "246-246-246",
                    rgbHex: "#F6F6F6",
                    name: "Traffic white"
                },
                9017: {
                    code: "9017",
                    rgbApprox: "030-030-030",
                    rgbHex: "#1E1E1E",
                    name: "Traffic black"
                },
                9018: {
                    code: "9018",
                    rgbApprox: "215-215-215",
                    rgbHex: "#D7D7D7",
                    name: "Papyrus white"
                },
                9022: {
                    code: "9022",
                    rgbApprox: "156-156-156",
                    rgbHex: "#9C9C9C",
                    name: "Pearl light grey"
                },
                9023: {
                    code: "9023",
                    rgbApprox: "130-130-130",
                    rgbHex: "#828282",
                    name: "Pearl dark grey"
                },
                codes: [],
                getCode: function(t) {
                    return e[t] || e[1e3]
                },
                getHexColor: function(t) {
                    return parseInt(e.getCode(t).rgbHex.substr(1), 16)
                }
            };
            return e.codes = Object.keys(e).filter(function(e) {
                return /\d\d\d\d/.test(e)
            }), e
        }
        e.getRalDict = t
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return o
    });
    var r = n(2),
        i = n(0),
        o = function() {
            function e() {
                this.glass = new i.MeshStandardMaterial({
                    color: 8947916,
                    roughness: 0,
                    metalness: 1,
                    opacity: .44,
                    transparent: !0,
                    envMapIntensity: 1,
                    shading: i.FlatShading,
                    depthWrite: !1
                }), this.environmentSphere = new i.MeshBasicMaterial({
                    depthWrite: !1,
                    depthTest: !1
                }), this.whiteMetal = new i.MeshStandardMaterial({
                    color: 16777215,
                    roughness: .7,
                    metalness: .4,
                    shading: i.FlatShading
                }), this.whiteChalk = new i.MeshStandardMaterial({
                    color: 16777215,
                    roughness: 1,
                    metalness: 0,
                    shading: i.FlatShading
                }), this.oldEnvironmentTextureUrl = "xyz", this.blackMetal = this.withColor(this.whiteMetal, 0), this.grayMetal = this.withColor(this.whiteMetal, 8947848);
                var e = new i.ShadowMaterial;
                e.opacity = .5, this.shadowMaterial = e, e.name = "shadowMaterial", this.enableThrottling()
            }
            return e.prototype.enableThrottling = function() {}, e.prototype.withColor = function(e, t) {
                return e = e.clone(), e.color = new i.Color(t), e.needsUpdate = !0, e
            }, e.prototype.withTexture = function(e, t, n) {
                return e = e.clone(), (new i.TextureLoader).load(t, function(t) {
                    e.map = t, e.needsUpdate = !0, n && n(e)
                }), e
            }, e.prototype.setEnvironmentTexture = function(e, t) {
                this.environmentSphere.map = e, t && t(e), this.environmentSphere.needsUpdate = !0, e.mapping = i.EquirectangularReflectionMapping, e.needsUpdate = !0, [this.glass, this.whiteMetal, this.blackMetal].map(function(t) {
                    t.envMap = e, t.needsUpdate = !0
                })
            }, e.prototype.setEnvironmentTextureFromUrl = function(e, t) {
                if (e != this.oldEnvironmentTextureUrl) {
                    this.oldEnvironmentTextureUrl = e;
                    (new i.TextureLoader).load(e, function(e) {
                        this.setEnvironmentTexture(e, t)
                    }.bind(this))
                }
            }, e.prototype.setEnvironmentTextureFromFileInput = function(e, t) {
                var n = new FileReader,
                    r = new Image;
                r.onload = function() {
                    var e = new i.Texture(r);
                    e.needsUpdate = !0, this.setEnvironmentTexture(e, t)
                }.bind(this), n.onload = function(e) {
                    r.src = e.target.result
                }, n.readAsDataURL(e.files[0])
            }, e.prototype.loadFromConfig = function(e) {
                return Object.keys(e).map(function(t) {
                    var n = e[t],
                        o = this.whiteChalk.clone();
                    void 0 !== n.color && o.color.setHex(n.color), n.map && n.map.url && this.withTexture(this.whiteChalk, Object(r.c)(n.map.url), function(t) {
                        t.map.wrapS = t.map.wrapT = i.RepeatWrapping;
                        var r = n.map.scale || e.default.map.scale;
                        t.map.repeat.set(r, r), o.map = t.map, n.bump && n.bump.url == n.map.url && (o.bumpMap = o.map, o.bumpMapScale = n.bump.bumpScale || e.default.bump.bumpScale), o.needsUpdate = !0
                    }), n.bump && n.bump.url && n.bump.url !== n.map.url && this.withTexture(this.whiteChalk, Object(r.c)(n.bump.url), function(t) {
                        t.map.wrapS = t.map.wrapT = i.RepeatWrapping;
                        var r = n.map.scale || e.default.bump.scale;
                        t.map.repeat.set(r, r), o.bumpMap = t.map, o.bumpMapScale = n.bump.bumpScale || e.default.bump.bumpScale, o.needsUpdate = !0
                    }), this[t] = o, o.needsUpdate = !0
                }.bind(this)), this
            }, e
        }()
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return i
    });
    var r = n(2),
        i = function() {
            function e() {
                this.items = {};
                var e = [{
                    key: "hof",
                    yawDegrees: 0,
                    deltaX: 0,
                    radius: 3e3,
                    floorHeight: 300,
                    roll: 0
                }, {
                    key: "reynaers",
                    yawDegrees: 90,
                    deltaX: 0,
                    radius: 3e3,
                    floorHeight: 220,
                    roll: 0
                }, {
                    key: "reynaers2",
                    yawDegrees: 0,
                    deltaX: 0,
                    radius: 3e3,
                    floorHeight: 200,
                    roll: 0
                }, {
                    key: "tom",
                    yawDegrees: 78,
                    deltaX: -50,
                    radius: 600,
                    floorHeight: 120,
                    roll: -1
                }, {
                    key: "yves",
                    yawDegrees: 92,
                    deltaX: 100,
                    radius: 650,
                    floorHeight: 80
                }, {
                    key: "lex",
                    yawDegrees: -80,
                    deltaX: 150,
                    radius: 550,
                    floorHeight: 70,
                    roll: 2
                }];
                this.items = {}, e.map(function(e) {
                    var t = e.key + ".jpg";
                    // e.url = Object(r.c)("textures/equirectangular/" + t), this.items[e.key] = e
					e.url = Object(r.c)("" + t), this.items[e.key] = e								   
                }.bind(this))
            }
            return e.prototype.defaultKey = function() {
                return "hof"
            }, e.prototype.updateConfiguration = function(e) {
                this.items[e.key] = e
            }, e.prototype.getConfiguration = function(e) {
                return e = e || this.defaultKey(), this.items[e] || this.items[this.defaultKey()]
            }, e
        }()
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(27),
        o = n(9),
        a = n(15),
        s = n(57),
        c = n(0),
        l = a.a.getRalDict();
    ! function(e) {
        var t = function() {
                function e() {
                    this.obj = new c.Object3D, this.dropTargets = [], this.dropped = [], this.actionableObjects = []
                }
                return e.prototype.add = function(e) {
                    var t = e.obj.position.clone();
                    this.obj.add(e.obj);
                    var n = this.obj.worldToLocal(t);
                    return e.obj.position.copy(n), this.dropTargets = this.dropTargets.concat(e.dropTargets), this.dropped = this.dropped.concat(e.dropped), this.actionableObjects = this.actionableObjects.concat(e.actionableObjects), this
                }, e
            }(),
            n = function() {
                function e(e, t) {
                    this.textures = [], this.cachedPanoMaterials = {}, this.panoCenterMesh = new c.Mesh(new c.SphereBufferGeometry(15), new c.MeshBasicMaterial({
                        color: 8978312
                    })), this.previousDraggableElements = null, this.previousDraggableInput = "abc", this.pngRenderContext = null, this.constVarsCache = {}, this.configGenerator = null, this.boxToVertices = function(e) {
                        return [new c.Vector2(e.min.x, e.min.y), new c.Vector2(e.max.x, e.min.y), new c.Vector2(e.max.x, e.max.y), new c.Vector2(e.min.x, e.max.y)]
                    }, this.materials = t, this.elementBuilder = new i.a.ElementBuilder(e, t)
                }
                return e.prototype.loadTexturesAndMaterial = function(e, t) {
                    var n = this;
                    e = this.parseConfiguration(e, t), e.textures.forEach(function(e) {
                        return n.loadTexture(e)
                    }), e.materials.forEach(function(e) {
                        return n.loadMaterial(e)
                    }), e.elements.filter(function(e) {
                        return e && "meshFromFile" === e.elementType
                    }).forEach(function(t) {
                        n.elementBuilder.buildElement(t.id, t.elementType, t, e)
                    })
                }, e.prototype.notNull = function(e, t) {
                    return e || console.error("missing lookup: " + t), e
                }, e.prototype.build = function(e, n, r, i) {
                    var o = this;
                    void 0 === i && (i = []), n = this.parseConfiguration(n, r);
                    var a = this.notNull(n.models.filter(function(t) {
                        return t.id === e
                    })[0], "model." + e);
                    return n.textures.forEach(function(e) {
                        return o.loadTexture(e)
                    }), n.materials.forEach(function(e) {
                        return o.loadMaterial(e)
                    }), a.buildSteps.reduce(function(e, r) {
                        if (r.disabled) return e;
                        try {
                            if (r.cloneStepWithName) {
                                var o = this.notNull(a.buildSteps.filter(function(e) {
                                    return e.name === r.cloneStepWithName
                                })[0], "buildstep.name = " + r.cloneStepWithName);
                                r = Object.assign({}, o, r)
                            }
                            var s;
                            switch (r.type) {
                                case "siding":
                                    s = this.buildSiding(this.notNull(n.sidings.filter(function(e) {
                                        return e.id === r.id
                                    })[0], "siding.id =" + r.id), n);
                                    break;
                                case "plane":
                                    s = this.buildPlane(this.notNull(n.planes.filter(function(e) {
                                        return e.id === r.id
                                    })[0], "planes.id =" + r.id), n);
                                    break;
                                case "element":
                                    s = this.buildElement(this.notNull(n.elements.filter(function(e) {
                                        return e && e.id === r.id
                                    })[0], "elements.id = " + r.id), n, 0, i);
                                    break;
                                case "placeholder":
                                    s = new t;
                                    break;
                                case "panos":
                                    s = this.buildPanos(n.panos);
                                    break;
                                default:
                                    throw "unknown build step type: " + r.type
                            }
                            s && s.obj && (s.obj.rotateX(Math.PI / 2), s.obj.position.y -= 200, s.obj.name = r.name, r.position && s.obj.position.add((new c.Vector3).fromArray(r.position)), r.rotation && (s.obj.rotation.x += r.rotation[0], s.obj.rotation.y += r.rotation[1], s.obj.rotation.z += r.rotation[2]), r.scale && s.obj.scale.fromArray(r.scale), void 0 !== r.visible && (s.obj.visible = r.visible), i.some(function(e) {
                                return e == r.name
                            }) && s.actionableObjects.push(s.obj), e.add(s))
                        } catch (e) {
                            console.warn("unable to build the following step: \n" + JSON.stringify(r, null, 2) + "\n" + e)
                        }
                        return e
                    }.bind(this), new t)
                }, e.prototype.loadTexture = function(e) {
                    if (!this.textures.filter(function(t) {
                            return t.name === e.id
                        }).length) {
                        var t = (new c.TextureLoader).setPath(contentRoute).load(e.imageUrl);
                        t.name = e.id, t.wrapS = t.wrapT = c.RepeatWrapping, e.repeat ? t.repeat.set(e.repeat.x, e.repeat.y) : t.repeat.set(.01, .01), e.offset && t.offset.set(e.offset.x, e.offset.y), e.wrap && (t.wrapS = e.wrap.x ? c.MirroredRepeatWrapping : c.RepeatWrapping, t.wrapT = e.wrap.y ? c.MirroredRepeatWrapping : c.RepeatWrapping), t.name = e.id, this.textures.push(t)
                    }
                }, e.prototype.loadPanoMaterials = function(e) {
                    var t = this,
                        n = {};
                    return e.forEach(function(e) {
                        if (t.cachedPanoMaterials[e]) n[e] = t.cachedPanoMaterials[e];
                        else {
                            var r = new c.MeshBasicMaterial,
                                i = (new c.TextureLoader).load(e, function() {
                                    r.map = i, r.needsUpdate = !0
                                });
                            n[e] = r
                        }
                    }), this.cachedPanoMaterials = n, this.cachedPanoMaterials
                }, e.prototype.buildPanos = function(e) {
                    var n = this;
                    this.panoCenterMesh.material.depthTest = !1, this.panoCenterMesh.material.transparent = !0, this.panoCenterMesh.position.z = 85;
                    var r = this.loadPanoMaterials(e.map(function(e) {
                            return e.url
                        })),
                        i = new c.SphereGeometry(1, 50, 25),
                        o = new c.Object3D;
                    o.name = "panos", e.forEach(function(e) {
                        var t = new c.Mesh(i, r[e.url]);
                        t.name = "noshading", t.rotation.x -= Math.PI / 2, t.rotation.y += -e.rotation * Math.PI * 2, t.scale.setScalar(100), t.scale.x *= -1;
                        var a = new c.Object3D;
                        a.position.fromArray(e.position), a.position.z *= -230, t.position.z -= (e.camHeight || 145) - 100, a.name = e.label, a.add(t), a.add(n.panoCenterMesh.clone()), o.add(a)
                    });
                    var a = new t;
                    return a.obj = o, a
                }, e.prototype.loadMaterial = function(e) {
                    var t = this,
                        n = function(e, t) {
                            return new Number(e) == e ? e : t
                        },
                        r = function(e) {
                            return t.notNull(t.textures.filter(function(t) {
                                return t.name === e
                            })[0], "textures.name = " + e)
                        },
                        i = {
                            name: e.id,
                            color: e.colorRAL ? l.getHexColor(e.colorRAL) : n(e.colorHex, 16777215),
                            roughness: n(e.roughness, .5),
                            metalness: n(e.metalness, .5)
                        };
                    e.transparent && (i.transparent = !0), e.opacity && (i.transparent = !0, i.opacity = e.opacity), e.useEnvMap && (i.envMap = this.materials.environmentSphere.map), e.map && (i.map = r(e.map.textureId)), e.bump && (i.bumpMap = r(e.bump.textureId), i.bumpScale = n(e.bump.bumpScale, .5)), e.emissiveColorHex && (i.emissive = new c.Color(e.emissiveColorHex)), e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity);
                    var o;
                    e.noShading ? (delete i.roughness, delete i.metalness, o = new c.MeshBasicMaterial(i)) : o = new c.MeshStandardMaterial(i), this.materials[e.id] ? (this.materials[e.id].copy(o), this.materials[e.id].needsUpdate = !0) : this.materials[e.id] = o
                }, e.prototype.buildElement = function(e, n, r, i) {
                    if (e) {
                        var o = new t;
                        return o.obj = this.elementBuilder.buildElement(e.id, e.elementType, e, n, r), o.obj && i && o.obj.traverse(function(e) {
                            i.some(function(t) {
                                return t === e.name
                            }) && o.actionableObjects.push(e)
                        }), o
                    }
                }, e.prototype.buildDraggableElements = function(e, t, n, r) {
                    var i = this,
                        a = Object.assign({}, n.$data),
                        s = JSON.stringify(a) + e.join("$$$$");
                    return null != this.previousDraggableElements && this.previousDraggableInput == s ? this.previousDraggableElements : (this.previousDraggableInput = s, t = this.parseConfiguration(t, n), this.previousDraggableElements = t.draggableElements.filter(function(t) {
                        return t.allowedDropTargets === [] || t.allowedDropTargets.some(function(t) {
                            return e.indexOf(t) > -1
                        })
                    }).map(function(e) {
                        var n = Object.assign({}, t.elements.filter(function(t) {
                                return t && t.id === e.elementId
                            })[0]),
                            a = i.buildElement(n, t, 0, r).obj,
                            s = (new c.Box3).setFromCenterAndSize(new c.Vector3(0, 0, 0), new c.Vector3(n.width, n.height, 0)),
                            l = new o.a.IntersectableObject(a, null, s, null, null, n.asDropTargetUniqueId);
                        return l.mesh.visible = !1, {
                            allowedDropTargets: e.allowedDropTargets,
                            elementId: l.object.name,
                            extendDropArea: e.extendDropArea,
                            id: l.object.name,
                            intersectable: l,
                            originalScale: a.scale,
                            screenScale: e.screenScale || .005,
                            screenPosition: new c.Vector2(0, 0),
                            shouldClone: !0,
                            width: n.width,
                            minWidth: void 0 === n.minWidth ? n.width : n.minWidth,
                            maxWidth: void 0 === n.maxWidth ? n.width : n.maxWidth,
                            height: n.height,
                            minHeight: void 0 === n.minHeight ? n.height : n.minHeight,
                            maxHeight: void 0 === n.maxHeight ? n.height : n.maxHeight,
                            originalBoundingBox: (new c.Box2).setFromCenterAndSize(l.object.position, l.localBoundingBox.getSize()),
                            opts: n.opts,
                            windowOpts: n.window ? n.window.opts || {} : {},
                            float: !!n.float,
                            useMaterialFromDropTarget: e.useMaterialFromDropTarget,
                            asDropTargetId: n.asDropTargetId,
                            asDropTargetUniqueId: null
                        }
                    }), this.previousDraggableElements)
                }, e.prototype.renderToPng = function(e, t) {
                    var n, r, i, o, a, s, l;
                    return r = new c.Scene, r.add(e), i = (new c.Box3).setFromObject(r).expandByScalar(10), n = new c.OrthographicCamera(i.min.x, i.max.x, i.min.y, i.max.y, -100, i.max.z - i.min.z + 200), e.position.z = -(i.max.z - i.min.z) / 2 + 100, l = new c.DirectionalLight, l.position.z = -1, r.add(n), r.add(l), r.updateMatrixWorld(!0), this.pngRenderContext || (this.pngRenderContext = new c.WebGLRenderer({
                        alpha: !0,
                        preserveDrawingBuffer: !0
                    })), o = i.max.x - i.min.x, a = i.max.y - i.min.y, s = t / (o > a ? o : a), this.pngRenderContext.setSize(o * s, a * s), this.pngRenderContext.render(r, n), this.pngRenderContext.domElement.toDataURL("image/png")
                }, e.prototype.buildGlassDecorationBBoxes = function(e, t, n) {
                    return this.elementBuilder.buildGlassDecorationBBoxes(e, t, n)
                }, e.prototype.parseConfiguration_old = function(e, t) {
                    var n = this;
                    t.$set("vars", {});
                    var r = Object.keys(t.$data),
                        i = r.indexOf("vars"),
                        o = r.map(function(e) {
                            return t.$get(e)
                        }),
                        a = Object.keys(this.constVarsCache);
                    o[i];
                    return e.vars.forEach(function(e) {
                        var s = n.constVarsCache[e.id]; - 1 == a.indexOf(e.id) && (s = n.evalFormula(r, e.formula), e.isConstant && (s = s.apply(null, o)), n.constVarsCache[e.id] = s);
                        var c = e.isConstant ? s : s.apply(t, o);
                        o[i][e.id] = c
                    }), t.$set("vars", o[i]), this.parseConfigurationInternal(r, o, e)
                }, e.prototype.parseConfigurationInternal = function(e, t, n) {
                    var r = this;
                    switch (!0) {
                        case Array.isArray(n):
                            return n.map(function(n) {
                                return r.parseConfigurationInternal(e, t, n)
                            });
                        case n instanceof Object:
                            return Object.keys(n).reduce(function(i, o) {
                                return i[o] = r.parseConfigurationInternal(e, t, n[o]), i
                            }, {});
                        case "string" == typeof n && 0 === n.indexOf("$"):
                            var i = n.substring(1);
                            return this.evalFormula(e, i).apply(null, t);
                        default:
                            return n
                    }
                }, e.prototype.evalFormula = function(e, t) {
                    var n = Array.isArray(t) ? t.join("\n") : t;
                    return Function.apply(null, e.concat("return " + n))
                }, e.prototype.parseConfiguration = function(e, t) {
                    if (!this.configGenerator) {
                        var n = "var " + Object.keys(t.$data || t).map(function(e) {
                            return e + "=q." + e
                        }).join(",") + ";\n";
                        n += e.vars.map(function(t) {
                            var n = Array.isArray(t.formula) ? t.formula.join("\n") : t.formula;
                            return new Function("return (" + n + ")"), e.$data ? 'q.$set("vars.' + t.id + '",vars["' + t.id + '"] =(' + n + "))" : '(vars["' + t.id + '"] =(' + n + "))"
                        }).join(",") + ";", n += "return " + this.createGenerator(e), this.configGenerator = this.configGenerator || new Function("q", n)
                    }
                    return this.configGenerator(t)
                }, e.prototype.createGenerator = function(e) {
                    var t = this;
                    switch (!0) {
                        case Array.isArray(e):
                            return "[" + e.map(function(e, n) {
                                return t.createGenerator(e)
                            }).join(",") + "]";
                        case e instanceof Object:
                            return "{" + Object.keys(e).map(function(n) {
                                return '"' + n + '":' + t.createGenerator(e[n])
                            }).join(",") + "}";
                        case "string" == typeof e && 0 === e.indexOf("$"):
                            var n = "(" + e.substring(1) + ")";
                            return new Function(n), n;
                        default:
                            return JSON.stringify(e, null, 2)
                    }
                }, e.prototype.buildShape = function(e) {
                    try {
                        var t;
                        if (e.turtle) t = e.turtle.reduce(function(e, t, n, r) {
                            switch (t.op) {
                                case "move":
                                    var i = (t.parameter || 1) * e.scale;
                                    e.position.add(e.direction.clone().multiplyScalar(i));
                                    break;
                                case "scale":
                                    e.scale = t.parameter || 1;
                                    break;
                                case "turn":
                                    var o;
                                    switch (t.parameter) {
                                        case "left":
                                            o = -90;
                                            break;
                                        case "right":
                                            o = 90;
                                            break;
                                        case "back":
                                            o = 180;
                                            break;
                                        default:
                                            o = parseFloat(t.parameter)
                                    }
                                    o *= Math.PI / 180, e.direction.applyAxisAngle(new c.Vector3(0, 0, 1), o);
                                    break;
                                case "label":
                                    e.vertices.push(e.position.clone()), e.edgeNames.push(t.parameter);
                                    break;
                                default:
                                    console.exception("unknown step type", t)
                            }
                            return n === r.length - 1 && e.vertices.push(e.position), e
                        }.bind(this), {
                            position: new c.Vector3(0, 0, 0),
                            direction: new c.Vector3(0, 1, 0),
                            scale: 1,
                            vertices: [],
                            edgeNames: []
                        });
                        else {
                            if (!e.vertices) throw "need at least a turtle or vertices for shape";
                            t = {
                                vertices: [],
                                edgeNames: []
                            };
                            for (var n = e.vertices, r = 0; r < e.vertices.length; r++) t.vertices.push(new c.Vector3(n[r][0], n[r][1], 0)), t.edgeNames.push(e.id + " edge " + r);
                            t.vertices.push(t.vertices[0].clone()), t.edgeNames.push(e.id + " edge " + r)
                        }
                        e.offset && t.vertices.forEach(function(t) {
                            t.x += e.offset[0], t.y += e.offset[1]
                        }), e.flip && t.vertices.forEach(function(t) {
                            t.x *= e.flip.x ? -1 : 1, t.y *= e.flip.y ? -1 : 1
                        });
                        var i = new s.a.Shape(t.vertices, !1, t.edgeNames);
                        return i.normal.z > 0 && (i = new s.a.Shape(i.verts.slice(0).reverse(), i.isClosed, i.edges.map(function(e) {
                            return e.name
                        }).reverse())), i
                    } catch (t) {
                        throw console.warn("unable to build the following shape: \n" + JSON.stringify(e, null, 2) + "\n" + t), t
                    }
                }, e.prototype.buildBorder = function(e, t, n) {
                    var r = this.notNull(n.shapes.filter(function(e) {
                            return e.id === t.borderShapeId
                        })[0], "shapes.id = " + t.borderShapeId),
                        i = this.buildShape(r);
                    if (t.offset) {
                        var o = new c.Vector3(t.offset.x, t.offset.y, 0);
                        i.verts.forEach(function(e) {
                            return e.add(o)
                        })
                    }
                    var a = this.materials[t.materialId];
                    return this.extrudeShapeOnYPlane(t.borderShapeId, a, i.verts, e.verts, !e.isClosed)
                }, e.prototype.checkLineIntersection = function(e, t, n, r, i, o, a, s) {
                    var c, l, h, u, d, p = {
                        x: null,
                        y: null,
                        onLine1: !1,
                        onLine2: !1
                    };
                    return 0 == (c = (s - o) * (n - e) - (a - i) * (r - t)) ? p : (l = t - o, h = e - i, u = (a - i) * l - (s - o) * h, d = (n - e) * l - (r - t) * h, l = u / c, h = d / c, p.x = e + l * (n - e), p.y = t + l * (r - t), l > 0 && l < 1 && (p.onLine1 = !0), h > 0 && h < 1 && (p.onLine2 = !0), p)
                }, e.prototype.extrudeShapeOnYPlane = function(e, t, n, r, i) {
                    var o = this,
                        a = r.slice(0);
                    a.unshift(a.pop());
                    var s = r.map(function(e, t) {
                            var n = a[t],
                                r = n.clone().sub(e).normalize(),
                                i = r.x;
                            return r.x = -r.y, r.y = i, {
                                vl: e.clone(),
                                vr: n.clone(),
                                i: t,
                                n: r
                            }
                        }),
                        l = n.map(function(e, t) {
                            var n = s.map(function(t, n) {
                                    var r = t.n.clone().multiplyScalar(e.x);
                                    return r.z -= e.y, {
                                        vl: t.vl.clone().add(r),
                                        vr: t.vr.clone().add(r)
                                    }
                                }),
                                r = n.slice(0);
                            return r.unshift(r.pop()), n.reduce(function(e, t, n) {
                                var i = r[n],
                                    a = o.checkLineIntersection(t.vl.x, t.vl.y, t.vr.x, t.vr.y, i.vl.x, i.vl.y, i.vr.x, i.vr.y);
                                return null !== a.x && null !== a.y && e.push(new c.Vector3(a.x, a.y, t.vl.z)), e
                            }, [])
                        }),
                        h = new Float32Array(r.length * n.length * 2 * 3 * 3),
                        u = new Float32Array(r.length * n.length * 2 * 3 * 3),
                        d = new Float32Array(r.length * n.length * 2 * 2 * 3),
                        p = 0,
                        f = 0,
                        m = 0,
                        g = new c.Vector3,
                        v = new c.Vector3,
                        y = n.map(function(e, t, n) {
                            return 0 == t ? 0 : n[t - 1].distanceTo(e)
                        }),
                        b = r.map(function(e, t, n) {
                            return 0 == t ? 0 : n[t - 1].distanceTo(e)
                        });
                    l.forEach(function(e, t, n) {
                        0 !== t && e.forEach(function(e, r, i) {
                            var o = r - 1;
                            o < 0 && (o += i.length);
                            var a = n[t - 1][o],
                                s = y[t - 1],
                                c = b[o],
                                l = n[t - 1][r],
                                x = y[t - 1],
                                w = b[r],
                                _ = n[t][r],
                                M = y[t],
                                E = b[r],
                                T = n[t][o],
                                S = y[t],
                                A = b[o];
                            h[p++] = a.x, h[p++] = a.y, h[p++] = a.z, d[m++] = s, d[m++] = c, h[p++] = _.x, h[p++] = _.y, h[p++] = _.z, d[m++] = M, d[m++] = E, h[p++] = l.x, h[p++] = l.y, h[p++] = l.z, d[m++] = x, d[m++] = w, h[p++] = _.x, h[p++] = _.y, h[p++] = _.z, d[m++] = M, d[m++] = E, h[p++] = a.x, h[p++] = a.y, h[p++] = a.z, d[m++] = s, d[m++] = c, h[p++] = T.x, h[p++] = T.y, h[p++] = T.z, d[m++] = S, d[m++] = A, g.subVectors(a, l), v.subVectors(_, l), g.cross(v), g.normalize();
                            for (var P = g.x, C = g.y, L = g.z, R = 0; R < 6; R++) u[f++] = P, u[f++] = C, u[f++] = L
                        })
                    });
                    var x = new c.BufferGeometry;
                    h = h.slice(0, p), u = u.slice(0, p), x.addAttribute("position", new c.BufferAttribute(h, 3)), x.addAttribute("normal", new c.BufferAttribute(u, 3)), x.addAttribute("uv", new c.BufferAttribute(d, 2)), x.computeBoundingSphere();
                    var w = new c.Mesh(x, t);
                    return w.name = e, w
                }, e.prototype.createDropTargetFromMesh = function(e, t, n, r, i, a, s) {
                    if (e) {
                        var c = new o.a.IntersectableObject(t, e, r, i, a, s);
                        return c.intersectable.mesh.visible = !1, c
                    }
                }, e.prototype.populateDropTargetWithElements = function(e, t, n) {
                    var r = this,
                        i = e.dropTargetId,
                        a = e.intersectable.mesh,
                        s = (new c.Box3).setFromObject(a),
                        l = new c.Box2(new c.Vector2(s.min.x, s.min.y), new c.Vector2(s.max.x, s.max.y)),
                        h = l.getSize();
                    return t.droppedElements.filter(function(t) {
                        return (t.allowedDropTargets === [] || t.allowedDropTargets.indexOf(i) > -1) && (t.droppedOnUniqueId ? t.droppedOnUniqueId === e.asDropTargetUniqueId : t.dropTargetName === a.parent.name)
                    }).map(function(i) {
                        function s(e, t, n, r) {
                            return t <= 0 && (t += r), n <= 0 && (n += r), Math.min(n, Math.max(t, e))
                        }
                        var u = (new c.Vector2).fromArray(i.position || [0, 0]),
                            d = [l];
                        if (e.grid) {
                            d = e.grid;
                            var p = d.filter(function(e) {
                                return e.containsPoint(u)
                            });
                            if (!p.length) return null;
                            l = p[0], h = l.getSize()
                        }
                        var f = r.notNull(t.elements.filter(function(e) {
                                return e && e.id === i.elementId
                            })[0], "elements.id = " + i.elementId),
                            m = Object.assign({}, f);
                        m.minWidth = void 0 === m.minWidth ? m.width : m.minWidth, m.maxWidth = void 0 === m.maxWidth ? m.width : m.maxWidth, m.width = i.width || m.width, m.minHeight = void 0 === m.minHeight ? m.height : m.minHeight, m.maxHeight = void 0 === m.maxHeight ? m.height : m.maxHeight, m.height = i.height || m.height, m.height = s(m.height, m.minHeight, m.maxHeight, h.height), m.width = s(m.width, m.minWidth, m.maxWidth, h.width), i.useMaterialFromDropTarget && (m.baseMaterialId = n);
                        var g = l.clone().expandByVector(new c.Vector2(m.width, m.height).divideScalar(-2));
                        g.isEmpty() ? g.getCenter(u) : u = g.clampPoint(u), m.opts = Object.assign({}, m.opts, i.opts), m.window && i.windowOpts && (m.window.opts = Object.assign({}, m.window.opts, i.windowOpts));
                        var v = r.elementBuilder.buildElement("dropped " + i.elementId, m.elementType, m, t);
                        v.position.set(u.x, u.y, 0), v.rotation.fromArray(i.rotation || [0, 0, 0]);
                        var y = (new c.Box3).setFromCenterAndSize(new c.Vector3(0, 0, 0), new c.Vector3(m.width, m.height, 0)),
                            b = new o.a.IntersectableObject(v, null, y, null, null, i.asDropTargetUniqueId);
                        return a.parent.add(b.object), {
                            id: "dropped " + m.id,
                            allowedDropTargets: i.allowedDropTargets,
                            droppableId: i.droppableId,
                            dropTargetId: i.dropTargetId,
                            dropTargetName: i.dropTargetName,
                            elementId: i.elementId,
                            extendDropArea: i.extendDropArea,
                            intersectable: b,
                            shouldClone: !1,
                            localBoundingBox: b.localBoundingBox,
                            position: i.position,
                            rotation: i.rotation,
                            screenScale: i.screenScale,
                            screenPosition: i.screenPosition,
                            originalScale: v.scale.clone(),
                            minWidth: m.minWidth,
                            maxWidth: m.maxWidth,
                            width: m.width,
                            minHeight: m.minHeight,
                            maxHeight: m.maxHeight,
                            height: m.height,
                            originalBoundingBox: (new c.Box2).setFromCenterAndSize((new c.Vector2).fromArray(i.position), b.localBoundingBox.getSize()),
                            opts: i.opts,
                            windowOpts: i.windowOpts,
                            float: !!i.float,
                            useMaterialFromDropTarget: i.useMaterialFromDropTarget,
                            asDropTargetId: m.asDropTargetId,
                            asDropTargetUniqueId: i.asDropTargetUniqueId,
                            droppedOnUniqueId: i.droppedOnUniqueId
                        }
                    }).filter(function(e) {
                        return !!e
                    })
                }, e.prototype.buildSiding = function(e, n) {
                    var r = this,
                        i = this.notNull(n.shapes.filter(function(t) {
                            return t.id === e.shapeId
                        })[0], "shapes.id = " + e.shapeId),
                        o = this.buildShape(i);
                    o.normal.z > 0 && o.normal.negate();
                    var a = new c.Vector2(0, 0);
                    return o.edges.reduce(function(t, i, o) {
                        var l = i.v1.distanceTo(i.v2);
                        if (l < 1 || e.height <= 0) return t;
                        var h = e.sides.filter(function(e) {
                            return e.id === i.name
                        });
                        if (!h.length) return t;
                        if (!1 === h[0].visible) return t;
                        var u = new s.a.Shape([new c.Vector3(l / 2, e.height, 0), new c.Vector3(l / 2, 0, 0), new c.Vector3(-l / 2, 0, 0), new c.Vector3(-l / 2, e.height, 0)], !0),
                            d = (new c.Box2).setFromPoints(u.verts),
                            p = d.getSize();
                        d = (new c.Box2).setFromCenterAndSize(new c.Vector2(0, 0), p), u.name = i.name;
                        var f = h[0].layerIds;
                        f = Array.isArray(f) ? f : [f];
                        var m = null;
                        return f.forEach(function(o, s) {
                            var l = h[0].dropTargetId,
                                f = r.notNull(n.layers.filter(function(e) {
                                    return e.id === o
                                })[0], "layers.id = " + o),
                                g = (new c.Vector2(0, 0), u);
                            g.name = i.name, f = Object.assign({}, f);
                            var v = -f.thickness - f.height,
                                y = r.holesForDroppedElements(i.name, l, d.clone().expandByScalar(f.expand || 0), n, !1),
                                b = r.buildLayer(g, y, f, n, a, !0);
                            if (0 === s) {
                                if (f.glassDecorationId) {
                                    var x = n.glassDecorations.filter(function(e) {
                                        return e.id === f.glassDecorationId
                                    });
                                    x.length && (m = r.buildGlassDecorationBBoxes(p.width, p.height, x[0]))
                                }
                                r.addDropTargets(b, l, v, g, n, !0, m, f.materialId, null, null)
                            }
                            var w = i.v1.clone().sub(i.v2),
                                _ = Math.atan2(w.y, -w.x);
                            b.obj.rotation.set(-Math.PI / 2, _, 0);
                            var M = i.v1.clone().lerp(i.v2, .5);
                            b.obj.position.x += M.x, b.obj.position.y += M.y - e.height / 2, b.obj.position.z -= M.z + e.height / 2, t.add(b)
                        }), a.x += l, t
                    }, new t)
                }, e.prototype.buildLayer = function(e, n, r, i, o, a) {
                    var s = new t,
                        l = e;
                    r.expand && (l = e.expand(new c.Vector2(r.expand, 0)));
                    var h, u = null;
                    a ? (u = (new c.Matrix4).getInverse(l.localMatrix), h = l.verts.map(function(e) {
                        return (new c.Vector2).fromArray(e.clone().applyMatrix4(u).toArray())
                    })) : h = l.verts.map(function(e) {
                        return new c.Vector2(e.x, e.y)
                    });
                    var d = new c.Shape(h);
                    (new c.Box2).setFromPoints(h);
                    d.holes = n;
                    var p = new c.ExtrudeGeometry(d, {
                            bevelEnabled: !1,
                            steps: 1,
                            amount: r.thickness
                        }),
                        f = new c.Mesh(p, this.materials[r.materialId]);
                    if (f.name = e.name, s.obj.name = e.name, s.obj.add(f), a ? f.position.z += r.height * (a ? 1 : -1) : f.position.z -= r.height + r.thickness, void 0 !== r.visible && (f.visible = !!r.visible), a ? (s.obj.setRotationFromMatrix(e.localMatrix), s.obj.position.setFromMatrixPosition(e.localMatrix), this.elementBuilder.remapUV(f, r.swapUV, o)) : this.elementBuilder.remapUV2(f, r.swapUV, o), s.obj.name = e.name, r.glassDecorationId) {
                        var m = this.notNull(i.glassDecorations.filter(function(e) {
                                return e.id === r.glassDecorationId
                            })[0], "glassDecoration.id =" + r.glassDecorationId),
                            g = (new c.Box2).setFromPoints(h),
                            v = g.getSize(),
                            y = this.elementBuilder.buildGlassDecoration(v.width, v.height, m, i),
                            b = g.getCenter();
                        y.position.copy(f.position).add(new c.Vector3(b.x, 0, b.y)), y.rotation.copy(f.rotation), s.obj.add(y)
                    }
                    return s
                }, e.prototype.holesForDroppedElements = function(e, t, n, r, i, o) {
                    var a = this;
                    return t ? r.droppedElements.filter(function(n) {
                        return n.dropTargetName === e && n.dropTargetId === t
                    }).filter(function(e) {
                        return !e.float
                    }).reduce(function(e, t) {
                        var r = t.localBoundingBox,
                            s = new c.Vector2(r.min.x, r.min.y),
                            l = new c.Vector2(r.max.x, r.max.y),
                            h = new c.Box2(s, l).translate((new c.Vector2).fromArray(t.position)),
                            u = a.boxToVertices(h);
                        return i && (u = u.map(function(e) {
                            return new c.Vector2(-e.y, -e.x)
                        })), o && (i && (o = new c.Vector2(o.x, o.y)), u.forEach(function(e) {
                            return e.add(o)
                        })), e.push(new c.Path(u.map(function(e) {
                            return n.clampPoint(e)
                        }))), e
                    }, []) : []
                }, e.prototype.addDropTargets = function(e, n, r, i, o, a, l, h, u, d) {
                    var p = this;
                    if (n) {
                        var f, m = i.expand(new c.Vector2(-2, 0)).verts,
                            g = i.localMatrix.clone();
                        if (a) {
                            var v = (new c.Matrix4).getInverse(g);
                            f = m.map(function(e) {
                                return (new c.Vector2).fromArray(e.clone().applyMatrix4(v).toArray())
                            })
                        } else f = m.map(function(e) {
                            return new c.Vector2(e.x, e.y)
                        });
                        var y = new c.Shape(f),
                            b = new c.ExtrudeGeometry(y, {
                                bevelEnabled: !1,
                                steps: 1,
                                amount: 3
                            }),
                            x = new c.Mesh(b);
                        x.name = e.obj.name, x.position.z -= r - 3, e.obj.add(x), a && (e.obj.setRotationFromMatrix(i.localMatrix), e.obj.position.setFromMatrixPosition(i.localMatrix)), x.visible = !1;
                        var w = (new c.Box3).setFromPoints(f.map(function(e) {
                                return new c.Vector3(e.x, e.y, 0)
                            })),
                            _ = this.createDropTargetFromMesh(n, x, o, w, l, u, d),
                            M = this.populateDropTargetWithElements(_, o, h);
                        M.forEach(function(e) {
                            return e.intersectable.object.position.z -= 3
                        }), e.dropTargets.push(_), e.dropped = e.dropped.concat(M);
                        var E = (e.obj.children.map(function(e) {
                            return e.localToWorld(new c.Vector3(0, 0, 0))
                        }), new t);
                        M.filter(function(e) {
                            return e.asDropTargetId
                        }).map(function(t) {
                            var n = new c.Vector2(t.position[1], t.position[0]),
                                r = (new c.Box2).setFromCenterAndSize(n, new c.Vector2(t.height, t.width)),
                                i = [new c.Vector3(r.min.y, r.min.x, 0), new c.Vector3(r.min.y, r.max.x, 0), new c.Vector3(r.max.y, r.max.x, 0), new c.Vector3(r.max.y, r.min.x, 0)];
                            p.addDropTargets(e, t.asDropTargetId, 0, new s.a.Shape(i), o, !1, null, h, null, t.asDropTargetUniqueId)
                        }), e.add(E)
                    }
                }, e.prototype.simplifyVerts = function(e) {
                    return e.filter(function(e, t, n) {
                        return n[(t - 1 + n.length) % n.length].distanceToManhattan(e) >= 1
                    }).filter(function(e, t, n) {
                        var r = n[(t - 1 + n.length) % n.length],
                            i = n[(t + 1) % n.length],
                            o = e.x,
                            a = e.y,
                            s = r.x,
                            c = r.y,
                            l = i.x,
                            h = i.y;
                        return o * (c - h) + s * (h - a) + l * (a - c) != 0
                    })
                }, e.prototype.buildPlane = function(e, n) {
                    var r = this,
                        i = this.buildShape(this.notNull(n.shapes.filter(function(t) {
                            return t.id === e.shapeId
                        })[0], "shapes.id =" + e.shapeId)),
                        o = i.verts.map(function(e) {
                            return new c.Vector2(e.x, e.y)
                        });
                    o = this.simplifyVerts(o), i = new s.a.Shape(o.map(function(e) {
                        return new c.Vector3(e.x, e.y, 0)
                    }), i.isClosed);
                    var a = new t,
                        l = (new c.Box2).setFromPoints(o),
                        h = l.getCenter(),
                        u = this.holesForDroppedElements(e.id, e.dropTargetId, l, n, !0, h);
                    if (e.useHolesFrom) {
                        var d = this.notNull(n.planes.filter(function(t) {
                                return t.id === e.useHolesFrom
                            })[0], "planes.id = " + e.useHolesFrom),
                            p = this.buildShape(this.notNull(n.shapes.filter(function(e) {
                                return e.id === d.shapeId
                            })[0], "shapes.id =" + d.shapeId)),
                            f = (new c.Box2).setFromPoints(p.verts.map(function(e) {
                                return new c.Vector2(e.x, e.y)
                            })),
                            m = f.getCenter();
                        u = this.holesForDroppedElements(d.id, d.dropTargetId, f, n, !0, m)
                    }
                    var g, v = 0,
                        y = l.getSize(),
                        b = "";
                    e.layerIds.forEach(function(e, t) {
                        var o = r.notNull(n.layers.filter(function(t) {
                                return t.id === e
                            })[0], "layers.id = " + e),
                            s = r.buildLayer(i, u, o, n, new c.Vector2, !1);
                        if (a.add(s), v = Math.max(v, o.height + o.thickness), o.borderId) {
                            var l = r.notNull(n.borders.filter(function(e) {
                                    return e.id === o.borderId
                                })[0], "border.id =" + o.borderId),
                                d = r.buildBorder(i, l, n);
                            a.obj.add(d), d.position.z -= o.height
                        }
                        if (o.glassDecorationId && 0 == t) {
                            var p = n.glassDecorations.filter(function(e) {
                                return e.id === o.glassDecorationId
                            });
                            p.length && (g = r.buildGlassDecorationBBoxes(y.width, y.height, p[0]).map(function(e) {
                                return e.translate(h)
                            }))
                        }
                        b = b || o.materialId
                    });
                    var x = new t;
                    x.obj.name = e.id;
                    var w = (new c.Box3).setFromPoints(i.verts),
                        _ = new s.a.Shape(this.boxToVertices(w).map(function(e) {
                            return new c.Vector3(e.x, e.y, 0)
                        }), !0);
                    return _.name = i.name, this.addDropTargets(x, e.dropTargetId, -v, _, n, !0, g, b, null, null), a.add(x), a
                }, e
            }();
        e.Builder = n
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(20);
    ! function(e) {
        e.config = {
            data: i.a.defaultData,
            gui: [{
                faIcon: "fa-home",
                activeDropTargetIds: [],
                ui: [{
                    kind: "wrapper",
                    templatePrefix: ["<vsl-logo></vsl-logo>", "<h3>{{$t('step1title1')}}</h3>", "<p>{{$t('step1description1')}}</p>", "<p>{{$t('step1action')}}</p>"]
                }]
            }, {
                faIcon: "fa-cube",
                activeDropTargetIds: [],
                ui: [{
                    key: "style.baseColorRAL",
                    templatePrefix: ["<h4>{{$t('step2title1')}}</h4>"],
                    kind: "ralcode",
                    opts: {
                        label: "step2framecolor"
                    }
                }, {
                    key: "style.roofColorRAL",
                    kind: "ralcode",
                    opts: {
                        label: "step2roofcolor"
                    }
                }, {
                    key: "style.screenColorRAL",
                    kind: "ralcode",
                    opts: {
                        label: "step2screencolor",
                        codes: ["9016", "8017", "9001", "9007", "7016"]
                    }
                }, {
                    key: "size.width",
                    kind: "slider",
                    templatePrefix: ["<h4>{{$t('step2title2')}}</h4>"],
                    opts: {
                        label: "step2width",
                        min: 250,
                        max: 1200,
                        step: 50,
                        unit: "cm"
                    }
                }, {
                    key: "size.depth",
                    kind: "slider",
                    templatePrefix: "",
                    opts: {
                        label: "step2depth",
                        min: 200,
                        max: 800,
                        step: 50,
                        unit: "cm"
                    }
                }, {
                    key: "size.height",
                    kind: "slider",
                    templatePrefix: "",
                    opts: {
                        label: "step2height",
                        min: 180,
                        max: 300,
                        step: 10,
                        unit: "cm"
                    }
                }]
            }, {
                faIcon: "fa-sun-o",
                activeDropTargetIds: ["sideLeft", "sideRight", "sideFront", "sideBack"],
                ui: [{
                    key: "style.screenColorRAL",
                    kind: "ralcode",
                    opts: {
                        label: "step2screencolor",
                        codes: ["9016", "9007", "9017"]
                    },
                    templatePrefix: ["<h3>{{$t('step3title1')}}</h3>", "<p>{{$t('step3description1')}}</p>", "<h4>{{$t('step3title2')}}</h4>"]
                }, {
                    key: "wallHeights.front",
                    kind: "slider",
                    templatePrefix: "<h4>{{$t('step3title3')}}</h4>",
                    opts: {
                        label: "step3front",
                        min: 0,
                        max: 350,
                        step: 10,
                        unit: "cm"
                    }
                }, {
                    key: "wallHeights.back",
                    kind: "slider",
                    opts: {
                        label: "step3back",
                        min: 0,
                        max: 350,
                        step: 10,
                        unit: "cm"
                    }
                }, {
                    key: "wallHeights.left",
                    kind: "slider",
                    opts: {
                        label: "step3left",
                        min: 0,
                        max: 350,
                        step: 10,
                        unit: "cm"
                    }
                }, {
                    key: "wallHeights.right",
                    kind: "slider",
                    opts: {
                        label: "step3right",
                        min: 0,
                        max: 350,
                        step: 10,
                        unit: "cm"
                    }
                }, {
                    kind: "select",
                    key: "style.wallMaterialId",
                    opts: {
                        label: "sideWallMaterial",
                        items: [{
                            key: "brick",
                            label: "sideWallMaterialBrick"
                        }, {
                            key: "stucco",
                            label: "sideWallMaterialStucco"
                        }]
                    }
                }, {
                    key: "style.wallStuccoRalColorId",
                    kind: "ralcode",
                    templatePrefix: "<template v-if='style.wallMaterialId==\"stucco\"'>",
                    templatePostfix: "</template>",
                    opts: {
                        label: "RAL",
                        alwaysExpand: !1
                    }
                }]
            }, {
                faIcon: "fa-camera-retro",
                activeDropTargetIds: [],
                ui: [{
                    key: "homography",
                    kind: "backgroundpic",
                    templatePrefix: ["<h3>{{$t('step4title1')}}</h3>", "<p>{{$t('step4description1')}}</p>"],
                    templatePostfix: "<h4>Info</h4>{{{$t('step4description2')}}}"
                }]
            }, {
                faIcon: "fa-envelope",
                activeDropTargetIds: [],
                ui: [{
                    kind: "contact",
                    opts: {
                        generatePin: !1,
                        redirectAfterPost: !0
                    },
                    templatePrefix: ["<h3>{{$t('Kontakt')}}</h3> <p>{{$t('step6description1')}}</p>"
                  ],
                    templatePostfix: ""
                }]
            }, {
                faIcon: "fa-thumbs-o-up",
                activeDropTargetIds: [],
                ui: [{
                    kind: "contact",
                    opts: {
                        generatePin: !1,
                        redirectAfterPost: !0
                    },
                    templatePrefix: ["<h3>{{$t('step5title1')}}</h3> <p>{{$t('step5description1')}}</p>"
                  ],
                    templatePostfix: ""
                }]
            }],
            floatGui: {
                faIcon: "fa-sun-o",
                activeDropTargetIds: [],
                ui: [{
                    key: "interactive.pctOpen",
                    kind: "slider",
                    templatePrefix: "<i class='fa fa-sun-o' aria-hidden='true'></i><h4>{{$t('sideMenuTitle1')}}</h4 ><template v-if='vars.hasScreens'>",
                    templatePostfix: ["</template>"],
                    opts: {
                        label: "sideMenuScreens",
                        min: 0,
                        max: 100,
                        step: 5,
                        unit: "%"
                    }
                }, {
                    key: "interactive.sunRotation",
                    kind: "slider",
                    opts: {
                        label: "sideMenuSun",
                        min: -180,
                        max: 180,
                        step: 5,
                        unit: "%"
                    }
                }, {
                    key: "interactive.blindsOpenPct",
                    kind: "slider",
                    opts: {
                        label: "sideMenuRoof",
                        min: 0,
                        max: 100,
                        step: 5,
                        unit: "%"
                    }
                }, {
                    key: "interactive.blindsCollapsePct",
                    kind: "slider",
                    opts: {
                        label: "sideMenuExpandCollapse",
                        min: 0,
                        max: 100,
                        step: 5,
                        unit: "%"
                    }
                }, {
                    key: "interactive.ledLight",
                    kind: "checkbox",
                    templatePrefix: "",
                    opts: {
                        label: "sideMenuLEDLights"
                    },
                    templatePostfix: ""
                }, {
                    key: "homography.enabled",
                    kind: "checkbox",
                    templatePrefix: "<template v-if='homography.available'>",
                    opts: {
                        label: "Verwenden Sie das Hintergrundbild"
                    },
                    templatePostfix: "</template>"
                }]
            },
            builders: {
                vars: [{
                    id: "hasScreens",
                    formula: ["elements.droppedElements.some(function(el){", " return el.elementId == 'screen' || el.elementId != 'vast raam';", "})"]
                }, {
                    id: "leftFrontVisible",
                    formula: "Math.max(wallHeights.left,wallHeights.front) < size.height-10"
                }, {
                    id: "rightFrontVisible",
                    formula: "Math.max(wallHeights.right,wallHeights.front) < size.height-10"
                }, {
                    id: "leftBackVisible",
                    formula: "Math.max(wallHeights.left,wallHeights.back) < size.height-10"
                }, {
                    id: "rightBackVisible",
                    formula: "Math.max(wallHeights.right,wallHeights.back) < size.height-10"
                }],
                glassDecorations: [{
                    id: "palen voor/achter",
                    type: "grid",
                    maxGridWidth: 710,
                    maxGridHeight: 400,
                    meshThickness: 12,
                    meshDepth: 10,
                    materialId: "base",
                    offset: [0, 0, 1]
                }, {
                    id: "palen links/rechts",
                    type: "grid",
                    maxGridWidth: 410,
                    maxGridHeight: 400,
                    meshThickness: 12,
                    meshDepth: 10,
                    materialId: "base",
                    offset: [0, 8, 1]
                }, {
                    id: "wall",
                    type: "box",
                    maxGridWidth: 40,
                    maxGridHeight: 40,
                    meshThickness: 2.2,
                    meshDepth: 25,
                    materialId: "$style.wallMaterialId",
                    offset: [18.25, 7, 0]
                }],
                textures: [{
                    id: "brick",
                    imageUrl: "textures/house/RedBrick.jpg"
                }, {
                    id: "crepi bump",
                    imageUrl: "textures/house/CrepiBump.jpg"
                }, {
                    id: "bluestone tiles",
                    imageUrl: "textures/floor/bluestonetiles.jpg"
                }, {
                    id: "fabric",
                    imageUrl: "textures/sidingtypes/fabric.jpg",
                    repeat: {
                        x: .5,
                        y: .5
                    }
                }],
                materials: [{
                    id: "brick",
                    metalness: .1,
                    roughness: .7,
                    map: {
                        textureId: "brick"
                    }
                }, {
                    id: "stucco",
                    metalness: .1,
                    roughness: .7,
                    colorRAL: "$style.wallStuccoRalColorId",
                    bump: {
                        textureId: "crepi bump",
                        bumpScale: 1
                    }
                }, {
                    id: "fabric",
                    bump: {
                        textureId: "fabric",
                        bumpScale: .1
                    },
                    opacity: .93,
                    colorRAL: "$style.screenColorRAL"
                }, {
                    id: "bluestone tiles",
                    metalness: .1,
                    roughness: .7,
                    map: {
                        textureId: "bluestone tiles"
                    },
                    bump: {
                        textureId: "bluestone tiles",
                        bumpScale: .1
                    }
                }, {
                    id: "base",
                    colorRAL: "$style.baseColorRAL",
                    roughness: .4,
                    metalness: .3,
                    useEnvMap: !0
                }, {
                    id: "roof",
                    colorRAL: "$style.roofColorRAL",
                    roughness: .4,
                    metalness: .3,
                    useEnvMap: !0
                }, {
                    id: "ledlight",
                    colorHex: 16777215,
                    roughness: 0,
                    metalness: 0,
                    useEnvMap: !1,
                    emissiveColorHex: 16777215,
                    emissiveIntensity: 1
                }],
                elements: [{
                    id: "diningtable",
                    elementType: "meshFromFile",
                    height: 100,
                    width: 100,
                    opts: {
                        url: "models/diningroom.dae"
                    },
                    baseMaterialId: "blackMetal",
                    swapUV: !1,
                    scale: [4.75, 4.75, 4.75],
                    position: [-80, 0, 0],
                    float: !0,
                    rotation: [Math.PI, 0, 0]
                }, {
                    id: "blinds",
                    elementType: "blinds",
                    baseMaterialId: "roof",
                    height: "$Math.max(size.width,size.depth)-16",
                    width: "$Math.min(size.width,size.depth)-16",
                    opts: {
                        maxShutterWidth: 16,
                        lightMaterialId: "ledlight",
                        openPct: "$interactive.blindsOpenPct",
                        collapsePct: "$interactive.blindsCollapsePct",
                        ledLight: "$interactive.ledLight"
                    },
                    position: [0, 0, -9],
                    rotation: [0, 0, "$size.width<size.depth?0:Math.PI/2"]
                }, {
                    id: "pole",
                    elementType: "pole",
                    height: 12,
                    width: 12,
                    opts: {
                        height: "$size.height"
                    },
                    baseMaterialId: "base",
                    swapUV: !1
                }, {
                    id: "ZIP Screen",
                    baseMaterialId: "fabric",
                    elementType: "horizontalScreen",
                    width: 230,
                    height: 180,
                    pctOpen: "$interactive.pctOpen",
                    minWidth: 0,
                    maxWidth: 0,
                    minHeight: 0,
                    maxHeight: 0
                }, {
                    id: "ZIP Screen Fenster",
                    baseMaterialId: "fabric",
                    elementType: "gondula",
                    width: 230,
                    height: 180,
                    pctOpen: "$interactive.pctOpen",
                    minWidth: 0,
                    maxWidth: 0,
                    minHeight: 0,
                    maxHeight: 0
                }, {
                    id: "Schiebeläden",
                    elementType: "slidingDoorLeft",
                    baseMaterialId: "base",
                    window: {
                        elementType: "window",
                        id: "window",
                        width: 118,
                        height: 180
                    },
                    width: 230,
                    minWidth: 0,
                    maxWidth: 0,
                    height: 180,
                    minHeight: 0,
                    maxHeight: 0,
                    pctOpen: "$interactive.pctOpen",
                    position: [0, -6, -2]
                }, {
                    id: "Festverglasung",
                    elementType: "windowPanel",
                    baseMaterialId: "base",
                    width: 230,
                    minWidth: 0,
                    maxWidth: 0,
                    height: 180,
                    minHeight: 0,
                    maxHeight: 0,
                    position: [0, -6, -2]
                }, {
                    id: "Glasschiebewand",
                    elementType: "slidingGlassDoors",
                    baseMaterialId: "aluminium",
                    height: "$size.height-16",
                    width: 150,
                    minHeight: 0,
                    maxHeight: 0,
                    minWidth: 0,
                    maxWidth: 0,
                    swapUV: !1,
                    pctOpen: "$interactive.pctOpen",
                    position: [0, -6, -2]
                }],
                models: [{
                    id: "patioroof3",
                    buildSteps: [{
                        name: "floor",
                        type: "plane",
                        id: "floor",
                        visible: "$!homography.enabled"
                    }, {
                        name: "shadow floor",
                        type: "plane",
                        id: "shadow floor"
                    }, {
                        name: "pole links voor",
                        type: "element",
                        id: "pole",
                        position: ["$size.width/2-6", "$size.height/2", "$-size.depth/2+6"],
                        visible: "$vars.leftFrontVisible"
                    }, {
                        name: "pole rechts voor",
                        cloneStepWithName: "pole links voor",
                        position: ["$-size.width/2+6", "$size.height/2", "$-size.depth/2+6"],
                        visible: "$vars.rightFrontVisible"
                    }, {
                        name: "pole links achter",
                        cloneStepWithName: "pole links voor",
                        position: ["$size.width/2-6", "$size.height/2", "$size.depth/2-6"],
                        visible: "$vars.leftBackVisible"
                    }, {
                        name: "pole rechts achter",
                        cloneStepWithName: "pole links voor",
                        position: ["$-size.width/2+6", "$size.height/2", "$size.depth/2-6"],
                        visible: "$vars.rightBackVisible"
                    }, {
                        name: "roof",
                        type: "element",
                        id: "$style.roofType",
                        position: [0, "$size.height", 0]
                    }, {
                        name: "top frame",
                        type: "siding",
                        id: "top frame",
                        position: [0, "$size.height", 0]
                    }, {
                        name: "furniture",
                        type: "element",
                        id: "diningtable",
                        position: [0, 0, 0],
                        visible: "$!homography.enabled"
                    }, {
                        name: "gridanchor",
                        type: "placeholder",
                        id: "gridanchor",
                        position: [0, 0, "$size.depth"]
                    }, {
                        name: "sideLeft",
                        type: "siding",
                        id: "sideLeft",
                        position: [0, "$wallHeights.left+6", 0],
                        visible: "$wallHeights.left<=size.height-11"
                    }, {
                        name: "sideRight",
                        type: "siding",
                        id: "sideRight",
                        position: [0, "$wallHeights.right+6", 0],
                        visible: "$wallHeights.right<=size.height-11"
                    }, {
                        name: "sideBack",
                        type: "siding",
                        id: "sideBack",
                        position: [0, "$wallHeights.back+6", 0],
                        visible: "$wallHeights.back<=size.height-11"
                    }, {
                        name: "sideFront",
                        type: "siding",
                        id: "sideFront",
                        position: [0, "$wallHeights.front+6", 0],
                        visible: "$wallHeights.front<=size.height-11"
                    }, {
                        name: "wallLeft",
                        type: "siding",
                        id: "wallLeft",
                        position: [0, 6, 0],
                        visible: "$wallHeights.left>0 && !(wallHeights.left>size.height-10 && homography.enabled)"
                    }, {
                        name: "wallRight",
                        type: "siding",
                        id: "wallRight",
                        position: [0, 6, 0],
                        visible: "$wallHeights.right>0  && !(wallHeights.right>size.height-10 && homography.enabled)"
                    }, {
                        name: "wallBack",
                        type: "siding",
                        id: "wallBack",
                        position: [0, 6, 0],
                        visible: "$wallHeights.back>0  && !(wallHeights.back>size.height-10 && homography.enabled)"
                    }, {
                        name: "wallFront",
                        type: "siding",
                        id: "wallFront",
                        position: [0, 6, 0],
                        visible: "$wallHeights.front>0  && !(wallHeights.front>size.height-10 && homography.enabled)"
                    }, {
                        name: "gridanchor",
                        type: "placeholder",
                        id: "gridanchor",
                        position: [0, 0, 0]
                    }]
                }],
                shapes: [{
                    id: "floorplan",
                    vertices: [
                        ["$-size.width/2", "$size.depth/2"],
                        ["$-size.width/2", "$-size.depth/2"],
                        ["$size.width/2", "$-size.depth/2"],
                        ["$size.width/2", "$size.depth/2"]
                    ]
                }, {
                    id: "sideplan",
                    vertices: [
                        ["$-size.width/2-(wallHeights.right<size.height-10?-6:8)", "$size.depth/2+(wallHeights.back<size.height-10?-6:8)"],
                        ["$-size.width/2-(wallHeights.right<size.height-10?-6:8)", "$-size.depth/2-(wallHeights.front<size.height-10?-6:8)"],
                        ["$size.width/2+(wallHeights.left<size.height-10?-6:8)", "$-size.depth/2-(wallHeights.front<size.height-10?-6:8)"],
                        ["$size.width/2+(wallHeights.left<size.height-10?-6:8)", "$size.depth/2+(wallHeights.back<size.height-10?-6:8)"]
                    ]
                }],
                sidings: [{
                    id: "sideFront",
                    height: "$size.height-wallHeights.front+3",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 2",
                        layerIds: "front/back",
                        dropTargetId: "$size.height>wallHeights.front?'sideFront':''"
                    }]
                }, {
                    id: "sideBack",
                    height: "$size.height-wallHeights.back+3",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 0",
                        layerIds: "front/back",
                        dropTargetId: "$size.height>wallHeights.back?'sideBack':''"
                    }]
                }, {
                    id: "sideLeft",
                    height: "$size.height-wallHeights.left+3",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 3",
                        layerIds: "left/right",
                        dropTargetId: "$size.height>wallHeights.left?'sideLeft':''"
                    }]
                }, {
                    id: "sideRight",
                    height: "$size.height-wallHeights.right+3",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 1",
                        layerIds: "left/right",
                        dropTargetId: "$size.height>wallHeights.right?'sideRight':''"
                    }]
                }, {
                    id: "wallFront",
                    height: "$wallHeights.front>0?wallHeights.front-6:0",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 2",
                        layerIds: "wall"
                    }]
                }, {
                    id: "wallBack",
                    height: "$wallHeights.back>0?wallHeights.back-6:0",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 0",
                        layerIds: "wall"
                    }]
                }, {
                    id: "wallLeft",
                    height: "$wallHeights.left>0?wallHeights.left-6:0",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 3",
                        layerIds: "wall"
                    }]
                }, {
                    id: "wallRight",
                    height: "$wallHeights.right>0?wallHeights.right-6:0",
                    shapeId: "sideplan",
                    sides: [{
                        id: "sideplan edge 1",
                        layerIds: "wall"
                    }]
                }, {
                    id: "top frame",
                    height: 20,
                    shapeId: "floorplan",
                    sides: [{
                        id: "floorplan edge 0",
                        layerIds: "top frame"
                    }, {
                        id: "floorplan edge 1",
                        layerIds: "top frame"
                    }, {
                        id: "floorplan edge 2",
                        layerIds: "top frame"
                    }, {
                        id: "floorplan edge 3",
                        layerIds: "top frame"
                    }]
                }],
                planes: [{
                    id: "floor",
                    shapeId: "floorplan",
                    layerIds: ["floor"]
                }, {
                    id: "shadow floor",
                    shapeId: "floorplan",
                    layerIds: ["shadow plane"]
                }],
                layers: [{
                    id: "floor",
                    materialId: "bluestone tiles",
                    height: 0,
                    expand: 50,
                    thickness: 5
                }, {
                    id: "wall",
                    materialId: "$style.wallMaterialId",
                    height: -7.5,
                    expand: 7.5,
                    thickness: 15
                }, {
                    id: "shadow plane",
                    materialId: "shadowMaterial",
                    height: -5,
                    expand: 5e3,
                    thickness: 1
                }, {
                    id: "front/back",
                    materialId: "base",
                    height: 0,
                    expand: 0,
                    thickness: 1.8,
                    visible: !1,
                    glassDecorationId: "palen voor/achter"
                }, {
                    id: "left/right",
                    materialId: "base",
                    height: 0,
                    expand: 0,
                    thickness: 1.8,
                    visible: !1,
                    glassDecorationId: "palen links/rechts"
                }, {
                    id: "top frame",
                    materialId: "base",
                    height: -10,
                    expand: 0,
                    thickness: 10
                }],
                borders: [],
                droppedElements: "$elements.droppedElements",
                draggableElements: [{
                    elementId: "ZIP Screen",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"]
                }, {
                    elementId: "ZIP Screen Fenster",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"]
                }, {
                    elementId: "Schiebeläden",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"]
                }, {
                    elementId: "Festverglasung",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"]
                }, {
                    elementId: "Glasschiebewand",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"]
                }]
            },
            locales: {
                nl: {
                    sideMenuTitle1: "Interactief",
                    sideMenuScreens: "Screens",
                    sideMenuSun: "Positie Zon",
                    sideMenuRoof: "Lamellen",
                    generalbuttonnext: "Volgende",
                    generalbuttonprevious: "Vorige",
                    generalno: "Neen",
                    generalyes: "Ja",
                    step1title1: "Lamellendak designer",
                    step1description1: "Ontwerp uw eigen lamellendak in een paar minuten tijd, en bekijk het op een foto.",
                    step1action: "Druk op Volgende om te beginnen.",
                    step2title1: "Kies een kleur",
                    step2framecolor: "Basiskleur",
                    step2roofcolor: "Lamellen",
                    step2screencolor: "Screens",
                    step2title2: "Bepaal de afmetingen",
                    step2width: "Breedte",
                    step2depth: "Diepte",
                    step2height: "Hoogte",
                    step3title1: "Screens, deuren en ramen",
                    step3description1: "Faites glisser les bons éléments aux parois désirées.",
                    step3title2: "Kleuren",
                    step3title3: "Muren",
                    step3front: "Voor",
                    step3back: "Achter",
                    step3left: "Links",
                    step3right: "Rechts",
                    step4title1: "Bekijk op foto",
                    step4description1: "Kijk hoe deze overkapping er zou uit zien in uw eigen tuin.",
                    step4description2: "<p>Upload een foto van waar u uw 3D model wilt plaatsen.</p><p>Plaats het 3D model op de gewenste positie door de sliders te veranderen en het model te verslepen.</p><p> Pas de schaal aan door het model te vergroten en te verkleinen met de blauwe knoppen.</p>",
                    Step4browsebutton: "Bestand kiezen",
                    step4description3: "geen bestand gekozen",
                    step5title1: "Uw ontwerp is klaar",
                    step5description1: "Geef uw gegevens door en ontvang een gepersonaliseerd antwoord.",
                    step5name: "Name",
                    step5mail: "email@domain.com",
                    step5street: "Street",
                    step5nr: "nr",
                    step5zip: "zip",
                    step5city: "city",
                    step5phone: "phone",
                    step5remarks: "Opmerkingen",
                    step5savebutton: "Verzenden",
                    step6tiltle1: "3D Configurator",
                    step6description1: "Start een nieuwe configuratie",
                    step6clickbutton: "Start",
                    sideWallMaterial: "Muur",
                    sideWallMaterialBrick: "Baksteen",
                    sideWallMaterialStucco: "Crepi",
                    sideMenuLEDLights: "LED lichten",
                    sideMenuExpandCollapse: "Open- / samen plooien"
                },
                en: {
                    sideMenuTitle1: "Interaction",
                    sideMenuScreens: "Screens",
                    sideMenuSun: "Position Sun",
                    sideMenuRoof: "Louvers",
                    generalbuttonnext: "next",
                    generalbuttonprevious: "back",
                    generalno: "No",
                    generalyes: "Yes",
                    step1title1: "Louvered roof designer",
                    step1description1: "Create your own louvered roof in a few minutes and see it on a picture",
                    step1action: "Click on next to start",
                    step2title1: "Choose a color",
                    step2framecolor: "Base color",
                    step2roofcolor: "Louvers",
                    step2screencolor: "Screens",
                    step2title2: "Dimensions",
                    step2width: "Width",
                    step2depth: "Depth",
                    step2height: "Height",
                    step3title1: "Screens, doors and windows",
                    step3description1: "Drag the elements on the right to the desired sidings.",
                    step3title2: "Colors",
                    step3title3: "Walls",
                    step3front: "Front",
                    step3back: "Back",
                    step3left: "Left",
                    step3right: "Right",
                    step4title1: "Have a look on a picture",
                    step4description1: "Have a look on how the pergola will look in your garden",
                    step4description2: "<p>Upload a phot on which you would like to place your 3D model.</p><p>Put it in position by maneuvering the model and the sliders.</p><p>Adjust the scale of the 3D model by using the blue buttons.</p>",
                    Step4browsebutton: "choose file",
                    step4description3: "no file chosen",
                    step5title1: "Your design is ready",
                    step5description1: "Send your details and get a personalised answer",
                    step5name: "Name",
                    step5mail: "email@domain.com",
                    step5street: "Street",
                    step5nr: "nr",
                    step5zip: "zip",
                    step5city: "city",
                    step5phone: "phone",
                    step5remarks: "",
                    step5savebutton: "sent",
                    step6tiltle1: "3D Configurator",
                    step6description1: "Start a new configurator",
                    step6clickbutton: "Start",
                    sideWallMaterial: "Wall",
                    sideWallMaterialBrick: "Brick",
                    sideWallMaterialStucco: "Stucco",
                    sideMenuLEDLights: "LED lights",
                    sideMenuExpandCollapse: "Expand / Collapse"
                },
                de: {
                    sideMenuTitle1: "Interaktiv",
                    sideMenuScreens: "Markisen",
                    sideMenuSun: "Position der Sonne",
                    sideMenuRoof: "Lamellen",
                    generalbuttonnext: "Weiter",
                    generalbuttonprevious: "Zurück",
                    generalno: "Nein",
                    generalyes: "Ja",
                    step1title1: "Lamellendach Designer",
                    step1description1: "Entwerfen Sie in wenigen Minuten Ihr eigenes Lamellendach und sehen Sie sich das Ergebnis gleich an!",
                    step1action: "Zum Start auf „Weiter“ klicken.",
                    step2title1: "Wählen Sie eine Farbe aus",
                    step2framecolor: "Basisfarbe",
                    step2roofcolor: "Lamellen",
                    step2screencolor: "Markisen",
                    step2title2: "Legen Sie die Grösse fest",
                    step2width: "Breite",
                    step2depth: "Tiefe",
                    step2height: "Höhe",
                    step3title1: "Sonnenschutzmarkisen, Türen und Fenster",
                    step3description1: "Ziehen Sie die richtigen Elemente auf die gewünschten Wände.",
                    step3title2: "Farbe",
                    step3title3: "Mauerwerk",
                    step3front: "Vorn",
                    step3back: "Hinten",
                    step3left: "Links",
                    step3right: "Rechts",
                    step4title1: "Ergebnis ansehen",
                    step4description1: "Sehen Sie sich an, wie diese Überdachung in Ihrem eigenen Garten aussehen würde.",
                    step4description2: "<p>Laden Sie ein Foto von dem Ort hoch, an dem Ihr Entwurf installiert werden soll.</p><p> Positionieren Sie das 3D- Modell an der gewünschten Stelle, indem Sie den Sliders verschieben.</p><p> Passen Sie die Grösse an, indem Sie das Modell mit den blauen icons vergrössern oder verkleinern.</p>",
                    Step4browsebutton: "Datei auswählen",
                    step4description3: "Keine Datei ausgewählt",
                    step5title1: "Ihr Entwurf ist fertig",
                    step5description1: "Gerne können Sie hier ihr Design mit ihrem Hintergrundbild speichern.",
                    step5name: "Name",
                    step5mail: "magers@nachmann.com",
                    step5street: "Strasse",
                    step5nr: "Hausnr.",
                    step5zip: "PLZ",
                    step5city: "Ort",
                    step5phone: "Telefon",
                    step5remarks: "Anmerkungen",
                    step5savebutton: "Absenden",
                    step6tiltle1: "3D-Konfigurator",
                    step6description1: "Eine neue Konfiguration starten",
                    step6clickbutton: "Start",
                    sideWallMaterial: "Wand",
                    sideWallMaterialBrick: "Backstein",
                    sideWallMaterialStucco: "Beton",
                    sideMenuLEDLights: "LED Lichter",
                    sideMenuExpandCollapse: "expandieren / kollabieren"
                },
                fr: {
                    sideMenuTitle1: "Interactif",
                    sideMenuScreens: "Écrans",
                    sideMenuSun: "Position du soleil",
                    sideMenuRoof: "Lames",
                    generalbuttonnext: "Suivant",
                    generalbuttonprevious: "Précédent",
                    generalno: "Non",
                    generalyes: "Oui",
                    step1title1: "Concepteur de toiture à lames",
                    step1description1: "Concevez votre propre toiture à lames en l‘espace de quelques minutes, et visualisez-la sur photo.",
                    step1action: "Cliquez sur Suivant pour commencer.",
                    step2title1: "Choisissez une couleur",
                    step2framecolor: "Base",
                    step2roofcolor: "Lames",
                    step2screencolor: "Écrans",
                    step2title2: "Définissez les dimensions",
                    step2width: "Largeur",
                    step2depth: "Profondeur",
                    step2height: "Hauteur",
                    step3title1: "Écrans pare-soleil, portes et fenêtres",
                    step3description1: "Faites glisser les bons éléments aux parois désirées.",
                    step3title2: "Couleur",
                    step3title3: "Murs",
                    step3front: "Avant",
                    step3back: "Arrière",
                    step3left: "Gauche",
                    step3right: "Droite",
                    step4title1: "Visualisez sur photo",
                    step4description1: "Voyez à quoi ressemblerait cette couverture dans votre jardin.",
                    step4description2: "<p>Chargez une photo de l‘endroit où vous voulez placer votre modèle 3D.</p><p>Positionnez le modèle 3D à l‘endroit souhaité, en déplaçant le model et les sliders.</p><p>Ajustez l‘échelle en agrandissant ou en réduisant le modèle à l‘aide des boutons bleus.<p>",
                    Step4browsebutton: "Sélectionner un fichier",
                    step4description3: "aucun fichier sélectionné",
                    step5title1: "Votre projet est prêt",
                    step5description1: "Indiquez vos coordonnées pour recevoir une réponse personnalisée.",
                    step5name: "Nom",
                    step5mail: "email@domain.com",
                    step5street: "Rue",
                    step5nr: "n°",
                    step5zip: "Code postal",
                    step5city: "Localité",
                    step5phone: "Téléphone",
                    step5remarks: "Remarques",
                    step5savebutton: "Envoyer",
                    step6tiltle1: "Configurateur 3D",
                    step6description1: "Commencer une nouvelle configuration",
                    step6clickbutton: "Début",
                    sideWallMaterial: "Mur",
                    sideWallMaterialBrick: "Brique",
                    sideWallMaterialStucco: "Béton",
                    sideMenuLEDLights: "Lumières LED",
                    sideMenuExpandCollapse: "Plier ouvertes/ensembles"
                }
            }
        }
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r;
    ! function(e) {
        var t = function() {
            function e() {}
            return e
        }();
        e.EditorData = t, e.defaultData = {
            size: {
                width: 350,
                height: 230,
                depth: 250
            },
            style: {
                type: "patioroof3",
                baseColorRAL: "9016",
                roofColorRAL: "9016",
                screenColorRAL: "7016",
                roofAngleDegrees: 10,
                roofType: "blinds",
                wallMaterialId: "stucco",
                wallStuccoRalColorId: "9016"
            },
            wallHeights: {
                front: 0,
                left: 0,
                right: 0,
                back: 0
            },
            elements: {
                droppedElements: [{
                    id: "dropped screen",
                    allowedDropTargets: ["sideLeft", "sideRight", "sideFront", "sideBack"],
                    droppableId: "screen",
                    dropTargetId: "sideBack",
                    dropTargetName: "sideplan edge 0",
                    elementId: "screen",
                    intersectable: {
                        localBoundingBox: {
                            min: {
                                x: -163,
                                y: -110.5
                            },
                            max: {
                                x: 163,
                                y: 110.5
                            }
                        },
                        mesh: null
                    },
                    shouldClone: !1,
                    localBoundingBox: {
                        min: {
                            x: -163,
                            y: -110.5
                        },
                        max: {
                            x: 163,
                            y: 110.5
                        }
                    },
                    position: [0, 0, null],
                    rotation: [0, 0, 0],
                    screenScale: .005,
                    screenPosition: {
                        x: 0,
                        y: 0
                    },
                    originalScale: {
                        x: 1,
                        y: 1,
                        z: 1
                    },
                    minWidth: 0,
                    maxWidth: 0,
                    width: 326,
                    minHeight: 0,
                    maxHeight: 0,
                    height: 221,
                    originalBoundingBox: {
                        min: {
                            x: -163,
                            y: -110.5
                        },
                        max: {
                            x: 163,
                            y: 110.5
                        }
                    },
                    windowOpts: {},
                    float: !1,
                    asDropTargetUniqueId: "jaa175o4bmlsnpi5961q",
                    droppedOnUniqueId: null
                }],
                sides: {
                    back: "screen",
                    front: "screen",
                    left: "screen",
                    right: "screen"
                }
            },
            interactive: {
                blindsCollapsePct: 0,
                pctOpen: 15,
                sunRotation: 0,
                blindsOpenPct: 40,
                ledLight: !0
            },
            contact: {
                name: "",
                street: "",
                housenumber: "",
                zip: "",
                city: "",
                email: "",
                phone: "",
                visitme: !0,
                remark: ""
            },
            meta: {
                id: "",
                designer: "patioroof3",
                wasSubmitted: !1,
                allowPicture: "always"
            },
            homography: {
                position: {
                    x: .5265624999999998,
                    y: .49918749999999995
                },
                rotation: {
                    x: .11272621556370213,
                    y: -1.0094292649401475
                },
                scale: .5290085248221333,
                imageSrc: null,
                enabled: !1,
                available: !1,
                gridsVisible: !1
            },
            vars: {
                hasScreens: !0
            }
        }
    }(r || (r = {}))
}, function(e, t, n) {
    var r = n(0);
    r.MTLLoader = function(e) {
        this.manager = void 0 !== e ? e : r.DefaultLoadingManager
    }, r.MTLLoader.prototype = {
        constructor: r.MTLLoader,
        load: function(e, t, n, i) {
            var o = this,
                a = new r.FileLoader(this.manager);
            a.setPath(this.path), a.load(e, function(e) {
                t(o.parse(e))
            }, n, i)
        },
        setPath: function(e) {
            this.path = e
        },
        setTexturePath: function(e) {
            this.texturePath = e
        },
        setBaseUrl: function(e) {
            console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead."), this.setTexturePath(e)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        setMaterialOptions: function(e) {
            this.materialOptions = e
        },
        parse: function(e) {
            for (var t = e.split("\n"), n = {}, i = /\s+/, o = {}, a = 0; a < t.length; a++) {
                var s = t[a];
                if (s = s.trim(), 0 !== s.length && "#" !== s.charAt(0)) {
                    var c = s.indexOf(" "),
                        l = c >= 0 ? s.substring(0, c) : s;
                    l = l.toLowerCase();
                    var h = c >= 0 ? s.substring(c + 1) : "";
                    if (h = h.trim(), "newmtl" === l) n = {
                        name: h
                    }, o[h] = n;
                    else if (n)
                        if ("ka" === l || "kd" === l || "ks" === l) {
                            var u = h.split(i, 3);
                            n[l] = [parseFloat(u[0]), parseFloat(u[1]), parseFloat(u[2])]
                        } else n[l] = h
                }
            }
            var d = new r.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
            return d.setCrossOrigin(this.crossOrigin), d.setManager(this.manager), d.setMaterials(o), d
        }
    }, r.MTLLoader.MaterialCreator = function(e, t) {
        this.baseUrl = e || "", this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : r.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : r.RepeatWrapping
    }, r.MTLLoader.MaterialCreator.prototype = {
        constructor: r.MTLLoader.MaterialCreator,
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        setManager: function(e) {
            this.manager = e
        },
        setMaterials: function(e) {
            this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
        },
        convert: function(e) {
            if (!this.options) return e;
            var t = {};
            for (var n in e) {
                var r = e[n],
                    i = {};
                t[n] = i;
                for (var o in r) {
                    var a = !0,
                        s = r[o],
                        c = o.toLowerCase();
                    switch (c) {
                        case "kd":
                        case "ka":
                        case "ks":
                            this.options && this.options.normalizeRGB && (s = [s[0] / 255, s[1] / 255, s[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === s[0] && 0 === s[1] && 0 === s[2] && (a = !1)
                    }
                    a && (i[c] = s)
                }
            }
            return t
        },
        preload: function() {
            for (var e in this.materialsInfo) this.create(e)
        },
        getIndex: function(e) {
            return this.nameLookup[e]
        },
        getAsArray: function() {
            var e = 0;
            for (var t in this.materialsInfo) this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
            return this.materialsArray
        },
        create: function(e) {
            return void 0 === this.materials[e] && this.createMaterial_(e), this.materials[e]
        },
        createMaterial_: function(e) {
            function t(e, t) {
                return "string" != typeof t || "" === t ? "" : /^https?:\/\//i.test(t) ? t : e + t
            }

            function n(e, n) {
                if (!a[e]) {
                    var r = i.getTextureParams(n, a),
                        o = i.loadTexture(t(i.baseUrl, r.url));
                    o.repeat.copy(r.scale), o.offset.copy(r.offset), o.wrapS = i.wrap, o.wrapT = i.wrap, a[e] = o
                }
            }
            var i = this,
                o = this.materialsInfo[e],
                a = {
                    name: e,
                    side: this.side
                };
            for (var s in o) {
                var c = o[s];
                if ("" !== c) switch (s.toLowerCase()) {
                    case "kd":
                        a.color = (new r.Color).fromArray(c);
                        break;
                    case "ks":
                        a.specular = (new r.Color).fromArray(c);
                        break;
                    case "map_kd":
                        n("map", c);
                        break;
                    case "map_ks":
                        n("specularMap", c);
                        break;
                    case "map_bump":
                    case "bump":
                        n("bumpMap", c);
                        break;
                    case "ns":
                        a.shininess = parseFloat(c);
                        break;
                    case "d":
                        c < 1 && (a.opacity = c, a.transparent = !0);
                        break;
                    case "Tr":
                        c > 0 && (a.opacity = 1 - c, a.transparent = !0)
                }
            }
            return this.materials[e] = new r.MeshPhongMaterial(a), this.materials[e]
        },
        getTextureParams: function(e, t) {
            var n, i = {
                    scale: new r.Vector2(1, 1),
                    offset: new r.Vector2(0, 0)
                },
                o = e.split(/\s+/);
            return n = o.indexOf("-bm"), n >= 0 && (t.bumpScale = parseFloat(o[n + 1]), o.splice(n, 2)), n = o.indexOf("-s"), n >= 0 && (i.scale.set(parseFloat(o[n + 1]), parseFloat(o[n + 2])), o.splice(n, 4)), n = o.indexOf("-o"), n >= 0 && (i.offset.set(parseFloat(o[n + 1]), parseFloat(o[n + 2])), o.splice(n, 4)), i.url = o.join(" ").trim(), i
        },
        loadTexture: function(e, t, n, i, o) {
            var a, s = r.Loader.Handlers.get(e),
                c = void 0 !== this.manager ? this.manager : r.DefaultLoadingManager;
            return null === s && (s = new r.TextureLoader(c)), s.setCrossOrigin && s.setCrossOrigin(this.crossOrigin), a = s.load(e, n, i, o), void 0 !== t && (a.mapping = t), a
        }
    }
}, function(e, t, n) {
    var r = n(0);
    r.OBJLoader = function(e) {
        this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this.materials = null, this.regexp = {
            vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
            face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
            face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
            face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
            object_pattern: /^[og]\s*(.+)?/,
            smoothing_pattern: /^s\s+(\d+|on|off)/,
            material_library_pattern: /^mtllib /,
            material_use_pattern: /^usemtl /
        }
    }, r.OBJLoader.prototype = {
        constructor: r.OBJLoader,
        load: function(e, t, n, i) {
            var o = this,
                a = new r.FileLoader(o.manager);
            a.setPath(this.path), a.load(e, function(e) {
                t(o.parse(e))
            }, n, i)
        },
        setPath: function(e) {
            this.path = e
        },
        setMaterials: function(e) {
            this.materials = e
        },
        _createParserState: function() {
            var e = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(e, t) {
                    if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t);
                    var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                            name: e || "",
                            fromDeclaration: !1 !== t,
                            geometry: {
                                vertices: [],
                                normals: [],
                                uvs: []
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function(e, t) {
                                var n = this._finalize(!1);
                                n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                var r = {
                                    index: this.materials.length,
                                    name: e || "",
                                    mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                    smooth: void 0 !== n ? n.smooth : this.smooth,
                                    groupStart: void 0 !== n ? n.groupEnd : 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function(e) {
                                        var t = {
                                            index: "number" == typeof e ? e : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return t.clone = this.clone.bind(t), t
                                    }
                                };
                                return this.materials.push(r), r
                            },
                            currentMaterial: function() {
                                if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                            },
                            _finalize: function(e) {
                                var t = this.currentMaterial();
                                if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1)
                                    for (var n = this.materials.length - 1; n >= 0; n--) this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                return e && 0 === this.materials.length && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }), t
                            }
                        }, n && n.name && "function" == typeof n.clone) {
                        var r = n.clone(0);
                        r.inherited = !0, this.object.materials.push(r)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseNormalIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseUVIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 2 * (n >= 0 ? n - 1 : n + t / 2)
                },
                addVertex: function(e, t, n) {
                    var r = this.vertices,
                        i = this.object.geometry.vertices;
                    i.push(r[e + 0]), i.push(r[e + 1]), i.push(r[e + 2]), i.push(r[t + 0]), i.push(r[t + 1]), i.push(r[t + 2]), i.push(r[n + 0]), i.push(r[n + 1]), i.push(r[n + 2])
                },
                addVertexLine: function(e) {
                    var t = this.vertices,
                        n = this.object.geometry.vertices;
                    n.push(t[e + 0]), n.push(t[e + 1]), n.push(t[e + 2])
                },
                addNormal: function(e, t, n) {
                    var r = this.normals,
                        i = this.object.geometry.normals;
                    i.push(r[e + 0]), i.push(r[e + 1]), i.push(r[e + 2]), i.push(r[t + 0]), i.push(r[t + 1]), i.push(r[t + 2]), i.push(r[n + 0]), i.push(r[n + 1]), i.push(r[n + 2])
                },
                addUV: function(e, t, n) {
                    var r = this.uvs,
                        i = this.object.geometry.uvs;
                    i.push(r[e + 0]), i.push(r[e + 1]), i.push(r[t + 0]), i.push(r[t + 1]), i.push(r[n + 0]), i.push(r[n + 1])
                },
                addUVLine: function(e) {
                    var t = this.uvs,
                        n = this.object.geometry.uvs;
                    n.push(t[e + 0]), n.push(t[e + 1])
                },
                addFace: function(e, t, n, r, i, o, a, s, c, l, h, u) {
                    var d, p = this.vertices.length,
                        f = this.parseVertexIndex(e, p),
                        m = this.parseVertexIndex(t, p),
                        g = this.parseVertexIndex(n, p);
                    if (void 0 === r ? this.addVertex(f, m, g) : (d = this.parseVertexIndex(r, p), this.addVertex(f, m, d), this.addVertex(m, g, d)), void 0 !== i) {
                        var v = this.uvs.length;
                        f = this.parseUVIndex(i, v), m = this.parseUVIndex(o, v), g = this.parseUVIndex(a, v), void 0 === r ? this.addUV(f, m, g) : (d = this.parseUVIndex(s, v), this.addUV(f, m, d), this.addUV(m, g, d))
                    }
                    if (void 0 !== c) {
                        var y = this.normals.length;
                        f = this.parseNormalIndex(c, y), m = c === l ? f : this.parseNormalIndex(l, y), g = c === h ? f : this.parseNormalIndex(h, y), void 0 === r ? this.addNormal(f, m, g) : (d = this.parseNormalIndex(u, y), this.addNormal(f, m, d), this.addNormal(m, g, d))
                    }
                },
                addLineGeometry: function(e, t) {
                    this.object.geometry.type = "Line";
                    for (var n = this.vertices.length, r = this.uvs.length, i = 0, o = e.length; i < o; i++) this.addVertexLine(this.parseVertexIndex(e[i], n));
                    for (var a = 0, o = t.length; a < o; a++) this.addUVLine(this.parseUVIndex(t[a], r))
                }
            };
            return e.startObject("", !1), e
        },
        parse: function(e) {
            console.time("OBJLoader");
            var t = this._createParserState(); - 1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
            for (var n = e.split("\n"), i = "", o = "", a = "", s = [], c = "function" == typeof "".trimLeft, l = 0, h = n.length; l < h; l++)
                if (i = n[l], i = c ? i.trimLeft() : i.trim(), 0 !== i.length && "#" !== (o = i.charAt(0)))
                    if ("v" === o)
                        if (" " === (a = i.charAt(1)) && null !== (s = this.regexp.vertex_pattern.exec(i))) t.vertices.push(parseFloat(s[1]), parseFloat(s[2]), parseFloat(s[3]));
                        else if ("n" === a && null !== (s = this.regexp.normal_pattern.exec(i))) t.normals.push(parseFloat(s[1]), parseFloat(s[2]), parseFloat(s[3]));
            else {
                if ("t" !== a || null === (s = this.regexp.uv_pattern.exec(i))) throw new Error("Unexpected vertex/normal/uv line: '" + i + "'");
                t.uvs.push(parseFloat(s[1]), parseFloat(s[2]))
            } else if ("f" === o)
                if (null !== (s = this.regexp.face_vertex_uv_normal.exec(i))) t.addFace(s[1], s[4], s[7], s[10], s[2], s[5], s[8], s[11], s[3], s[6], s[9], s[12]);
                else if (null !== (s = this.regexp.face_vertex_uv.exec(i))) t.addFace(s[1], s[3], s[5], s[7], s[2], s[4], s[6], s[8]);
            else if (null !== (s = this.regexp.face_vertex_normal.exec(i))) t.addFace(s[1], s[3], s[5], s[7], void 0, void 0, void 0, void 0, s[2], s[4], s[6], s[8]);
            else {
                if (null === (s = this.regexp.face_vertex.exec(i))) throw new Error("Unexpected face line: '" + i + "'");
                t.addFace(s[1], s[2], s[3], s[4])
            } else if ("l" === o) {
                var u = i.substring(1).trim().split(" "),
                    d = [],
                    p = [];
                if (-1 === i.indexOf("https://productconfigurator.virtualsaleslab.com/")) d = u;
                else
                    for (var f = 0, m = u.length; f < m; f++) {
                        var g = u[f].split("https://productconfigurator.virtualsaleslab.com/");
                        "" !== g[0] && d.push(g[0]), "" !== g[1] && p.push(g[1])
                    }
                t.addLineGeometry(d, p)
            } else if (null !== (s = this.regexp.object_pattern.exec(i))) {
                var v = (" " + s[0].substr(1).trim()).substr(1);
                t.startObject(v)
            } else if (this.regexp.material_use_pattern.test(i)) t.object.startMaterial(i.substring(7).trim(), t.materialLibraries);
            else if (this.regexp.material_library_pattern.test(i)) t.materialLibraries.push(i.substring(7).trim());
            else {
                if (null === (s = this.regexp.smoothing_pattern.exec(i))) {
                    if ("\0" === i) continue;
                    throw new Error("Unexpected line: '" + i + "'")
                }
                var y = s[1].trim().toLowerCase();
                t.object.smooth = "1" === y || "on" === y;
                var b = t.object.currentMaterial();
                b && (b.smooth = t.object.smooth)
            }
            t.finalize();
            var x = new r.Group;
            x.materialLibraries = [].concat(t.materialLibraries);
            for (var l = 0, h = t.objects.length; l < h; l++) {
                var w = t.objects[l],
                    _ = w.geometry,
                    M = w.materials,
                    E = "Line" === _.type;
                if (0 !== _.vertices.length) {
                    var T = new r.BufferGeometry;
                    T.addAttribute("position", new r.BufferAttribute(new Float32Array(_.vertices), 3)), _.normals.length > 0 ? T.addAttribute("normal", new r.BufferAttribute(new Float32Array(_.normals), 3)) : T.computeVertexNormals(), _.uvs.length > 0 && T.addAttribute("uv", new r.BufferAttribute(new Float32Array(_.uvs), 2));
                    for (var S = [], A = 0, P = M.length; A < P; A++) {
                        var C = M[A],
                            b = void 0;
                        if (null !== this.materials && (b = this.materials.create(C.name), E && b && !(b instanceof r.LineBasicMaterial))) {
                            var L = new r.LineBasicMaterial;
                            L.copy(b), b = L
                        }
                        b || (b = E ? new r.LineBasicMaterial : new r.MeshPhongMaterial, b.name = C.name), b.shading = C.smooth ? r.SmoothShading : r.FlatShading, S.push(b)
                    }
                    var R;
                    if (S.length > 1) {
                        for (var A = 0, P = M.length; A < P; A++) {
                            var C = M[A];
                            T.addGroup(C.groupStart, C.groupCount, A)
                        }
                        R = E ? new r.LineSegments(T, S) : new r.Mesh(T, S)
                    } else R = E ? new r.LineSegments(T, S[0]) : new r.Mesh(T, S[0]);
                    R.name = w.name, x.add(R)
                }
            }
            return console.timeEnd("OBJLoader"), x
        }
    }
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return a
    });
    var r = n(24),
        i = n(0),
        o = n(5),
        a = (n.n(o), function() {
            function e(e, t) {
                this.env = new r.a, this.placeholder = new i.Object3D, this.lookFromObjectTo = function(e, t, n, r, i) {
                    return this.env.lookFromObjectTo(e, t, n, r, i)
                }, this.builder = e, this.backgroundConfigurations = t;
                var n = this.env;
                n.renderer.shadowMap.enabled = !0, n.renderer.shadowMap.type = i.PCFSoftShadowMap, n.renderer.shadowMap.autoUpdate = !0, window.env = n, window.scene = n.scene, window.scene.add(this.placeholder);
                var o = new i.DirectionalLight(16777215, 1);
                o.castShadow = !0;
                var a = o.shadow.camera;
                a.left = -1024, a.right = 1024, a.top = -1024, a.bottom = 1024, a.near = -1024, a.far = 1024, o.shadow.bias = -.0075, o.name = "sun", o.position.set(-.6, 1.08, -1.32), n.scene.add(o);
                var s = new i.AmbientLight(16777215, .3);
                s.position.copy(o.position.clone().negate()), n.scene.add(s), n.controls.rotateSpeed = .5, n.controls.autoRotateSpeed = -.57, n.renderer.domElement.onmousedown = function() {
                    n.controls.autoRotate = !1, n.lookFromOrigin = null
                }, n.renderer.render(n.scene, n.camera)
            }
            return Object.defineProperty(e.prototype, "domElement", {
                get: function() {
                    return this.env.renderer.domElement
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "scene", {
                get: function() {
                    return this.env.scene
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "isStillMoving", {
                get: function() {
                    return this.env.isStillMoving
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "camera", {
                get: function() {
                    return this.env.camera
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "controls", {
                get: function() {
                    return this.env.controls
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.animate = function(e) {
                this.env.animate(e)
            }, e.prototype.clearAnimations = function() {
                this.env.clearAnimations()
            }, e.prototype.setAutoRotate = function(e) {
                this.env.controls.autoRotate = e, e && (this.env.lookFromOrigin = null)
            }, e.prototype.getObjectByName = function(e) {
                return this.env.scene.getObjectByName(e)
            }, e.prototype.setBackgroundConfigurationKey = function(e, t) {
                if (this.backgroundConfigurations) {
                    var n = this.backgroundConfigurations.getConfiguration(e),
                        r = this.builder.backgroundSphere(n.radius, -n.floorHeight);
                    r.position.y -= 210 - n.floorHeight, this.env.setBackgroundMesh(r), this.env.setControlLimits(n.radius - 100, 150 - n.floorHeight), this.builder.setEnvironmentTextureFromUrl(n.url, t), this.env.setBackgroundTexture(null)
                }
            }, e.prototype.setForeGroundScene = function(e) {
                this.env.setForegroundScene(e)
            }, e.prototype.setBackgroundImage = function(e) {
                var t = this,
                    n = function(e) {
                        var n = t.env.controls;
                        n.enabled = n.enableKeys = n.enablePan = n.enableRotate = n.enableZoom = e
                    };
                if (!e) return this.env.setBackgroundTexture(), void n(!0);
                n(!1);
                var r = document.createElement("canvas");
                r.width = window.innerWidth, r.height = window.innerHeight;
                var o = r.getContext("2d"),
                    a = window.innerWidth / window.innerHeight / e.width * e.height,
                    s = 1;
                a > 1 && (s /= a, a = 1);
                var c = window.innerWidth * s,
                    l = window.innerHeight * a,
                    h = (window.innerWidth - c) / 2,
                    u = (window.innerHeight - l) / 2;
                o.drawImage(e, h, u, c, l);
                var d = new i.Texture(r);
                d.needsUpdate = !0, this.env.setBackgroundTexture(d)
            }, e.prototype.addOrReplaceObject = function(e) {
                var t = this.placeholder.getObjectByName(e.name);
                t && this.placeholder.remove(t), this.placeholder.add(e)
            }, e.prototype.lookAtObject = function(e, t, n, r, i) {
                return this.env.lookAtObject(e, t, n, r, i)
            }, e.prototype.lookFromTo = function(e, t, n) {
                return this.env.lookFromTo(e, t, n)
            }, e
        }())
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return c
    });
    var r = n(0),
        i = n(25),
        o = (n.n(i), n(5)),
        a = (n.n(o), n(26)),
        s = (n.n(a), function() {
            function e(e, t, n, i, o, a, s) {
                this.activeCameraChanged = function(e) {}, this.cameraO = new r.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, a, s), this.cameraP = new r.PerspectiveCamera(n, e / t, i, o), this.inOrthographicMode = !0, this.toPerspective()
            }
            return e.prototype.toPerspective = function() {
                this.cameraP.updateMatrixWorld(!1), this.cameraP.updateProjectionMatrix(), this.inOrthographicMode && (this.inPerspectiveMode = !0, this.inOrthographicMode = !1, this.camera = this.cameraP, this.activeCameraChanged(this.camera))
            }, e.prototype.toOrthographic = function() {
                var e = this.cameraP.fov,
                    t = this.cameraP.aspect,
                    n = this.cameraP.near,
                    r = this.cameraP.far,
                    i = (n + r) / 2,
                    o = Math.tan(e * Math.PI / 180 / 2) * i,
                    a = o * t;
                o /= this.cameraP.zoom, a /= this.cameraP.zoom, this.cameraO.left = -a, this.cameraO.right = a, this.cameraO.top = o, this.cameraO.bottom = -o, this.cameraO.view = this.cameraP.view, this.cameraO.updateMatrixWorld(!1), this.cameraO.updateProjectionMatrix(), this.inPerspectiveMode && (this.inPerspectiveMode = !1, this.inOrthographicMode = !0, this.camera = this.cameraO, this.activeCameraChanged(this.camera))
            }, e
        }()),
        c = function() {
            function e(e) {
                var t = this;
                if (this.scene = new r.Scene, this.lookAtTarget = null, this.lookFromOrigin = null, this.lookCallback = null, this.timer = 0, this.controlPositionMaxRadius = 1 / 0, this.controlPositionMinHeight = -1 / 0, this.backgroundScene = null, this.foregroundScene = new r.Object3D, this.renderUsingComposer = null, this.animations = [], this.screenshotAsBase64JPGCallback = null, !i.webgl) return void i.addGetWebGLMessage();
                if (this.renderer = new r.WebGLRenderer({
                        antialias: !0
                    }), this.renderer.setPixelRatio(window.devicePixelRatio), e) {
                    var n = e.getBoundingClientRect();
                    this.renderer.setSize(n.width, n.height)
                } else this.renderer.setSize(window.innerWidth, window.innerHeight);
                var e = e || document.body;
                e.appendChild(this.renderer.domElement), this.cameraCombiner = new s(window.innerWidth, window.innerHeight, 46, 1, 16e3, -16e3, 16e3), this.camera = this.cameraCombiner.cameraP, this.camera.position.set(0, 0, 10), this.scene.add(this.cameraCombiner.cameraP), this.scene.add(this.cameraCombiner.cameraO), this.controls = new r.OrbitControls(this.cameraCombiner.cameraP, this.renderer.domElement), this.cameraCombiner.activeCameraChanged = function(e) {
                    t.camera = e, t.controls.object = e, t.cameraCombiner.inOrthographicMode && (e.zoom = 10)
                }, this.controls.enableDamping = !0, this.backgroundScene = null, window.addEventListener("resize", this.onWindowResize.bind(this), !1), this.controlPositionMaxRadius = 1 / 0, this.controlPositionMinHeight = -1 / 0, this.lookAtTarget = null, this.lookFromOrigin = null, this.renderer.autoClear = !1, this.myAnimate(), this.animate(function() {
                    var e = this.controls.object;
                    e.position.length() > 0 && e.position.clampLength(0, this.controlPositionMaxRadius), e.position.y < this.controlPositionMinHeight && (e.position.y = this.controlPositionMinHeight);
                    return this.lookAtTarget && (this.lookAtTarget.length() > 0 && this.lookAtTarget.clampLength(0, this.controlPositionMaxRadius), this.controls.target.lerp(this.lookAtTarget, .05), this.controls.target.distanceToSquared(this.lookAtTarget) < 25 && (this.lookAtTarget = null)), this.lookFromOrigin && (this.lookFromOrigin.length() > 0 && this.lookFromOrigin.clampLength(0, this.controlPositionMaxRadius), e.position.lerp(this.lookFromOrigin, .05), e.position.distanceToSquared(this.lookFromOrigin) < 25 && (this.lookFromOrigin = null)), !this.lookCallback || this.lookFromOrigin || this.lookAtTarget || (this.lookCallback(), this.lookCallback = null), e.updateProjectionMatrix(), this.controls.update(), !0
                }.bind(this))
            }
            return Object.defineProperty(e.prototype, "isStillMoving", {
                get: function() {
                    return !(!this.lookAtTarget && !this.lookFromOrigin)
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.myAnimate = function() {
                var e = this;
                requestAnimationFrame(this.myAnimate.bind(this)), this.controls.update();
                for (var t = []; this.animations.length > 0;) {
                    var n = this.animations.shift();
                    n(this.timer) && t.push(n)
                }
                this.timer++, this.animations = t;
                var r = this.camera,
                    i = this.renderUsingComposer;
                if (i || (i = function() {
                        e.renderer.clear(!1, !0, !0), e.renderer.render(e.scene, r)
                    }), this.backgroundScene && this.scene.add(this.backgroundScene), this.foregroundScene && (this.scene.add(this.foregroundScene), this.foregroundScene.layers.set(1), this.foregroundScene.traverse(function(e) {
                        return e.layers.set(1)
                    })), this.backgroundScene && (r.layers.set(2), i(), this.renderer.clearDepth()), r.layers.set(0), i(), !this.isStillMoving && this.foregroundScene) {
                    var o = this.scene.background;
                    this.scene.background = null, r.layers.set(1), i(), this.scene.background = o
                }
                r.layers.set(0), this.foregroundScene && this.scene.remove(this.foregroundScene), this.backgroundScene && this.scene.remove(this.backgroundScene), this.screenshotAsBase64JPGCallback && (this.screenshotAsBase64JPGCallback(), this.screenshotAsBase64JPGCallback = null)
            }, e.prototype.initPaperMode = function() {
                var e = this,
                    t = {
                        defaultThickNess: .01,
                        defaultColor: new r.Color(0),
                        defaultAlpha: 1,
                        defaultKeepAlive: !0
                    },
                    n = new r.OutlineEffect(this.renderer, t);
                this.renderUsingComposer = function() {
                    n.render(e.scene, e.camera)
                }
            }, e.prototype.animate = function(e) {
                this.animations.push(e)
            }, e.prototype.clearAnimations = function() {
                for (; this.animations.length > 1;) this.animations.pop()
            }, e.prototype.lookAt = function(e, t, n) {
                return this.lookAtTarget = "object" == typeof e ? e.clone() : new r.Vector3(e, t, n), this
            }, e.prototype.lookFrom = function(e, t, n) {
                return this.lookFromOrigin = "object" == typeof e ? e.clone() : new r.Vector3(e, t, n), this
            }, e.prototype.setControlLimits = function(e, t) {
                this.controlPositionMaxRadius = e, this.controlPositionMinHeight = t
            }, e.prototype.onWindowResize = function() {
                this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight)
            }, e.prototype.screenshotAsBase64EncodedJpg = function(e, t) {
                this.screenshotAsBase64JPGCallback = function() {
                    var n = this.renderer.domElement.toDataURL("image/jpg");
                    if (t && t.resize) {
                        var r = function(e, t, n, r) {
                                var i = r / n;
                                return n >= e && i <= 1 ? (n = e, r = e * i) : r >= t && (r = t, n = t / i), {
                                    width: n,
                                    height: r
                                }
                            },
                            i = new Image;
                        i.onload = function() {
                            var t = document.createElement("canvas");
                            t.width = 640, t.height = 480;
                            var n = t.getContext("2d");
                            n.fillStyle = "black", n.fillRect(0, 0, t.width, t.height);
                            var o = r(t.width, t.height, i.width, i.height),
                                a = (t.width - o.width) / 2,
                                s = (t.height - o.height) / 2;
                            n.drawImage(i, a, s, o.width, o.height);
                            var c = t.toDataURL("image/jpg");
                            return e(c)
                        }, i.src = n
                    } else e(n)
                }
            }, e.prototype.lookFromTo = function(e, t, n) {
                this.lookAt(t), this.lookFrom(e), this.lookCallback = n || this.lookCallback
            }, e.prototype.lookAtObject = function(e, t, n, i, o) {
                var a = this.scene.getObjectByName(e);
                if (a) {
                    this.scene.updateMatrixWorld();
                    var s = new r.Vector3(0, 0, 0),
                        c = "object" == typeof t ? t.clone() : new r.Vector3(t, n, i);
                    a.localToWorld(s), a.localToWorld(c), this.lookFromTo(c, s, o)
                }
            }, e.prototype.lookFromObjectTo = function(e, t, n, i, o) {
                var a = this.scene.getObjectByName(e);
                if (a) {
                    this.scene.updateMatrixWorld();
                    var s = "object" == typeof t ? t.clone() : new r.Vector3(t, n, i),
                        c = new r.Vector3(0, 0, 0);
                    a.localToWorld(c), this.lookFromTo(c, s, o)
                }
            }, e.prototype.lookFromObjectAtObject = function(e, t, n) {
                var i = this.scene.getObjectByName(e),
                    o = this.scene.getObjectByName(t);
                if (i && o) {
                    this.scene.updateMatrixWorld();
                    var a = new r.Vector3(0, 0, 0),
                        s = new r.Vector3(0, 0, 0);
                    o.localToWorld(a), i.localToWorld(s), this.lookFromTo(s, a, n)
                }
            }, e.prototype.setBackgroundMesh = function(e) {
                this.backgroundScene && (this.backgroundScene = null), e && (this.backgroundScene = new r.Object3D, e.layers.set(2), this.backgroundScene.add(e))
            }, e.prototype.setForegroundScene = function(e) {
                this.foregroundScene && (this.foregroundScene = new r.Object3D), e && (this.foregroundScene.add(e), this.foregroundScene.layers.set(1), this.foregroundScene.traverse(function(e) {
                    return e.layers.set(1)
                }))
            }, e.prototype.setBackgroundTexture = function(e) {
                this.scene.background = e
            }, e
        }()
}, function(e, t, n) {
    var r = (n(0), {
        canvas: !!window.CanvasRenderingContext2D,
        webgl: function() {
            try {
                var e = document.createElement("canvas");
                return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl"))
            } catch (e) {
                return !1
            }
        }(),
        workers: !!window.Worker,
        fileapi: window.File && window.FileReader && window.FileList && window.Blob,
        getWebGLErrorMessage: function() {
            var e = document.createElement("div");
            return e.id = "webgl-error-message", e.style.fontFamily = "monospace", e.style.fontSize = "13px", e.style.fontWeight = "normal", e.style.textAlign = "center", e.style.background = "#fff", e.style.color = "#000", e.style.padding = "1.5em", e.style.width = "400px", e.style.margin = "5em auto 0", this.webgl || (e.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")), e
        },
        addGetWebGLMessage: function(e) {
            var t, n, i;
            e = e || {}, t = void 0 !== e.parent ? e.parent : document.body, n = void 0 !== e.id ? e.id : "oldie", i = r.getWebGLErrorMessage(), i.id = n, t.appendChild(i)
        }
    });
    e.exports = r
}, function(e, t, n) {
    var r = n(0);
    r.OutlineEffect = function(e, t) {
        function n() {
            return new r.ShaderMaterial({
                name: "invisible",
                visible: !1
            })
        }

        function i(e) {
            var t, i, o = w[e.type];
            e.outlineParameters;
            if (void 0 !== o) {
                var a = r.ShaderLib[o];
                t = a.uniforms, i = a.vertexShader
            } else if (!0 === e.isRawShaderMaterial) {
                if (t = e.uniforms, i = e.vertexShader, !/attribute\s+vec3\s+position\s*;/.test(i) || !/attribute\s+vec3\s+normal\s*;/.test(i)) return console.warn("THREE.OutlineEffect requires both vec3 position and normal attributes in vertex shader, does not draw outline for " + e.name + "(uuid:" + e.uuid + ") material."), n()
            } else {
                if (!0 !== e.isShaderMaterial) return n();
                t = e.uniforms, i = e.vertexShader
            }
            var s = Object.assign({}, t, _),
                c = i.replace(/void\s+main\s*\(\s*\)/, M + "\nvoid main()").replace(/\}\s*$/, E + "\n}").replace(/#include\s+<[\w_]*light[\w_]*>/g, ""),
                l = {};
            return /vec3\s+transformed\s*=/.test(i) || /#include\s+<begin_vertex>/.test(i) || (l.DECLARE_TRANSFORMED = !0), new r.ShaderMaterial({
                defines: l,
                uniforms: s,
                vertexShader: c,
                fragmentShader: T,
                side: r.BackSide,
                skinning: !1,
                morphTargets: !1,
                morphNormals: !1,
                fog: !1
            })
        }

        function o(e) {
            var t = v[e.uuid];
            return void 0 === t && (t = {
                material: i(e),
                used: !0,
                keepAlive: g,
                count: 0
            }, v[e.uuid] = t), t.used = !0, t.material
        }

        function a(e) {
            var t = o(e);
            return b[t.uuid] = e, u(t, e), t
        }

        function s(e) {
            if (void 0 !== e.material) {
                if (Array.isArray(e.material))
                    for (var t = 0, n = e.material.length; t < n; t++) e.material[t] = a(e.material[t]);
                else e.material = a(e.material);
                x[e.uuid] = e.onBeforeRender, e.onBeforeRender = l
            }
        }

        function c(e) {
            if (void 0 !== e.material) {
                if (Array.isArray(e.material))
                    for (var t = 0, n = e.material.length; t < n; t++) e.material[t] = b[e.material[t].uuid];
                else e.material = b[e.material.uuid];
                e.onBeforeRender = x[e.uuid]
            }
        }

        function l(e, t, n, r, i, o) {
            var a = b[i.uuid];
            void 0 !== a && h(i, a)
        }

        function h(e, t) {
            var n = t.outlineParameters;
            e.uniforms.outlineAlpha.value = t.opacity, void 0 !== n && (void 0 !== n.thickness && (e.uniforms.outlineThickness.value = n.thickness), void 0 !== n.color && e.uniforms.outlineColor.value.copy(n.color), void 0 !== n.alpha && (e.uniforms.outlineAlpha.value = n.alpha))
        }

        function u(e, t) {
            if ("invisible" !== e.name) {
                var n = t.outlineParameters;
                e.skinning = t.skinning, e.morphTargets = t.morphTargets, e.morphNormals = t.morphNormals, e.fog = t.fog, void 0 !== n ? (!1 === t.visible ? e.visible = !1 : e.visible = void 0 === n.visible || n.visible, e.transparent = void 0 !== n.alpha && n.alpha < 1 || t.transparent, void 0 !== n.keepAlive && (v[t.uuid].keepAlive = n.keepAlive)) : (e.transparent = t.transparent, e.visible = t.visible), !0 !== t.wireframe && !1 !== t.depthTest || (e.visible = !1)
            }
        }

        function d() {
            var e;
            e = Object.keys(b);
            for (var t = 0, n = e.length; t < n; t++) b[e[t]] = void 0;
            e = Object.keys(x);
            for (var t = 0, n = e.length; t < n; t++) x[e[t]] = void 0;
            e = Object.keys(v);
            for (var t = 0, n = e.length; t < n; t++) {
                var r = e[t];
                !1 === v[r].used ? (v[r].count++, !1 === v[r].keepAlive && v[r].count > y && delete v[r]) : (v[r].used = !1, v[r].count = 0)
            }
        }
        t = t || {}, this.enabled = !0;
        var p = void 0 !== t.defaultThickness ? t.defaultThickness : .003,
            f = void 0 !== t.defaultColor ? t.defaultColor : new r.Color(0),
            m = void 0 !== t.defaultAlpha ? t.defaultAlpha : 1,
            g = void 0 !== t.defaultKeepAlive && t.defaultKeepAlive,
            v = {},
            y = 60,
            b = {},
            x = {},
            w = {
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical"
            },
            _ = {
                outlineThickness: {
                    type: "f",
                    value: p
                },
                outlineColor: {
                    type: "c",
                    value: f
                },
                outlineAlpha: {
                    type: "f",
                    value: m
                }
            },
            M = ["#include <fog_pars_vertex>", "uniform float outlineThickness;", "vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {", "\tfloat thickness = outlineThickness;", "\tconst float ratio = 1.0;", "\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );", "\tvec4 norm = normalize( pos - pos2 );", "\treturn pos + norm * thickness * pos.w * ratio;", "}"].join("\n"),
            E = ["#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )", "\t#ifndef USE_ENVMAP", "\t\tvec3 objectNormal = normalize( normal );", "\t\t#ifdef FLIP_SIDED", "\t\t\tobjectNormal = -objectNormal;", "\t\t#endif", "\t#endif", "#endif", "#ifdef DECLARE_TRANSFORMED", "\tvec3 transformed = vec3( position );", "#endif", "#ifdef USE_SKINNING", "\tgl_Position = calculateOutline( gl_Position, objectNormal, skinned );", "#else", "\tgl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );", "#endif", "#include <fog_vertex>"].join("\n"),
            T = ["#include <common>", "#include <fog_pars_fragment>", "uniform vec3 outlineColor;", "uniform float outlineAlpha;", "void main() {", "\tgl_FragColor = vec4( outlineColor, outlineAlpha );", "\t#include <fog_fragment>", "}"].join("\n");
        this.render = function(t, n, r, i) {
            if (!1 === this.enabled) return void e.render(t, n, r, i);
            var o = e.autoClear;
            e.autoClear = this.autoClear, e.render(t, n, r, i);
            var a = t.autoUpdate,
                l = t.background,
                h = e.shadowMap.enabled;
            t.autoUpdate = !1, t.background = null, e.autoClear = !1, e.shadowMap.enabled = !1, t.traverse(s), e.render(t, n, r), t.traverse(c), d(), t.autoUpdate = a, t.background = l, e.autoClear = o, e.shadowMap.enabled = h
        }, this.autoClear = e.autoClear, this.domElement = e.domElement, this.shadowMap = e.shadowMap, this.clear = function(t, n, r) {
            e.clear(t, n, r)
        }, this.getPixelRatio = function() {
            return e.getPixelRatio()
        }, this.setPixelRatio = function(t) {
            e.setPixelRatio(t)
        }, this.getSize = function() {
            return e.getSize()
        }, this.setSize = function(t, n, r) {
            e.setSize(t, n, r)
        }, this.setViewport = function(t, n, r, i) {
            e.setViewport(t, n, r, i)
        }, this.setScissor = function(t, n, r, i) {
            e.setScissor(t, n, r, i)
        }, this.setScissorTest = function(t) {
            e.setScissorTest(t)
        }, this.setRenderTarget = function(t) {
            e.setRenderTarget(t)
        }
    }
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(4),
        o = n(2),
        a = n(0),
        s = n(11),
        c = (n.n(s), n(28)),
        l = (n.n(c), n(29)),
        h = (n.n(l), n(45)),
        u = (n.n(h), this && this.__extends || function() {
            var e = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(e, t) {
                e.__proto__ = t
            } || function(e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            };
            return function(t, n) {
                function r() {
                    this.constructor = t
                }
                e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
            }
        }()),
        d = i.a.Builder,
        p = i.a.IntervalBuilder,
        f = d;
    ! function(e) {
        var t = function(e) {
            function t(t, n) {
                var r = e.call(this, t, n) || this;
                return r.elementCache = [], r.loadedMeshes = [], l(Object(o.c)("fonts/Roboto-msdf.json"), function(e, t) {
                    r.MSDFFont = t, (new a.TextureLoader).load(Object(o.c)("fonts/Roboto-msdf.html"), function(e) {
                        r.MSDFTexture = e, r.elementCache = []
                    })
                }), r
            }
            return u(t, e), t.prototype.buildGlassDecoration = function(e, t, n, r) {
                var i, o = this,
                    s = new a.Geometry,
                    c = this.materials[n.materialId],
                    l = (new a.Vector3).fromArray(n.offset || [0, 0, 0]),
                    h = (n.shape || [
                        [-.5, -.5],
                        [.5, -.5],
                        [.5, .5],
                        [-.5, .5]
                    ]).map(function(e) {
                        return (new a.Vector2).fromArray(e)
                    });
                if (n.isSmoothShape) {
                    i = new a.Shape;
                    var u = h.pop();
                    i.moveTo(u.x, u.y), i.splineThru(h)
                } else i = new a.Shape(h);
                var d = new a.ExtrudeGeometry(i, {
                        steps: 1,
                        amount: 1,
                        bevelEnabled: !1
                    }),
                    f = new a.Mesh(d, c);
                switch (f.rotation.x = Math.PI / 2, e += 2 * l.x, t += 2 * l.y, n.type) {
                    case "grid":
                        var m = (new p).withMaxWidth(n.maxGridWidth);
                        n.gridSides && 0 != n.gridSides[0] || (m = m.withoutBorders());
                        var g = f.clone();
                        g.scale.set(n.meshThickness, n.meshDepth, t), m.forRange(0, e).map(function(r) {
                            var i = g.clone();
                            n.stepSize ? i.position.x = Math.round(r / n.stepSize[0]) * n.stepSize[0] - e / 2 : i.position.x = r - e / 2, i.position.z += l.z, i.position.y += t / 2, s.mergeMesh(i)
                        }), m = (new p).withMaxWidth(n.maxGridHeight), n.gridSides && 0 != n.gridSides[1] || (m = m.withoutBorders());
                        var v = f.clone();
                        v.scale.set(n.meshThickness, n.meshDepth, e), v.rotation.y += Math.PI / 2, m.forRange(0, t).map(function(r) {
                            var i = v.clone();
                            i.position.z += l.z, n.stepSize ? i.position.y = Math.round(r / n.stepSize[1]) * n.stepSize[1] - t / 2 : i.position.y = r - t / 2, i.position.x -= e / 2, s.mergeMesh(i)
                        });
                        break;
                    case "panel":
                        var y = this.box("panel", c, e, t, n.meshDepth);
                        y.position.z += l.z, s.mergeMesh(y);
                        break;
                    case "box":
                        t -= l.y;
                        var y = this.box("box", c, e + n.meshThickness, t + n.meshThickness, n.meshDepth);
                        y.position.z += l.z, y.position.y -= l.y, s.mergeMesh(y);
                        break;
                    case "prairie":
                        m = (new p).withFunction(function(e, t) {
                            return [e + 15, t - 15]
                        });
                        var g = this.box("vert", c, n.meshThickness, t, n.meshDepth),
                            v = this.box("vert", c, e, n.meshThickness, n.meshDepth);
                        m.forRange(-e / 2, e / 2).map(function(e) {
                            var t = g.clone();
                            t.position.z += l.z, t.position.x = e, s.mergeMesh(t)
                        }), m.forRange(-t / 2, t / 2).map(function(e) {
                            var t = v.clone();
                            t.position.z += l.z, t.position.y = e, s.mergeMesh(t)
                        })
                }
                var b = new a.Mesh(s, c);
                if (this.remapUV(b), n.elements && n.elements.length > 0 && "grid" === n.type) {
                    var x = function(e, t, n) {
                            return (t - e) * n + e
                        },
                        w = this.buildGlassDecorationBBoxes(e, t, n);
                    n.elements.forEach(function(e) {
                        var t = e.relativePosition || [.5, .5],
                            n = e.absoluteSizeDelta || [0, 0],
                            i = e.offset || [0, 0, 0],
                            s = r.elements.filter(function(t) {
                                return t.id === e.elementId
                            })[0];
                        s = JSON.parse(JSON.stringify(s)), w.forEach(function(e) {
                            var c = e.getSize(),
                                l = new a.Vector2(x(e.min.x, e.max.x, t[0]), x(e.min.y, e.max.y, 1 - t[1]));
                            s.width = c.x + n[0], s.height = c.y + n[1];
                            var h = o.buildElement(s.id, s.elementType, s, r);
                            h.position.x += l.x, h.position.y += l.y, h.position.add(new((u = a.Vector3).bind.apply(u, [void 0].concat(i)))), b.add(h);
                            var u
                        })
                    })
                }
                return b
            }, t.prototype.buildGlassDecorationBBoxes = function(e, t, n) {
                var r = new a.Vector2(e, t),
                    i = r.clone().divideScalar(2),
                    o = i.clone().negate();
                if (!n) return [new a.Box2(o, i)];
                (new a.Vector2).fromArray(n.offset || [0, 0]);
                switch (n.type) {
                    case "grid":
                        for (var s = [], c = Math.ceil(e / n.maxGridWidth), l = Math.ceil(t / n.maxGridHeight), h = e / c, u = t / l, d = n.meshThickness / 2, p = new a.Vector2(h, u), f = p.clone().divideScalar(2), m = (f.clone().negate(), 0); m < l; m++)
                            for (var g = 0; g < c; g++) {
                                var v = p.clone().multiply(new a.Vector2(g, m)),
                                    y = v.clone().add(p);
                                n.stepSize && (v.x = Math.round(v.x / n.stepSize[0]) * n.stepSize[0], v.y = Math.round(v.y / n.stepSize[1]) * n.stepSize[1], y.x = Math.round(y.x / n.stepSize[0]) * n.stepSize[0], y.y = Math.round(y.y / n.stepSize[1]) * n.stepSize[1]);
                                var b = new a.Box2(v.add(o).addScalar(d), y.add(o).addScalar(-d));
                                s.push(b)
                            }
                        return s;
                    default:
                        return [new a.Box2(o, i)]
                }
            }, t.prototype.rotateEl = function(e, t, n, r, i, o, s) {
                e = e.clone(), e.position.x += t, e.position.y += n, e.position.z += r;
                var c = new a.Object3D;
                c.children.push(e), c.rotation.x += i, c.rotation.y += o, c.rotation.z += s, c.position.x -= t, c.position.y -= n, c.position.z -= r;
                var l = new a.Object3D;
                return l.name = name, l.add(c), l
            }, t.prototype.addGlassDecoration = function(e, t, n, r, i) {
                if (!e) return !0;
                var o = t.glassDecorations.filter(function(t) {
                    return t.id === e
                })[0];
                return n.add(this.buildGlassDecoration(r, i, o, t)), "box" != o.type
            }, t.prototype.swapUV = function(e) {
                var t = function(e) {
                    var t = e.geometry;
                    t && t.faceVertexUvs && t.faceVertexUvs[0] && (t.faceVertexUvs[0].forEach(function(e) {
                        return e.forEach(function(e) {
                            return t = [e.y, e.x], e.x = t[0], e.y = t[1], t;
                            var t
                        })
                    }), t.uvsNeedUpdate = !0)
                };
                e.traverse(t)
            }, t.prototype.buildElement = function(e, t, n, r, i, o) {
                var a = void 0;
                if (n)
                    if (n.doNotCache) a = this.buildElementInternal(n.id, n.elementType, n, r, i, o);
                    else {
                        n.constProps && Object.assign(n, n.constProps);
                        var s = JSON.stringify(n),
                            c = this.elementCache.map(function(e) {
                                return e.pars
                            }).indexOf(s);
                        c < 0 || ["meshFromFile", "spriteFromFile", "text"].some(function(e) {
                            return e === n.elementType
                        }) ? (a = this.buildElementInternal(n.id, n.elementType, n, r, i, o), this.elementCache.length > 50 && this.elementCache.pop(), a = a.clone()) : (a = this.elementCache[c].value.clone(), this.elementCache.splice(c)), a.name = e, this.elementCache.unshift({
                            pars: s,
                            value: a.clone()
                        })
                    }
                return a
            }, t.prototype.buildElementInternal = function(e, t, n, r, i, s) {
                var c = this,
                    l = [];
                s = s || this.materials["default element material"], n && (n = Object.assign({}, n), n.baseMaterialId && (s = this.materials[n.baseMaterialId]), i = n.pctOpen || i), i = i || 0;
                var h, u, d, f, m, g, v = i / 100 * Math.PI / 2 * .9,
                    y = v / 8,
                    b = {
                        window: this.bevelXYVectorArray(this.xyRectVerts(7, 4, 0, !0), .5),
                        door: this.bevelXYVectorArray(this.xyRectVerts(12, 4, 0, !0), .5)
                    },
                    x = this.materials.glass;
                n && n.opts && n.opts.fillMaterialId && (x = this.materials[n.opts.fillMaterialId]), this.materials.aluminium || (this.materials.aluminium = this.materials.whiteMetal.clone(), this.materials.aluminium.metalness = .8, this.materials.aluminium.roughness = .6);
                var w = this.materials.aluminium;
                switch (t) {
                    case "meshFromFile":
                    case "spriteFromFile":
                        var _, M = this.loadedMeshes.map(function(e) {
                            return e.id
                        }).indexOf(n.id);
                        if (M < 0) {
                            switch (t) {
                                case "meshFromFile":
                                    var E = [],
                                        T = n.opts.overruleMaterials;
                                    _ = this.loadMesh(n.id, Object(o.c)(n.opts.url), function(e) {
                                        n.opts.overruleMaterials && e.traverse(function(e) {
                                            e.material && (e.material.isMultiMaterial ? e.material.forEach(function(t, n) {
                                                E.push(t), t.name && T[t.name] && (e.material[n] = c.materials[T[t.name]])
                                            }) : (e.material.name && T[e.material.name] && (e.material = c.materials[T[e.material.name]]), E.push(e.material)))
                                        })
                                    });
                                    break;
                                case "spriteFromFile":
                                    _ = this.loadSprite(n.id, Object(o.c)(n.opts.url), n.width, n.height, null);
                                    break;
                                default:
                                    throw "wtf"
                            }
                            this.loadedMeshes.push({
                                id: n.id,
                                mesh: _
                            })
                        } else _ = this.loadedMeshes[M].mesh;
                        l.push([_.clone()]);
                        break;
                    case "text":
                    case "horizontalArrowWithLabel":
                        var S = Object.assign({
                            label: "text",
                            fontSize: 18,
                            font: "Arial",
                            fillColor: "black",
                            strokeColor: "white",
                            strokeSize: 1,
                            labelRotation: [0, 0, 0]
                        }, n.opts);
                        if (_ = this.loadText(n.id, S.label, S.font, S.fontSize, S.fillColor, S.strokeColor, S.strokeSize), _.rotation.fromArray(S.labelRotation), l.push([_]), "horizontalArrowWithLabel" == t) {
                            var A = new a.MeshBasicMaterial({
                                    color: 0
                                }),
                                P = new a.LineBasicMaterial({
                                    color: 0,
                                    linewidth: 2
                                }),
                                C = new a.BufferGeometry;
                            C.addAttribute("position", new a.Float32BufferAttribute([0, -.5, 0, 0, .5, 0], 3));
                            var L = new a.CylinderBufferGeometry(0, .5, 1, 5, 1);
                            L.translate(0, -.5, 0);
                            var R = new a.Line(C, P);
                            R.scale.y = n.width;
                            var I = new a.Line(C, P);
                            I.scale.y = n.height, I.rotation.z = Math.PI / 2;
                            var O = I.clone(),
                                k = new a.Mesh(L, A);
                            k.scale.y = 4 * P.linewidth, k.scale.x = 2 * P.linewidth, k.scale.z = 2 * P.linewidth;
                            var D = k.clone();
                            D.rotation.x = Math.PI, l.push([R], [k, 0, n.width / 2, 0], [D, 0, -n.width / 2, 0], [I, n.height / 2, n.width / 2, 0], [O, n.height / 2, -n.width / 2, 0])
                        }
                        break;
                    case "extrudeShape":
                        var N, B = n.opts.shape.map(function(e) {
                            return (new a.Vector2).fromArray(e)
                        });
                        if (n && n.opts && n.opts.smoothShape) {
                            N = new a.Shape;
                            var U = B.pop();
                            N.moveTo(U.x, U.y), N.splineThru(B)
                        } else N = new a.Shape(B);
                        var F = new a.ExtrudeGeometry(N, {
                                steps: 1,
                                amount: n.opts.height,
                                bevelEnabled: !1
                            }),
                            z = new a.Mesh(F, s);
                        l.push([z]);
                        break;
                    case "element grid":
                        var j = Object.assign({}, n),
                            H = (j.opts.horizontalSplits || []).concat([j.width]).map(function(e) {
                                return e / 10
                            }),
                            V = (j.opts.verticalSplits || []).concat([j.height]).map(function(e) {
                                return e / 10
                            }),
                            G = new a.Object3D;
                        G.name = "elements", j.opts.sections.forEach(function(e, t) {
                            var n = H[e.range.column],
                                o = H[e.range.column + e.range.columnSpan],
                                a = o - n,
                                l = V[e.range.row],
                                h = V[e.range.row + e.range.rowSpan],
                                u = h - l,
                                p = r.elements.filter(function(t) {
                                    return t.id == e.filling
                                });
                            if (p.length) {
                                var f = p[0];
                                f = Object.assign({}, f), f.width = a, f.height = u, f.opts && (f.width += f.opts.deltaWidth || 0, f.height += f.opts.deltaHeight || 0), d = c.buildElementInternal("cell " + e.range.row + ", " + e.range.column, f.elementType, f, r, i, s), d.position.set(n + a / 2, l + u / 2, 0), G.add(d)
                            }
                        }), l.push([G]);
                        break;
                    case "windowPanel":
                        n.opts = n.opts || {};
                        var W = [{
                                height: n.height,
                                glassDecorationId: n.opts.glassDecorationId
                            }],
                            $ = [];
                        if (n.opts) {
                            if (n.opts.windowsHaveT) {
                                var X = n.opts.windowsTHeight || 40;
                                X = Math.min(X, n.height), W[0].height -= X, W.push({
                                    height: X,
                                    glassDecorationId: n.opts.glassDecorationIdForT
                                })
                            }
                            if (n.opts.windowsHaveBottomPanel) {
                                var X = n.opts.windowsBottomPanelHeight || 60;
                                X = Math.min(X, n.height), W[0].height -= X, W.unshift({
                                    height: X,
                                    glassDecorationId: n.opts.glassDecorationIdForBottomPanel
                                })
                            }
                            var q = n.opts.maxWindowPanelWidth || 6e5;
                            if (n.width > q) {
                                var Y = n.width / 2;
                                $ = (new p).withMaxWidth(q).withoutBorders().forRange(-Y, Y)
                            }
                        }
                        var Z = -n.height / 2;
                        W.forEach(function(e) {
                            var t = new a.Object3D,
                                i = $.slice(0);
                            i.unshift(-n.width / 2), i.push(n.width / 2);
                            for (var o = !1, h = 1; h < i.length; h++) {
                                var u = i[h] - i[h - 1],
                                    p = new a.Object3D;
                                t.add(p), p.position.x = (i[h] + i[h - 1]) / 2, o = c.addGlassDecoration(e.glassDecorationId, r, p, u, e.height)
                            }
                            l.push([t, 0, Z + e.height / 2, 0]), o && (d = c.xyFramedPanel("window", s, x, n.width, e.height, b.window), l.push([d, 0, Z + e.height / 2, 0]), $.reduce(function(e, t) {
                                e = e || c.box("vert beam", s, 5, n.height, 5), l.push([e.clone(), t, 0, 0])
                            }, null)), Z += e.height
                        });
                        break;
                    case "doorPanel":
                        h = this.xyFrame("door panel frame", s, n.width - 8, n.height - 8, b.door), u = this.box("door panel", s, n.width - 8, n.height - 8, 1), this.remapUV(u), l.push([h]), l.push([u, 0, 0, 0]);
                        break;
                    case "doorPanelWithGlass":
                        h = this.xyFrame("door panel frame", s, n.width - 8, n.height - 8, b.door);
                        var J = n.height - 8 - n.glassHeight;
                        u = this.box("door panel", s, n.width - 8, J, 1), this.remapUV(u), d = this.xyPanel("door glass", x, n.width - 8, n.glassHeight), this.addGlassDecoration(n.opts.glassDecorationId, r, d, n.width - 16, n.glassHeight - 8);
                        var K = this.box("door glass edge", s, n.width - 16, 10, 2);
                        this.remapUV(K, !0), l.push([h]), l.push([u, 0, -n.glassHeight / 2, 0]), l.push([d, 0, J / 2, 0]), l.push([K, 0, (J - n.glassHeight) / 2, 0]);
                        break;
                    case "glassdecoration":
                        var _ = new a.Object3D;
                        this.addGlassDecoration(n.opts.glassDecorationId, r, _, n.width, n.height), l.push([_]);
                        break;
                    case "windowTop":
                        d = this.buildElementInternal("window panel", "windowPanel", n, r, i, s), f = this.xyFrame("window frame", s, n.width + 7, n.height + 7, b.window), l.push([this.rotateEl(d, 0, -n.height / 2 - 2, 2, -y, 0, 0), 0, 0], [f, 0, 0]);
                        break;
                    case "windowLeft":
                        d = this.buildElementInternal("window panel", "windowPanel", n, r, i, s), f = this.xyFrame("window frame", s, n.width + 7, n.height + 7, b.window), l.push([this.rotateEl(d, n.width / 2 + 2, 0, -2, 0, -v, 0), 0, 0], [f, 0, 0]);
                        break;
                    case "windowRight":
                        d = this.buildElementInternal("window panel", "windowPanel", n, r, i, s), f = this.xyFrame("window frame", s, n.width + 7, n.height + 7, b.window), l.push([this.rotateEl(d, -n.width / 2 - 2, 0, -2, 0, v, 0), 0, 0], [f, 0, 0]);
                        break;
                    case "doubleWindow":
                        n.width = n.width - 12, n.height = n.height - 12, n.window && (n.window.width = n.width / 2, n.window.height = n.height), d = this.buildElementInternal("window panel", "windowPanel", n.window, r, i, s), f = this.xyFrame("window frame", s, 2 * n.window.width + 14, n.window.height + 9, b.window), l.push([this.rotateEl(d, n.window.width / 2 + 2, 0, -2, 0, -v, 0), -n.window.width / 2 - 2, 0], [this.rotateEl(d, -n.window.width / 2 - 2, 0, -2, 0, v, 0), n.window.width / 2 + 2, 0], [f, 0, 0]);
                        break;
                    case "rightDoorWithGlass":
                    case "leftDoorWithGlass":
                    case "rightDoor":
                    case "leftDoor":
                        g = this.xyFrame("door frame", s, n.width + 4, n.height + 2, b.window), l.push([g, 0, 0]);
                        var Q = "leftDoor" === t || "leftDoorWithGlass" === t ? 1 : -1;
                        m = "rightDoor" === t || "leftDoor" === t ? "doorPanel" : "doorPanelWithGlass";
                        var ee = this.buildElementInternal("door panel", m, n, r, i, s),
                            te = this.buildElementInternal("door handle", "handle", null, r, i, s);
                        te.position.x += Q * (n.width / 2 - 12), te.rotation.y = Q < 0 ? 0 : Math.PI, ee.add(te), l.push([this.rotateEl(ee, n.width / 2 * Q, 0, -2 * Q, 0, -v * Q, 0), 0, 0]);
                        break;
                    case "invisibleRightDoor":
                    case "invisibleLeftDoor":
                        h = this.xyFrame("door panel frame", s, n.width - 8, n.height - 8, b.door), u = this.box("door panel", s, n.width, n.height, 1), this.remapUV(u);
                        var ne = this.compose("invisible panel", [
                                [h, 0, 0, -1],
                                [u, 0, 0, 1]
                            ]),
                            te = this.buildElementInternal("door handle", "handle", null, r, i, s),
                            Q = "invisibleRightDoor" === t ? 1 : -1;
                        te.position.x += -Q * (n.width / 2 - 12), te.rotation.y = -Q < 0 ? 0 : Math.PI, ne.add(te), l.push([this.rotateEl(ne, -n.width * Q / 2, 0, 0, 0, v * Q, 0), 0, 0, 0]), l.push([this.box("hack", s, .1, .1, .1), -n.width / 2 * Q, 0, 0]);
                        break;
                    case "invisibleDoubleDoor":
                        ["invisibleRightDoor", "invisibleLeftDoor"].forEach(function(e) {
                            h = c.xyFrame("door panel frame", s, n.width / 2 - 8, n.height - 8, b.door), u = c.box("door panel", s, n.width / 2, n.height, 1), c.remapUV(u);
                            var t = c.compose("invisible panel", [
                                    [h, 0, 0, -1],
                                    [u, 0, 0, 1]
                                ]),
                                o = c.buildElementInternal("door handle", "handle", null, r, i, s),
                                a = "invisibleRightDoor" === e ? 1 : -1;
                            o.position.x += -a * (n.width / 4 - 12), o.rotation.y = -a < 0 ? 0 : Math.PI, t.add(o), l.push([c.rotateEl(t, -n.width * a / 4, 0, 0, 0, v * a, 0), n.width * a / 4, 0, 0])
                        });
                        break;
                    case "doubleDoor":
                    case "doubleDoorWithGlass":
                        g = this.xyFrame("door frame", s, n.width + 4, n.height + 2, b.window), l.push([g, 0, 0]), m = "doubleDoor" === t ? "doorPanel" : "doorPanelWithGlass";
                        var re = Object.assign({}, n);
                        re.width /= 2, re.window && (re.window.width = n.width / 2);
                        var ie = this.buildElementInternal("door panel", m, re, r, i, s),
                            oe = ie.clone(),
                            ae = this.buildElementInternal("door handle", "handle", null, re, i, s);
                        ae.position.x = -(re.width / 2 - 12), ie.add(ae), l.push([this.rotateEl(oe, re.width / 2, 0, -2, 0, -v, 0), -re.width / 2, 0, 0]), l.push([this.rotateEl(ie, -re.width / 2, 0, -2, 0, v, 0), re.width / 2, 0, 0]);
                        break;
                    case "frenchDoors":
                        g = this.xyFrame("door frame", s, n.width + 4, n.height + 2, b.window), l.push([g, 0, 0]);
                        var se = Object.assign({
                                maxPanelWidth: 80,
                                noHandle: !1
                            }, n.opts),
                            re = Object.assign({}, n, n.window),
                            ce = Math.min(n.width / 2, se.maxPanelWidth);
                        re.width = ce, re.height = n.height - 6, re.window && (re.window.width = n.width / 2);
                        var ie = this.buildElementInternal("french door panel", "windowPanel", re, r, i, s),
                            oe = ie.clone();
                        if (!se.noHandle) var ae = this.buildElementInternal("door handle", "handle", null, re, i, s);
                        ae.position.x = -(re.width / 2 - 7.5), ae.position.z = -4, ie.add(ae), l.push([this.rotateEl(oe, re.width / 2, 0, -2, 0, -v, 0), -re.width / 2 - 2, 0, 0]), l.push([this.rotateEl(ie, -re.width / 2, 0, -2, 0, v, 0), re.width / 2 + 2, 0, 0]);
                        var le = n.width / 2 - ce - 2;
                        if (le > 0) {
                            re.width = le;
                            var he = this.buildElementInternal("remainging window", "windowPanel", re, r, i, s);
                            l.push([he, -le / 2 - ce]), l.push([he, +le / 2 + ce])
                        }
                        break;
                    case "pole":
                        var ue = n.opts.thickness || 12,
                            z = this.box("pole", s, ue, n.opts.height || 200, ue);
                        z.rotation.x = Math.PI / 2, this.remapUV(z), l.push([z]);
                        break;
                    case "roundpole":
                        var ue = n.opts.thickness || 12,
                            de = new a.CylinderBufferGeometry(12, 12, n.height, 12),
                            z = new a.Mesh(de, s);
                        l.push([z]);
                        break;
                    case "slidingGlassDoors":
                        var pe = n.width;
                        pe += 6, n.height = n.height + 6;
                        var fe = n.width <= 400 ? 4 : 5,
                            me = pe / fe + 10,
                            ge = this.glassSlidersLeftFrontToRightBack("glass door", this.materials, pe, n.height, fe, me, i),
                            ve = this.box("top rail glass door", s, pe, 8, 6);
                        l.push([ge]), l.push([ve, 0, n.height / 2 - 4, 0]);
                        break;
                    case "slidingDoorLeft":
                    case "slidingDoorRight":
                        n.width = n.width - 14, n.height = n.height - 8, n.window && (n.window.width = n.width / 2, n.window.height = n.height), d = this.buildElementInternal("window panel", "windowPanel", n.window, r, i, s), f = this.xyFrame("window frame", s, n.width + 10, n.window.height + 9, b.window), f.scale.z = 2.5;
                        var ye = "slidingDoorLeft" === t;
                        l.push([d, n.window.width * (.5 - (ye ? i / 100 : 0)), 0, ye ? -4 : 0], [d, -n.window.width * (.5 - (ye ? 0 : i / 100)), 0, ye ? 0 : -4], [f, 0, 0, -2]);
                        break;
                    case "slidingDoorLeft3":
                    case "slidingDoorRight3":
                        n.width = n.width - 14, n.height = n.height - 8, n.window && (n.window.width = n.width / 3, n.window.height = n.height), d = this.buildElementInternal("window panel", "windowPanel", n.window, r, i, s), f = this.xyFrame("window frame", s, n.width + 10, n.window.height + 9, b.window), f.scale.z = 5;
                        var be = "slidingDoorLeft3" === t ? 1 : -1;
                        l.push([d, (-n.width / 2 + n.window.width * (.5 + 2 * (1 - i / 100))) * be, 0, -8], [d, (-n.width / 2 + n.window.width * (.5 + 1 * (1 - i / 100))) * be, 0, -4], [d, (-n.width / 2 + n.window.width * (.5 + 0 * (1 - i / 100))) * be, 0, 0], [f, 0, 0, -6]);
                        break;
                    case "slidingDoorDouble":
                        n.width = n.width - 14, n.height = n.height - 8, n.window && (n.window.width = n.width / 4, n.window.height = n.height), d = this.buildElementInternal("window panel", "windowPanel", n.window, r, i, s), f = this.xyFrame("window frame", s, n.width + 10, n.window.height + 9, b.window), f.scale.z = 2.5, l.push([d, 1.5 * n.window.width, 0, 0], [d, 1.5 * -n.window.width, 0, 0], [d, n.window.width * (.5 + i / 100), 0, -4], [d, -n.window.width * (.5 + i / 100), 0, -4], [f, 0, 0]);
                        break;
                    case "accordeonDoorLeft":
                    case "accordeonDoorRight":
                    case "accordeonDoorMiddle":
                        n.width = n.width - 16, n.height = n.height - 8, f = this.xyFrame("window frame", s, n.width, n.height, b.window), "accordeonDoorMiddle" === t && (n.width /= 2, n.width -= 2);
                        var xe = Math.ceil(n.width / 60),
                            le = (n.width + 12) / xe - 4;
                        n.window && (n.window.width = le, n.window.height = n.height + 4), d = this.buildElementInternal("window panel", "windowPanel", n.window, r, i, s), f.scale.z = 2.5;
                        for (var we = i / 100 * Math.PI / 2, _ = new a.Object3D, _e = 0; _e < xe; _e++) {
                            var Me = d.clone();
                            Me.rotation.y = we * (1 - 2 * (1 & _e)), Me.position.x = -4 - n.width / 2 + (_e + .5) * le * Math.cos(we) + 4 * _e, Me.position.z = -Math.sin(we) * (le / 2), _.add(Me)
                        }
                        switch (l.push(f, 0, -2), t) {
                            case "accordeonDoorLeft":
                                l.push([_]);
                                break;
                            case "accordeonDoorRight":
                                _.rotation.z = Math.PI, _.children.map(function(e) {
                                    e.rotation.z += Math.PI
                                }), l.push([_]);
                                break;
                            case "accordeonDoorMiddle":
                                var Ee = _.clone();
                                Ee.rotation.z = Math.PI, Ee.children.map(function(e) {
                                    e.rotation.z += Math.PI
                                }), l.push([_, -n.width / 2 - 6]), l.push([Ee, n.width / 2 + 6])
                        }
                        break;
                    case "trapezoid":
                        n = Object.assign({}, n);
                        var Y = n.width / 2,
                            Te = n.height / 2,
                            we = n.opts.angle || 5,
                            Se = 0,
                            Ae = Math.sin(we / 180 * Math.PI) * Y * 2;
                        Ae > 0 && (Se = -Ae, Ae = 0);
                        var Pe = [new a.Vector2(-Y, -Te), new a.Vector2(-Y, Te + Se), new a.Vector2(Y, Te + Ae), new a.Vector2(Y, -Te)];
                        Pe.push(Pe[0]), Pe.push(Pe[1]);
                        var Ce = function(e) {
                                return new a.Vector3(e.x, e.y + (Se + Ae) / 2, 0)
                            },
                            Le = this.simplifyVerts(Pe).map(Ce);
                        if (Le.length < 3) break;
                        var Re = this.extrudeShapeOnYPlane("trapezoid border", s, b.window, Le, !1),
                            Ie = this.polygonGeometry(Le);
                        Le = Le.reverse();
                        var Oe = this.polygonGeometry(Le),
                            ke = new a.Mesh(Ie, x),
                            De = new a.Mesh(Oe, x),
                            Ne = -(Se + Ae) / 2;
                        if (l.push([Re, 0, Ne], [ke, 0, Ne], [De, 0, Ne]), n.opts.glassDecorationId) {
                            Le = Pe.map(Ce);
                            var Be = r.glassDecorations.filter(function(e) {
                                    return e.id === n.opts.glassDecorationId
                                })[0],
                                Ue = (new p).withMaxWidth(Be.maxGridWidth).withoutBorders(),
                                Fe = (new p).withMaxWidth(Be.maxGridHeight).withoutBorders(),
                                ze = this.xyRectVerts(Be.meshThickness, Be.meshDepth, 0, !0),
                                je = this.parallelBeamsOverPoly("glass deco", this.materials[Be.materialId], Le, 3, Ue, ze);
                            l.push([je, 0, Ne, 0]);
                            var He = this.parallelBeamsOverPoly("glass deco", this.materials[Be.materialId], Le, 0, Fe, ze);
                            l.push([He, 0, Ne, 0])
                        }
                        break;
                    case "handle":
                        var Ve = this.xyRectVerts(15, 13.5);
                        Ve = this.bevelXYVectorArray(Ve, 1.5);
                        var Ge = this.xyRectVerts(3, 3);
                        Ge.push(Ge[0]), Ge = this.bevelXYVectorArray(Ge, .4 * 1.5);
                        var te = this.extrudeShapeOnYPlane("handle", w, Ge, Ve, !0);
                        te.rotation.x = Math.PI / 2, te.rotation.y = Math.PI, te = this.rotateEl(te, 7.5, 0, 0, 0, 0, -Math.sin(i / 100 * Math.PI) / 2), l.push([te]), l.push([this.box("handle plate", w, 4.5, 12, 7), -7.5, -3]);
                        break;
                    case "dome flat":
                        var We = Object.assign({
                                spanWidth: 60
                            }, n.opts),
                            $e = this.roofDome("roof", "flat", n.width, n.height, s, We.spanWidth);
                        $e.rotation.x = Math.PI / 2, l.push([$e]);
                        break;
                    case "dome saddle":
                        var We = Object.assign({
                                spanWidth: 60
                            }, n.opts),
                            $e = this.roofDome("roof", "saddle", n.width, n.height, s, We.spanWidth);
                        $e.rotation.x = Math.PI / 2, l.push([$e]);
                        break;
                    case "dome pyramid":
                        var We = Object.assign({
                                spanWidth: 60
                            }, n.opts),
                            $e = this.roofDome("roof", "pyramid", n.width, n.height, s, We.spanWidth);
                        $e.rotation.x = Math.PI / 2, l.push([$e]);
                        break;
                    case "dome pyramid simple":
                        var We = Object.assign({
                                spanWidth: 60
                            }, n.opts),
                            Xe = .6 * Math.min(n.width, n.height),
                            $e = this.roofDome("roof", "pyramid", n.width, n.height, s, We.spanWidth, Xe);
                        $e.rotation.x = Math.PI / 2, l.push([$e]);
                        break;
                    case "blinds":
                        n.opts = Object.assign({
                            maxShutterWidth: 20,
                            shutterHeight: 1.8,
                            openPct: 50,
                            collapsePct: 0,
                            ledLight: !1,
                            maxLedLightWidth: 120
                        }, n.opts || {});
                        var qe = (n.opts.openPct || 0) * Math.PI / 100,
                            Ye = this.horizontalShutters("blinds", s, n.opts.maxShutterWidth, n.opts.shutterHeight, qe, n.width, n.height, n.opts.ledLight ? n.opts.lightMaterialId : null, n.opts.collapsePct / 100, n.opts.maxLedLightWidth);
                        Ye.rotation.x = Math.PI / 2, l.push([Ye]);
                        break;
                    case "blindsCurved":
                        n.opts = Object.assign({
                            curvesWidth: 40,
                            curvesThickness: .1,
                            collapsePct: 50
                        }, n.opts || {});
                        var Ze = this.curvedShutters("blindsCurved", s, n.opts.curvesWidth, n.opts.curvesThickness, n.width, n.height, n.opts.collapsePct / 100, n.opts.alwaysVertical);
                        l.push([Ze]);
                        break;
                    case "horizontalBlinds":
                        n.opts = Object.assign({
                            maxShutterWidth: 20,
                            shutterHeight: 1.8,
                            openPct: 50,
                            collapsePct: 0,
                            ledLight: !1,
                            maxLedLightWidth: 120
                        }, n.opts || {});
                        var qe = (n.opts.openPct || 0) * Math.PI / 100,
                            Ye = this.fixedShutters("blinds", s, n.opts.maxShutterWidth, n.opts.shutterHeight, qe, n.height, n.width, n.opts.ledLight ? n.opts.lightMaterialId : null, n.opts.collapsePct / 100, n.opts.maxLedLightWidth);
                        Ye.rotation.y += Math.PI / 2, Ye.rotation.x = Math.PI / 2, l.push([Ye]);
                        break;
                    case "panel":
                        var ue = 2.2;
                        n && n.opts && n.opts.thickness && (ue = n.opts.thickness);
                        var Je = this.box("panel", s, n.width, n.height, ue);
                        l.push([Je]), this.remapUV(Je);
                        break;
                    case "horizontalScreen":
                        var ue = .3;
                        n && n.opts && n.opts.depth && (ue = n.opts.depth);
                        var _ = new a.Object3D,
                            Ke = n.height,
                            Qe = Ke * (100 - i) / 100,
                            Je = this.box("panel", s, n.width, Qe, ue);
                        Je.position.y = Ke - Qe / 2;
                        var ve = this.box("bottom rail", s, n.width, 3, 1);
                        ve.position.y = Ke - Qe - 1.5;
                        var et = this.box("hack", s, .1, .1, .1);
                        et.position.y = n.height / 2, this.remapUV(Je), _.add(Je), _.add(ve), _.add(et), l.push([_, 0, -Ke / 2, 0]);
                        break;
                    case "gondula":
                        var ue = .3,
                            tt = 40;
                        n && n.opts && (n.opts.depth && (ue = n.opts.depth), n.opts.bottomHeight && (tt = n.opts.bottomHeight));
                        var Ke = n.height,
                            Qe = Ke * (100 - i) / 100;
                        if (Qe > tt) {
                            var nt = this.box("glass", x, n.width, Qe - tt, ue);
                            l.push([nt, 0, Ke / 2 - (Qe - tt) / 2, 0])
                        }
                        var J = Math.min(tt, Qe),
                            Je = this.box("panel", s, n.width, J, ue);
                        l.push([Je, 0, Ke / 2 - Qe + J / 2, 0]);
                        var ve = this.box("bottom rail", s, n.width, 3, 1);
                        l.push([ve, 0, Ke / 2 - Qe + 1.5, 0]), this.remapUV(Je);
                        break;
                    case "arc support beams":
                        Qe = n.height, pe = n.width;
                        var rt = {
                            beamShape: [
                                [-4, 0],
                                [-4, 16],
                                [4, 16],
                                [4, 0],
                                [-4, 0]
                            ],
                            beamShapeIsSmooth: !1,
                            maxSpan: 120,
                            profileSize: 8,
                            ballSize: 80,
                            poleRadius: 8,
                            arcRadius: .7 * Qe,
                            arcCenter: {
                                x: 0,
                                y: 0
                            },
                            arcStartAngle: -Math.PI / 10,
                            arcEndAngle: Math.PI / 10
                        };
                        n && n.opts && Object.assign(rt, n.opts);
                        var it = rt.arcRadius,
                            ot = rt.beamShape.map(function(e) {
                                return new a.Vector3(it + e[1] / 1.75 - rt.profileSize / 2, e[0] / 1.75)
                            }),
                            at = new a.LatheBufferGeometry(ot, Math.round(it / 15), rt.arcStartAngle, rt.arcEndAngle - rt.arcStartAngle),
                            st = new a.Mesh(at, s);
                        st.rotation.x = Math.PI / 2, st.rotation.y = Math.PI, st.rotation.z = Math.PI / 2;
                        var ct = this.sphere("koppeling", s, rt.ballSize / 2);
                        ct.position.set(Math.sin(rt.arcStartAngle) * it, 0, Math.cos(rt.arcStartAngle) * it), st.add(ct);
                        var lt = ct.clone();
                        lt.position.set(Math.sin(rt.arcEndAngle) * it, 0, Math.cos(rt.arcEndAngle) * it), st.add(lt);
                        var ht = (new p).withMaxWidth(rt.maxSpan);
                        ht.forRange(-pe / 2, pe / 2).forEach(function(e) {
                            l.push([st, e, rt.arcCenter.x, rt.arcCenter.y])
                        });
                        break;
                    case "arc roof":
                        Qe = n.height, pe = n.width;
                        var ut = (new a.Object3D, {
                            beamShape: [
                                [-3.5, 0],
                                [-3.5, 5.5],
                                [3.5, 5.5],
                                [3.5, 0],
                                [-4, 0]
                            ],
                            beamShapeIsSmooth: !1,
                            maxSpan: 60,
                            glassMaterialId: "glass",
                            glassBackMaterialId: null,
                            profileSize: 8,
                            ballSize: 8,
                            poleRadius: 8,
                            arcRadius: .7 * Qe,
                            arcCenter: {
                                x: 0,
                                y: 0
                            },
                            arcStartAngle: -Math.PI / 10,
                            arcEndAngle: Math.PI / 10,
                            arcSupportCount: 4,
                            arcSupportOffsetStartAngle: 0,
                            arcSupportOffsetEndAngle: 0
                        });
                        n && n.opts && Object.assign(ut, n.opts);
                        var it = ut.arcRadius + 9,
                            dt = new a.CylinderGeometry(it, it, pe, Math.round(it / 4), 4, !0, ut.arcStartAngle + Math.PI, ut.arcEndAngle - ut.arcStartAngle),
                            ke = new a.Mesh(dt, this.materials[ut.glassMaterialId]),
                            pt = this.materials[ut.glassBackMaterialId || ut.glassMaterialId].clone();
                        pt.side = a.BackSide;
                        var De = new a.Mesh(dt, pt);
                        De.rotation.x = ke.rotation.x = Math.PI / 2, De.rotation.z = ke.rotation.z = -Math.PI / 2, l.push([ke, 0, ut.arcCenter.x, ut.arcCenter.y]), l.push([De, 0, ut.arcCenter.x, ut.arcCenter.y]);
                        var B = ut.beamShape.map(function(e) {
                                return new a.Vector2(e[0] - ut.ballSize, e[1])
                            }),
                            N = new a.Shape(B),
                            F = new a.ExtrudeGeometry(N, {
                                steps: 1,
                                amount: pe - 10,
                                bevelEnabled: !1
                            }),
                            z = new a.Mesh(F, s);
                        it -= 6;
                        var ft = (ut.arcRadius, ut.arcEndAngle, ut.arcStartAngle, ut.arcSupportCount + 2),
                            ht = (new p).withCount(ft).withoutBorders();
                        ht.forRange(ut.arcStartAngle + ut.arcSupportOffsetStartAngle, ut.arcEndAngle + ut.arcSupportOffsetEndAngle).forEach(function(e) {
                            var t = z.clone();
                            t.rotation.y = -Math.PI / 2, t.rotation.z = -e, l.push([t, pe / 2 - 5, ut.arcCenter.x + Math.cos(e) * it, ut.arcCenter.y + Math.sin(e) * it])
                        });
                        break;
                    case "equirectangular sphere":
                        var mt = new a.Mesh(new a.SphereGeometry(1, 50, 25), s);
                        mt.name = "noshading", mt.rotation.x += Math.PI / 2, mt.scale.x = -n.width / 2, mt.scale.z = n.width / 2, mt.scale.y = n.height / 2, l.push([mt]);
                        break;
                    case "floormaps":
                        var gt = [],
                            vt = new a.Object3D,
                            We = Object.assign({
                                polygons: [],
                                wallHeight: 230
                            }, n.opts),
                            yt = this.xyRectVerts(10, We.wallHeight / 5);
                        yt.push(yt[0]), n.opts.polygons.forEach(function(e) {
                            var t, n = gt.filter(function(t) {
                                return t.name == e.layer
                            });
                            n.length ? t = n[0] : (t = new a.Object3D, t.name = e.layer, gt.push(t), vt.add(t));
                            var r = c.extrudeShapeOnYPlaneNew(e.name, s, yt, e.vertices.map(function(e) {
                                return new a.Vector3(e[0], e[1], 0)
                            }), !1);
                            t.add(r)
                        }), gt.forEach(function(e, t) {
                            e.position.z -= t * We.wallHeight
                        });
                        var bt = (new a.Box3).setFromObject(vt),
                            xt = bt.getCenter();
                        bt.getSize();
                        vt.position.sub(xt), this.remapUV2(vt), l.push([vt]);
                        break;
                    case "flexroof":
                        var We = n.opts || {},
                            wt = We.spanWidth || 60,
                            _t = n.height,
                            Mt = We.edgeVerts.map(function(e) {
                                return new a.Vector3(e[0], 0, e[1])
                            }),
                            Et = We.topVerts.map(function(e) {
                                return new a.Vector3(e[0], _t, e[1])
                            }),
                            Tt = We.edgeTopIndexes.map(function(e) {
                                return Et[e]
                            }),
                            St = (Mt[Mt.length - 1].distanceToManhattan(Mt[0]), new a.Object3D),
                            At = Mt.slice(1).map(function(e, t) {
                                return [Mt[t], e, Tt[t + 1], Tt[t]].reduce(function(e, t) {
                                    return (!e.length || e[e.length - 1].distanceToManhattan(t) > 1) && e.push(t), e
                                }, [])
                            }).filter(function(e) {
                                return e.length > 2
                            }),
                            Pt = {
                                beamShape: this.default.beamShape,
                                parallelBeamIntervalBuilder: (new p).withMaxWidth(wt).withoutBorders(),
                                splitBeamIntervalBuilder: (new p).withMaxWidth(2 * wt).withoutBorders(),
                                glassMaterial: this.materials.glass,
                                beamMaterial: s || this.materials.whiteMetal
                            };
                        At.forEach(function(e, t) {
                            if (e = e.map(function(e) {
                                    return e.clone()
                                }), 3 === e.length && e[0].distanceTo(e[1]) < .8 * Math.min(e[0].distanceTo(e[2]), e[1].distanceTo(e[2]))) {
                                var n = c.beamsToLastPointOverTriangle("edge " + t, Pt.beamMaterial, e[0], e[1], e[2], Pt.splitBeamIntervalBuilder, Pt.beamShape);
                                St.add(n)
                            } else {
                                var n = c.parallelBeamsOverPoly("edge " + t, Pt.beamMaterial, e, 0, Pt.parallelBeamIntervalBuilder, Pt.beamShape);
                                St.add(n)
                            }
                            var r = c.polygonGeometry(e);
                            St.add(new a.Mesh(r, c.materials.glass))
                        });
                        var Ct = new a.Vector3(0, 1, 0),
                            Lt = Tt.slice(1).map(function(e, t) {
                                return {
                                    v1: Tt[t],
                                    v2: e
                                }
                            }).concat(Mt.map(function(e, t) {
                                return {
                                    v1: e,
                                    v2: Tt[t]
                                }
                            })).concat(Mt.slice(1).map(function(e, t) {
                                return {
                                    v1: Mt[t],
                                    v2: e
                                }
                            })).map(function(e) {
                                var t = e.v2.clone().sub(e.v1).normalize(),
                                    n = t.clone().multiplyScalar(3),
                                    r = e.v1.clone().sub(n),
                                    i = e.v2.clone().add(n),
                                    o = t.clone().cross(Ct).normalize();
                                return o.lengthManhattan() < .1 && (o = new a.Vector3(0, 0, 1).cross(Ct)), {
                                    v1: r,
                                    v2: i,
                                    v1Normal: o,
                                    v2Normal: o
                                }
                            }),
                            Rt = this.extrudeEdges("edges", Pt.beamMaterial, Lt, Pt.beamShape);
                        St.add(Rt), St.rotation.x = -Math.PI / 2, l.push([St])
                }
                var It = this.compose(e, l);
                if (n && (n.rotation || n.position || n.scale)) {
                    var Ot = new a.Object3D;
                    Ot.name = It.name, Ot.add(It), It.name += " wrapped", n.rotation && It.rotation.fromArray(n.rotation), n.position && It.position.fromArray(n.position), n.scale && It.scale.fromArray(n.scale), It = Ot
                }
                return n && n.swapUV && this.swapUV(It), n && n.children && n.children.forEach(function(e, t) {
                    var o = Object.assign({}, n);
                    o.children = [], o = Object.assign(o, e);
                    var a = c.buildElementInternal(n.id + o.id, o.elementType, o, r, i, s);
                    It.add(a)
                }), It
            }, t.prototype.checkLineIntersection = function(e, t, n, r, i, o, a, s) {
                var c, l, h, u, d, p = {
                    x: null,
                    y: null,
                    onLine1: !1,
                    onLine2: !1
                };
                return 0 == (c = (s - o) * (n - e) - (a - i) * (r - t)) ? p : (l = t - o, h = e - i, u = (a - i) * l - (s - o) * h, d = (n - e) * l - (r - t) * h, l = u / c, h = d / c, p.x = e + l * (n - e), p.y = t + l * (r - t), l > 0 && l < 1 && (p.onLine1 = !0), h > 0 && h < 1 && (p.onLine2 = !0), p)
            }, t.prototype.loadText = function(e, t, n, r, i, o, s) {
                if (!this.MSDFFont) {
                    var l = new a.Object3D;
                    return l.name = e, l
                }
                var u = h({
                        font: this.MSDFFont,
                        text: t
                    }),
                    d = new a.RawShaderMaterial(c({
                        map: this.MSDFTexture,
                        side: a.DoubleSide,
                        transparent: !0,
                        color: i
                    })),
                    p = u.layout,
                    f = new a.Mesh(u, d),
                    m = r / 50;
                f.position.set((-p.descender + p.height / 2) * m, p.width / 2 * m, 0), f.rotation.z = -Math.PI / 2, f.scale.setScalar(m);
                var g = new a.Object3D;
                return g.add(f), g.name = e, g
            }, t.prototype.extrudeShapeOnYPlaneNew = function(e, t, n, r, i) {
                var o = this,
                    s = r.slice(0);
                s.unshift(s.pop());
                var c = r.map(function(e, t) {
                        var n = s[t],
                            r = n.clone().sub(e).normalize(),
                            i = r.x;
                        return r.x = -r.y, r.y = i, {
                            vl: e.clone(),
                            vr: n.clone(),
                            i: t,
                            n: r
                        }
                    }),
                    l = n.map(function(e, t) {
                        var n = c.map(function(t, n) {
                                var r = t.n.clone().multiplyScalar(e.x);
                                return r.z -= e.y, {
                                    vl: t.vl.clone().add(r),
                                    vr: t.vr.clone().add(r)
                                }
                            }),
                            r = n.slice(0);
                        return r.unshift(r.pop()), n.reduce(function(e, t, n) {
                            var i = r[n],
                                s = o.checkLineIntersection(t.vl.x, t.vl.y, t.vr.x, t.vr.y, i.vl.x, i.vl.y, i.vr.x, i.vr.y);
                            return null !== s.x && null !== s.y && e.push(new a.Vector3(s.x, s.y, t.vl.z)), e
                        }, [])
                    }),
                    h = new Float32Array(r.length * n.length * 2 * 3 * 3),
                    u = new Float32Array(r.length * n.length * 2 * 3 * 3),
                    d = new Float32Array(r.length * n.length * 2 * 2 * 3),
                    p = 0,
                    f = 0,
                    m = 0,
                    g = new a.Vector3,
                    v = new a.Vector3,
                    y = n.map(function(e, t, n) {
                        return 0 == t ? 0 : n[t - 1].distanceTo(e)
                    }),
                    b = r.map(function(e, t, n) {
                        return 0 == t ? 0 : n[t - 1].distanceTo(e)
                    });
                l.forEach(function(e, t, n) {
                    0 !== t && e.forEach(function(e, r, i) {
                        var o = r - 1;
                        o < 0 && (o += i.length);
                        var a = n[t - 1][o],
                            s = y[t - 1],
                            c = b[o],
                            l = n[t - 1][r],
                            x = y[t - 1],
                            w = b[r],
                            _ = n[t][r],
                            M = y[t],
                            E = b[r],
                            T = n[t][o],
                            S = y[t],
                            A = b[o];
                        h[p++] = a.x, h[p++] = a.y, h[p++] = a.z, d[m++] = s, d[m++] = c, h[p++] = _.x, h[p++] = _.y, h[p++] = _.z, d[m++] = M, d[m++] = E, h[p++] = l.x, h[p++] = l.y, h[p++] = l.z, d[m++] = x, d[m++] = w, h[p++] = _.x, h[p++] = _.y, h[p++] = _.z, d[m++] = M, d[m++] = E, h[p++] = a.x, h[p++] = a.y, h[p++] = a.z, d[m++] = s, d[m++] = c, h[p++] = T.x, h[p++] = T.y, h[p++] = T.z, d[m++] = S, d[m++] = A, g.subVectors(a, l), v.subVectors(_, l), g.cross(v), g.normalize();
                        for (var P = g.x, C = g.y, L = g.z, R = 0; R < 6; R++) u[f++] = P, u[f++] = C, u[f++] = L
                    })
                });
                var x = new a.BufferGeometry;
                h = h.slice(0, p), u = u.slice(0, p), x.addAttribute("position", new a.BufferAttribute(h, 3)), x.addAttribute("normal", new a.BufferAttribute(u, 3)), x.addAttribute("uv", new a.BufferAttribute(d, 2)), x.computeBoundingSphere();
                var w = new a.Mesh(x, t);
                return w.name = e, w
            }, t
        }(f);
        e.ElementBuilder = t
    }(r || (r = {}))
}, function(e, t, n) {
    var r = n(0),
        i = n(12);
    e.exports = function(e) {
        e = e || {};
        var t = "number" == typeof e.opacity ? e.opacity : 1,
            n = "number" == typeof e.alphaTest ? e.alphaTest : 1e-4,
            o = e.precision || "highp",
            a = e.color,
            s = e.map;
        return delete e.map, delete e.color, delete e.precision, delete e.opacity, i({
            uniforms: {
                opacity: {
                    type: "f",
                    value: t
                },
                map: {
                    type: "t",
                    value: s || new r.Texture
                },
                color: {
                    type: "c",
                    value: new r.Color(a)
                }
            },
            vertexShader: ["attribute vec2 uv;", "attribute vec4 position;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * position;", "}"].join("\n"),
            fragmentShader: ["#ifdef GL_OES_standard_derivatives", "#extension GL_OES_standard_derivatives : enable", "#endif", "precision " + o + " float;", "uniform float opacity;", "uniform vec3 color;", "uniform sampler2D map;", "varying vec2 vUv;", "float median(float r, float g, float b) {", "  return max(min(r, g), min(max(r, g), b));", "}", "void main() {", "  vec3 sample = 1.0 - texture2D(map, vUv).rgb;", "  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;", "  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);", "  gl_FragColor = vec4(color.xyz, alpha * opacity);", 0 === n ? "" : "  if (gl_FragColor.a < " + n + ") discard;", "}"].join("\n")
        }, e)
    }
}, function(e, t, n) {
    (function(t) {
        function r(e) {
            return "[object ArrayBuffer]" === Object.prototype.toString.call(e)
        }

        function i(e) {
            if (d) return u(e, {
                responseType: "arraybuffer"
            });
            if (void 0 === self.XMLHttpRequest) throw new Error("your browser does not support XHR loading");
            var t = new self.XMLHttpRequest;
            return t.overrideMimeType("text/plain; charset=x-user-defined"), u({
                xhr: t
            }, e)
        }
        var o = n(33),
            a = function() {},
            s = n(38),
            c = n(39),
            l = n(42),
            h = n(43),
            u = n(8),
            d = function() {
                return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest
            }();
        e.exports = function(e, n) {
            n = "function" == typeof n ? n : a, "string" == typeof e ? e = {
                uri: e
            } : e || (e = {}), e.binary && (e = i(e)), o(e, function(i, o, u) {
                if (i) return n(i);
                if (!/^2/.test(o.statusCode)) return n(new Error("http status code: " + o.statusCode));
                if (!u) return n(new Error("no body result"));
                var d = !1;
                if (r(u)) {
                    var p = new Uint8Array(u);
                    u = new t(p, "binary")
                }
                h(u) && (d = !0, "string" == typeof u && (u = new t(u, "binary"))), d || (t.isBuffer(u) && (u = u.toString(e.encoding)), u = u.trim());
                var f;
                try {
                    var m = o.headers["content-type"];
                    f = d ? l(u) : /json/.test(m) || "{" === u.charAt(0) ? JSON.parse(u) : /xml/.test(m) || "<" === u.charAt(0) ? c(u) : s(u)
                } catch (e) {
                    n(new Error("error parsing font " + e.message)), n = a
                }
                n(null, f)
            })
        }
    }).call(t, n(6).Buffer)
}, function(e, t, n) {
    "use strict";

    function r(e) {
        var t = e.length;
        if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        return "=" === e[t - 2] ? 2 : "=" === e[t - 1] ? 1 : 0
    }

    function i(e) {
        return 3 * e.length / 4 - r(e)
    }

    function o(e) {
        var t, n, i, o, a, s = e.length;
        o = r(e), a = new u(3 * s / 4 - o), n = o > 0 ? s - 4 : s;
        var c = 0;
        for (t = 0; t < n; t += 4) i = h[e.charCodeAt(t)] << 18 | h[e.charCodeAt(t + 1)] << 12 | h[e.charCodeAt(t + 2)] << 6 | h[e.charCodeAt(t + 3)], a[c++] = i >> 16 & 255, a[c++] = i >> 8 & 255, a[c++] = 255 & i;
        return 2 === o ? (i = h[e.charCodeAt(t)] << 2 | h[e.charCodeAt(t + 1)] >> 4, a[c++] = 255 & i) : 1 === o && (i = h[e.charCodeAt(t)] << 10 | h[e.charCodeAt(t + 1)] << 4 | h[e.charCodeAt(t + 2)] >> 2, a[c++] = i >> 8 & 255, a[c++] = 255 & i), a
    }

    function a(e) {
        return l[e >> 18 & 63] + l[e >> 12 & 63] + l[e >> 6 & 63] + l[63 & e]
    }

    function s(e, t, n) {
        for (var r, i = [], o = t; o < n; o += 3) r = (e[o] << 16) + (e[o + 1] << 8) + e[o + 2], i.push(a(r));
        return i.join("")
    }

    function c(e) {
        for (var t, n = e.length, r = n % 3, i = "", o = [], a = 0, c = n - r; a < c; a += 16383) o.push(s(e, a, a + 16383 > c ? c : a + 16383));
        return 1 === r ? (t = e[n - 1], i += l[t >> 2], i += l[t << 4 & 63], i += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i += l[t >> 10], i += l[t >> 4 & 63], i += l[t << 2 & 63], i += "="), o.push(i), o.join("")
    }
    t.byteLength = i, t.toByteArray = o, t.fromByteArray = c;
    for (var l = [], h = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%2b/index.html", p = 0, f = d.length; p < f; ++p) l[p] = d[p], h[d.charCodeAt(p)] = p;
    h["-".charCodeAt(0)] = 62, h["_".charCodeAt(0)] = 63
}, function(e, t) {
    t.read = function(e, t, n, r, i) {
        var o, a, s = 8 * i - r - 1,
            c = (1 << s) - 1,
            l = c >> 1,
            h = -7,
            u = n ? i - 1 : 0,
            d = n ? -1 : 1,
            p = e[t + u];
        for (u += d, o = p & (1 << -h) - 1, p >>= -h, h += s; h > 0; o = 256 * o + e[t + u], u += d, h -= 8);
        for (a = o & (1 << -h) - 1, o >>= -h, h += r; h > 0; a = 256 * a + e[t + u], u += d, h -= 8);
        if (0 === o) o = 1 - l;
        else {
            if (o === c) return a ? NaN : 1 / 0 * (p ? -1 : 1);
            a += Math.pow(2, r), o -= l
        }
        return (p ? -1 : 1) * a * Math.pow(2, o - r)
    }, t.write = function(e, t, n, r, i, o) {
        var a, s, c, l = 8 * o - i - 1,
            h = (1 << l) - 1,
            u = h >> 1,
            d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            p = r ? 0 : o - 1,
            f = r ? 1 : -1,
            m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a = h) : (a = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), t += a + u >= 1 ? d / c : d * Math.pow(2, 1 - u), t * c >= 2 && (a++, c /= 2), a + u >= h ? (s = 0, a = h) : a + u >= 1 ? (s = (t * c - 1) * Math.pow(2, i), a += u) : (s = t * Math.pow(2, u - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + p] = 255 & s, p += f, s /= 256, i -= 8);
        for (a = a << i | s, l += i; l > 0; e[n + p] = 255 & a, p += f, a /= 256, l -= 8);
        e[n + p - f] |= 128 * m
    }
}, function(e, t) {
    var n = {}.toString;
    e.exports = Array.isArray || function(e) {
        return "[object Array]" == n.call(e)
    }
}, function(e, t, n) {
    "use strict";

    function r(e) {
        for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
        return !0
    }

    function i(e, t, n) {
        var r = e;
        return h(t) ? (n = t, "string" == typeof e && (r = {
            uri: e
        })) : r = d(t, {
            uri: e
        }), r.callback = n, r
    }

    function o(e, t, n) {
        return t = i(e, t, n), a(t)
    }

    function a(e) {
        function t() {
            4 === h.readyState && setTimeout(a, 0)
        }

        function n() {
            var e = void 0;
            if (e = h.response ? h.response : h.responseText || s(h), x) try {
                e = JSON.parse(e)
            } catch (e) {}
            return e
        }

        function i(e) {
            return clearTimeout(f), e instanceof Error || (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))), e.statusCode = 0, l(e, w)
        }

        function a() {
            if (!p) {
                var t;
                clearTimeout(f), t = e.useXDR && void 0 === h.status ? 200 : 1223 === h.status ? 204 : h.status;
                var r = w,
                    i = null;
                return 0 !== t ? (r = {
                    body: n(),
                    statusCode: t,
                    method: g,
                    headers: {},
                    url: m,
                    rawRequest: h
                }, h.getAllResponseHeaders && (r.headers = u(h.getAllResponseHeaders()))) : i = new Error("Internal XMLHttpRequest Error"), l(i, r, r.body)
            }
        }
        if (void 0 === e.callback) throw new Error("callback argument missing");
        var c = !1,
            l = function(t, n, r) {
                c || (c = !0, e.callback(t, n, r))
            },
            h = e.xhr || null;
        h || (h = e.cors || e.useXDR ? new o.XDomainRequest : new o.XMLHttpRequest);
        var d, p, f, m = h.url = e.uri || e.url,
            g = h.method = e.method || "GET",
            v = e.body || e.data,
            y = h.headers = e.headers || {},
            b = !!e.sync,
            x = !1,
            w = {
                body: void 0,
                headers: {},
                statusCode: 0,
                method: g,
                url: m,
                rawRequest: h
            };
        if ("json" in e && !1 !== e.json && (x = !0, y.accept || y.Accept || (y.Accept = "application/json"), "GET" !== g && "HEAD" !== g && (y["content-type"] || y["Content-Type"] || (y["Content-Type"] = "application/json"), v = JSON.stringify(!0 === e.json ? v : e.json))), h.onreadystatechange = t, h.onload = a, h.onerror = i, h.onprogress = function() {}, h.onabort = function() {
                p = !0
            }, h.ontimeout = i, h.open(g, m, !b, e.username, e.password), b || (h.withCredentials = !!e.withCredentials), !b && e.timeout > 0 && (f = setTimeout(function() {
                if (!p) {
                    p = !0, h.abort("timeout");
                    var e = new Error("XMLHttpRequest timeout");
                    e.code = "ETIMEDOUT", i(e)
                }
            }, e.timeout)), h.setRequestHeader)
            for (d in y) y.hasOwnProperty(d) && h.setRequestHeader(d, y[d]);
        else if (e.headers && !r(e.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
        return "responseType" in e && (h.responseType = e.responseType), "beforeSend" in e && "function" == typeof e.beforeSend && e.beforeSend(h), h.send(v || null), h
    }

    function s(e) {
        if ("document" === e.responseType) return e.responseXML;
        var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName;
        return "" !== e.responseType || t ? null : e.responseXML
    }

    function c() {}
    var l = n(34),
        h = n(13),
        u = n(35),
        d = n(8);
    e.exports = o, o.XMLHttpRequest = l.XMLHttpRequest || c, o.XDomainRequest = "withCredentials" in new o.XMLHttpRequest ? o.XMLHttpRequest : l.XDomainRequest,
        function(e, t) {
            for (var n = 0; n < e.length; n++) t(e[n])
        }(["get", "put", "post", "patch", "head", "delete"], function(e) {
            o["delete" === e ? "del" : e] = function(t, n, r) {
                return n = i(t, n, r), n.method = e.toUpperCase(), a(n)
            }
        })
}, function(e, t, n) {
    (function(t) {
        var n;
        n = "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}, e.exports = n
    }).call(t, n(7))
}, function(e, t, n) {
    var r = n(36),
        i = n(37),
        o = function(e) {
            return "[object Array]" === Object.prototype.toString.call(e)
        };
    e.exports = function(e) {
        if (!e) return {};
        var t = {};
        return i(r(e).split("\n"), function(e) {
            var n = e.indexOf(":"),
                i = r(e.slice(0, n)).toLowerCase(),
                a = r(e.slice(n + 1));
            void 0 === t[i] ? t[i] = a : o(t[i]) ? t[i].push(a) : t[i] = [t[i], a]
        }), t
    }
}, function(e, t) {
    function n(e) {
        return e.replace(/^\s*|\s*$/g, "")
    }
    t = e.exports = n, t.left = function(e) {
        return e.replace(/^\s*/, "")
    }, t.right = function(e) {
        return e.replace(/\s*$/, "")
    }
}, function(e, t, n) {
    function r(e, t, n) {
        if (!s(t)) throw new TypeError("iterator must be a function");
        arguments.length < 3 && (n = this), "[object Array]" === c.call(e) ? i(e, t, n) : "string" == typeof e ? o(e, t, n) : a(e, t, n)
    }

    function i(e, t, n) {
        for (var r = 0, i = e.length; r < i; r++) l.call(e, r) && t.call(n, e[r], r, e)
    }

    function o(e, t, n) {
        for (var r = 0, i = e.length; r < i; r++) t.call(n, e.charAt(r), r, e)
    }

    function a(e, t, n) {
        for (var r in e) l.call(e, r) && t.call(n, e[r], r, e)
    }
    var s = n(13);
    e.exports = r;
    var c = Object.prototype.toString,
        l = Object.prototype.hasOwnProperty
}, function(e, t) {
    function n(e, t) {
        if (!(e = e.replace(/\t+/g, " ").trim())) return null;
        var n = e.indexOf(" ");
        if (-1 === n) throw new Error("no named row at line " + t);
        var i = e.substring(0, n);
        e = e.substring(n + 1), e = e.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), e = e.split("="), e = e.map(function(e) {
            return e.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)
        });
        for (var o = [], a = 0; a < e.length; a++) {
            var s = e[a];
            0 === a ? o.push({
                key: s[0],
                data: ""
            }) : a === e.length - 1 ? o[o.length - 1].data = r(s[0]) : (o[o.length - 1].data = r(s[0]), o.push({
                key: s[1],
                data: ""
            }))
        }
        var c = {
            key: i,
            data: {}
        };
        return o.forEach(function(e) {
            c.data[e.key] = e.data
        }), c
    }

    function r(e) {
        return e && 0 !== e.length ? 0 === e.indexOf('"') || 0 === e.indexOf("'") ? e.substring(1, e.length - 1) : -1 !== e.indexOf(",") ? i(e) : parseInt(e, 10) : ""
    }

    function i(e) {
        return e.split(",").map(function(e) {
            return parseInt(e, 10)
        })
    }
    e.exports = function(e) {
        if (!e) throw new Error("no data provided");
        e = e.toString().trim();
        var t = {
                pages: [],
                chars: [],
                kernings: []
            },
            r = e.split(/\r\n?|\n/g);
        if (0 === r.length) throw new Error("no data in BMFont file");
        for (var i = 0; i < r.length; i++) {
            var o = n(r[i], i);
            if (o)
                if ("page" === o.key) {
                    if ("number" != typeof o.data.id) throw new Error("malformed file at line " + i + " -- needs page id=N");
                    if ("string" != typeof o.data.file) throw new Error("malformed file at line " + i + ' -- needs page file="path"');
                    t.pages[o.data.id] = o.data.file
                } else "chars" === o.key || "kernings" === o.key || ("char" === o.key ? t.chars.push(o.data) : "kerning" === o.key ? t.kernings.push(o.data) : t[o.key] = o.data)
        }
        return t
    }
}, function(e, t, n) {
    function r(e) {
        return i(e).reduce(function(e, t) {
            return e[o(t.nodeName)] = t.nodeValue, e
        }, {})
    }

    function i(e) {
        for (var t = [], n = 0; n < e.attributes.length; n++) t.push(e.attributes[n]);
        return t
    }

    function o(e) {
        return c[e.toLowerCase()] || e
    }
    var a = n(40),
        s = n(41),
        c = {
            scaleh: "scaleH",
            scalew: "scaleW",
            stretchh: "stretchH",
            lineheight: "lineHeight",
            alphachnl: "alphaChnl",
            redchnl: "redChnl",
            greenchnl: "greenChnl",
            bluechnl: "blueChnl"
        };
    e.exports = function(e) {
        e = e.toString();
        var t = s(e),
            n = {
                pages: [],
                chars: [],
                kernings: []
            };
        ["info", "common"].forEach(function(e) {
            var i = t.getElementsByTagName(e)[0];
            i && (n[e] = a(r(i)))
        });
        var i = t.getElementsByTagName("pages")[0];
        if (!i) throw new Error("malformed file -- no <pages> element");
        for (var o = i.getElementsByTagName("page"), c = 0; c < o.length; c++) {
            var l = o[c],
                h = parseInt(l.getAttribute("id"), 10),
                u = l.getAttribute("file");
            if (isNaN(h)) throw new Error('malformed file -- page "id" attribute is NaN');
            if (!u) throw new Error('malformed file -- needs page "file" attribute');
            n.pages[parseInt(h, 10)] = u
        }
        return ["chars", "kernings"].forEach(function(e) {
            var i = t.getElementsByTagName(e)[0];
            if (i)
                for (var o = e.substring(0, e.length - 1), s = i.getElementsByTagName(o), c = 0; c < s.length; c++) {
                    var l = s[c];
                    n[e].push(a(r(l)))
                }
        }), n
    }
}, function(e, t) {
    function n(e) {
        return e.split(",").map(function(e) {
            return parseInt(e, 10)
        })
    }
    e.exports = function(e) {
        "chasrset" in e && (e.charset = e.chasrset, delete e.chasrset);
        for (var t in e) "face" !== t && "charset" !== t && (e[t] = "padding" === t || "spacing" === t ? n(e[t]) : parseInt(e[t], 10));
        return e
    }
}, function(e, t) {
    e.exports = function() {
        return void 0 !== self.DOMParser ? function(e) {
            return (new self.DOMParser).parseFromString(e, "application/xml")
        } : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function(e) {
            var t = new self.ActiveXObject("Microsoft.XMLDOM");
            return t.async = "false", t.loadXML(e), t
        } : function(e) {
            var t = document.createElement("div");
            return t.innerHTML = e, t
        }
    }()
}, function(e, t) {
    function n(e, t, n) {
        if (n > t.length - 1) return 0;
        var c = t.readUInt8(n++),
            l = t.readInt32LE(n);
        switch (n += 4, c) {
            case 1:
                e.info = r(t, n);
                break;
            case 2:
                e.common = i(t, n);
                break;
            case 3:
                e.pages = o(t, n, l);
                break;
            case 4:
                e.chars = a(t, n, l);
                break;
            case 5:
                e.kernings = s(t, n, l)
        }
        return 5 + l
    }

    function r(e, t) {
        var n = {};
        n.size = e.readInt16LE(t);
        var r = e.readUInt8(t + 2);
        return n.smooth = r >> 7 & 1, n.unicode = r >> 6 & 1, n.italic = r >> 5 & 1, n.bold = r >> 4 & 1, r >> 3 & 1 && (n.fixedHeight = 1), n.charset = e.readUInt8(t + 3) || "", n.stretchH = e.readUInt16LE(t + 4), n.aa = e.readUInt8(t + 6), n.padding = [e.readInt8(t + 7), e.readInt8(t + 8), e.readInt8(t + 9), e.readInt8(t + 10)], n.spacing = [e.readInt8(t + 11), e.readInt8(t + 12)], n.outline = e.readUInt8(t + 13), n.face = l(e, t + 14), n
    }

    function i(e, t) {
        var n = {};
        n.lineHeight = e.readUInt16LE(t), n.base = e.readUInt16LE(t + 2), n.scaleW = e.readUInt16LE(t + 4), n.scaleH = e.readUInt16LE(t + 6), n.pages = e.readUInt16LE(t + 8);
        e.readUInt8(t + 10);
        return n.packed = 0, n.alphaChnl = e.readUInt8(t + 11), n.redChnl = e.readUInt8(t + 12), n.greenChnl = e.readUInt8(t + 13), n.blueChnl = e.readUInt8(t + 14), n
    }

    function o(e, t, n) {
        for (var r = [], i = c(e, t), o = i.length + 1, a = n / o, s = 0; s < a; s++) r[s] = e.slice(t, t + i.length).toString("utf8"), t += o;
        return r
    }

    function a(e, t, n) {
        for (var r = [], i = n / 20, o = 0; o < i; o++) {
            var a = {},
                s = 20 * o;
            a.id = e.readUInt32LE(t + 0 + s), a.x = e.readUInt16LE(t + 4 + s), a.y = e.readUInt16LE(t + 6 + s), a.width = e.readUInt16LE(t + 8 + s), a.height = e.readUInt16LE(t + 10 + s), a.xoffset = e.readInt16LE(t + 12 + s), a.yoffset = e.readInt16LE(t + 14 + s), a.xadvance = e.readInt16LE(t + 16 + s), a.page = e.readUInt8(t + 18 + s), a.chnl = e.readUInt8(t + 19 + s), r[o] = a
        }
        return r
    }

    function s(e, t, n) {
        for (var r = [], i = n / 10, o = 0; o < i; o++) {
            var a = {},
                s = 10 * o;
            a.first = e.readUInt32LE(t + 0 + s), a.second = e.readUInt32LE(t + 4 + s), a.amount = e.readInt16LE(t + 8 + s), r[o] = a
        }
        return r
    }

    function c(e, t) {
        for (var n = t; n < e.length && 0 !== e[n]; n++);
        return e.slice(t, n)
    }

    function l(e, t) {
        return c(e, t).toString("utf8")
    }
    var h = [66, 77, 70];
    e.exports = function(e) {
        if (e.length < 6) throw new Error("invalid buffer length for BMFont");
        if (!h.every(function(t, n) {
                return e.readUInt8(n) === t
            })) throw new Error("BMFont missing BMF byte header");
        var t = 3;
        if (e.readUInt8(t++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
        for (var r = {
                kernings: [],
                chars: []
            }, i = 0; i < 5; i++) t += n(r, e, t);
        return r
    }
}, function(e, t, n) {
    (function(t) {
        var r = n(44),
            i = new t([66, 77, 70, 3]);
        e.exports = function(e) {
            return "string" == typeof e ? "BMF" === e.substring(0, 3) : e.length > 4 && r(e.slice(0, 4), i)
        }
    }).call(t, n(6).Buffer)
}, function(e, t, n) {
    var r = n(6).Buffer;
    e.exports = function(e, t) {
        if (r.isBuffer(e) && r.isBuffer(t)) {
            if ("function" == typeof e.equals) return e.equals(t);
            if (e.length !== t.length) return !1;
            for (var n = 0; n < e.length; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }
    }
}, function(e, t, n) {
    function r(e) {
        d.call(this), "string" == typeof e && (e = {
            text: e
        }), this._opt = l({}, e), e && this.update(e)
    }
    var i = n(0),
        o = n(46),
        a = n(49),
        s = n(50),
        c = n(53),
        l = n(12),
        h = n(55),
        u = n(56),
        d = i.BufferGeometry;
    e.exports = function(e) {
        return new r(e)
    }, a(r, d), r.prototype.update = function(e) {
        if ("string" == typeof e && (e = {
                text: e
            }), e = l({}, this._opt, e), !e.font) throw new TypeError("must specify a { font } in options");
        this.layout = o(e);
        var t = !1 !== e.flipY,
            n = e.font,
            r = n.common.scaleW,
            i = n.common.scaleH,
            a = this.layout.glyphs.filter(function(e) {
                var t = e.data;
                return t.width * t.height > 0
            });
        this.visibleGlyphs = a;
        var u = h.positions(a),
            d = h.uvs(a, r, i, t),
            p = s({
                clockwise: !0,
                type: "uint16",
                count: a.length
            });
        if (c.index(this, p, 1, "uint16"), c.attr(this, "position", u, 2), c.attr(this, "uv", d, 2), !e.multipage && "page" in this.attributes) this.removeAttribute("page");
        else if (e.multipage) {
            var f = h.pages(a);
            c.attr(this, "page", f, 1)
        }
    }, r.prototype.computeBoundingSphere = function() {
        null === this.boundingSphere && (this.boundingSphere = new i.Sphere);
        var e = this.attributes.position.array,
            t = this.attributes.position.itemSize;
        if (!e || !t || e.length < 2) return this.boundingSphere.radius = 0, void this.boundingSphere.center.set(0, 0, 0);
        u.computeSphere(e, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
    }, r.prototype.computeBoundingBox = function() {
        null === this.boundingBox && (this.boundingBox = new i.Box3);
        var e = this.boundingBox,
            t = this.attributes.position.array,
            n = this.attributes.position.itemSize;
        if (!t || !n || t.length < 2) return void e.makeEmpty();
        u.computeBox(t, e)
    }
}, function(e, t, n) {
    function r(e) {
        this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(e)
    }

    function i(e) {
        Object.defineProperty(r.prototype, e, {
            get: o(e),
            configurable: !0
        })
    }

    function o(e) {
        return new Function(["return function " + e + "() {", "  return this._" + e, "}"].join("\n"))()
    }

    function a(e, t) {
        if (!e.chars || 0 === e.chars.length) return null;
        var n = d(e.chars, t);
        return n >= 0 ? e.chars[n] : null
    }

    function s(e) {
        for (var t = 0; t < g.length; t++) {
            var n = g[t].charCodeAt(0),
                r = d(e.chars, n);
            if (r >= 0) return e.chars[r].height
        }
        return 0
    }

    function c(e) {
        for (var t = 0; t < v.length; t++) {
            var n = v[t].charCodeAt(0),
                r = d(e.chars, n);
            if (r >= 0) return e.chars[r]
        }
        return 0
    }

    function l(e) {
        for (var t = 0; t < y.length; t++) {
            var n = y[t].charCodeAt(0),
                r = d(e.chars, n);
            if (r >= 0) return e.chars[r].height
        }
        return 0
    }

    function h(e, t, n) {
        if (!e.kernings || 0 === e.kernings.length) return 0;
        for (var r = e.kernings, i = 0; i < r.length; i++) {
            var o = r[i];
            if (o.first === t && o.second === n) return o.amount
        }
        return 0
    }

    function u(e) {
        return "center" === e ? _ : "right" === e ? M : w
    }

    function d(e, t, n) {
        n = n || 0;
        for (var r = n; r < e.length; r++)
            if (e[r].id === t) return r;
        return -1
    }
    var p = n(47),
        f = n(8),
        m = n(48),
        g = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"],
        v = ["m", "w"],
        y = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"],
        b = "\t".charCodeAt(0),
        x = " ".charCodeAt(0),
        w = 0,
        _ = 1,
        M = 2;
    e.exports = function(e) {
        return new r(e)
    }, r.prototype.update = function(e) {
        if (e = f({
                measure: this._measure
            }, e), this._opt = e, this._opt.tabSize = m(this._opt.tabSize, 4), !e.font) throw new Error("must provide a valid bitmap font");
        var t = this.glyphs,
            n = e.text || "",
            r = e.font;
        this._setupSpaceGlyphs(r);
        var i = p.lines(n, e),
            o = e.width || 0;
        t.length = 0;
        var a = i.reduce(function(e, t) {
                return Math.max(e, t.width, o)
            }, 0),
            c = 0,
            d = 0,
            g = m(e.lineHeight, r.common.lineHeight),
            v = r.common.base,
            y = g - v,
            b = e.letterSpacing || 0,
            x = g * i.length - y,
            w = u(this._opt.align);
        d -= x, this._width = a, this._height = x, this._descender = g - v, this._baseline = v, this._xHeight = s(r), this._capHeight = l(r), this._lineHeight = g, this._ascender = g - y - this._xHeight;
        var E = this;
        i.forEach(function(e, i) {
            for (var o, s = e.start, l = e.end, u = e.width, p = s; p < l; p++) {
                var f = n.charCodeAt(p),
                    m = E.getGlyph(r, f);
                if (m) {
                    o && (c += h(r, o.id, m.id));
                    var v = c;
                    w === _ ? v += (a - u) / 2 : w === M && (v += a - u), t.push({
                        position: [v, d],
                        data: m,
                        index: p,
                        line: i
                    }), c += m.xadvance + b, o = m
                }
            }
            d += g, c = 0
        }), this._linesTotal = i.length
    }, r.prototype._setupSpaceGlyphs = function(e) {
        if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, e.chars && 0 !== e.chars.length) {
            var t = a(e, x) || c(e) || e.chars[0],
                n = this._opt.tabSize * t.xadvance;
            this._fallbackSpaceGlyph = t, this._fallbackTabGlyph = f(t, {
                x: 0,
                y: 0,
                xadvance: n,
                id: b,
                xoffset: 0,
                yoffset: 0,
                width: 0,
                height: 0
            })
        }
    }, r.prototype.getGlyph = function(e, t) {
        var n = a(e, t);
        return n || (t === b ? this._fallbackTabGlyph : t === x ? this._fallbackSpaceGlyph : null)
    }, r.prototype.computeMetrics = function(e, t, n, r) {
        var i, o, a = this._opt.letterSpacing || 0,
            s = this._opt.font,
            c = 0,
            l = 0,
            u = 0;
        if (!s.chars || 0 === s.chars.length) return {
            start: t,
            end: t,
            width: 0
        };
        n = Math.min(e.length, n);
        for (var d = t; d < n; d++) {
            var p = e.charCodeAt(d),
                i = this.getGlyph(s, p);
            if (i) {
                i.xoffset;
                c += o ? h(s, o.id, i.id) : 0;
                var f = c + i.xadvance + a,
                    m = c + i.width;
                if (m >= r || f >= r) break;
                c = f, l = m, o = i
            }
            u++
        }
        return o && (l += o.xoffset), {
            start: t,
            end: t + u,
            width: l
        }
    }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach(i)
}, function(e, t) {
    function n(e, t, n, r) {
        var i = e.indexOf(t, n);
        return -1 === i || i > r ? r : i
    }

    function r(e) {
        return l.test(e)
    }

    function i(e, t, n, r, i) {
        for (var o = [], a = n, c = n; c < r && c < t.length; c++) {
            var l = t.charAt(c),
                h = s.test(l);
            if (h || c === r - 1) {
                var u = h ? c : c + 1,
                    d = e(t, a, u, i);
                o.push(d), a = c + 1
            }
        }
        return o
    }

    function o(e, t, i, o, a, s) {
        var l = [],
            h = a;
        for ("nowrap" === s && (h = Number.MAX_VALUE); i < o && i < t.length;) {
            for (var u = n(t, c, i, o); i < u && r(t.charAt(i));) i++;
            var d = e(t, i, u, h),
                p = i + (d.end - d.start),
                f = p + c.length;
            if (p < u) {
                for (; p > i && !r(t.charAt(p));) p--;
                if (p === i) f > i + c.length && f--, p = f;
                else
                    for (f = p; p > i && r(t.charAt(p - c.length));) p--
            }
            if (p >= i) {
                var m = e(t, i, p, h);
                l.push(m)
            }
            i = f
        }
        return l
    }

    function a(e, t, n, r) {
        return {
            start: t,
            end: t + Math.min(r, n - t)
        }
    }
    var s = /\n/,
        c = "\n",
        l = /\s/;
    e.exports = function(t, n) {
        return e.exports.lines(t, n).map(function(e) {
            return t.substring(e.start, e.end)
        }).join("\n")
    }, e.exports.lines = function(e, t) {
        if (t = t || {}, 0 === t.width && "nowrap" !== t.mode) return [];
        e = e || "";
        var n = "number" == typeof t.width ? t.width : Number.MAX_VALUE,
            r = Math.max(0, t.start || 0),
            s = "number" == typeof t.end ? t.end : e.length,
            c = t.mode,
            l = t.measure || a;
        return "pre" === c ? i(l, e, r, s, n) : o(l, e, r, s, n, c)
    }
}, function(e, t) {
    e.exports = function(e, t) {
        return "number" == typeof e ? e : "number" == typeof t ? t : 0
    }
}, function(e, t) {
    "function" == typeof Object.create ? e.exports = function(e, t) {
        e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        })
    } : e.exports = function(e, t) {
        e.super_ = t;
        var n = function() {};
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
    }
}, function(e, t, n) {
    var r = n(14),
        i = n(51),
        o = n(52),
        a = [0, 2, 3],
        s = [2, 1, 3];
    e.exports = function(e, t) {
        e && (i(e) || o(e)) || (t = e || {}, e = null), t = "number" == typeof t ? {
            count: t
        } : t || {};
        for (var n = "string" == typeof t.type ? t.type : "uint16", c = "number" == typeof t.count ? t.count : 1, l = t.start || 0, h = !1 !== t.clockwise ? a : s, u = h[0], d = h[1], p = h[2], f = 6 * c, m = e || new(r(n))(f), g = 0, v = 0; g < f; g += 6, v += 4) {
            var y = g + l;
            m[y + 0] = v + 0, m[y + 1] = v + 1, m[y + 2] = v + 2, m[y + 3] = v + u, m[y + 4] = v + d, m[y + 5] = v + p
        }
        return m
    }
}, function(e, t) {
    function n(e) {
        return e.BYTES_PER_ELEMENT && "[object ArrayBuffer]" === r.call(e.buffer) || Array.isArray(e)
    }
    var r = Object.prototype.toString;
    e.exports = n
}, function(e, t) {
    function n(e) {
        return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
    }

    function r(e) {
        return "function" == typeof e.readFloatLE && "function" == typeof e.slice && n(e.slice(0, 0))
    }
    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    e.exports = function(e) {
        return null != e && (n(e) || r(e) || !!e._isBuffer)
    }
}, function(e, t, n) {
    function r(e, t, n, r) {
        "number" != typeof n && (n = 1), "string" != typeof r && (r = "uint16");
        var i = !e.index && "function" != typeof e.setIndex,
            a = i ? e.getAttribute("index") : e.index,
            s = o(a, t, n, r);
        s && (i ? e.addAttribute("index", s) : e.index = s)
    }

    function i(e, t, n, r, i) {
        if ("number" != typeof r && (r = 3), "string" != typeof i && (i = "float32"), Array.isArray(n) && Array.isArray(n[0]) && n[0].length !== r) throw new Error("Nested vertex array has unexpected size; expected " + r + " but found " + n[0].length);
        var a = e.getAttribute(t),
            s = o(a, n, r, i);
        s && e.addAttribute(t, s)
    }

    function o(e, t, n, r) {
        if (t = t || [], !e || a(e, t, n)) {
            t = c(t, r);
            var i = e && "function" != typeof e.setArray;
            return e && !i || (i && !l && (l = !0, console.warn(["A WebGL buffer is being updated with a new size or itemSize, ", "however this version of ThreeJS only supports fixed-size buffers.", "\nThe old buffer may still be kept in memory.\n", "To avoid memory leaks, it is recommended that you dispose ", "your geometries and create new ones, or update to ThreeJS r82 or newer.\n", "See here for discussion:\n", "https://github.com/mrdoob/three.js/pull/9631"].join(""))), e = new s.BufferAttribute(t, n)), e.itemSize = n, e.needsUpdate = !0, "function" == typeof e.setArray && e.setArray(t), e
        }
        return c(t, e.array), e.needsUpdate = !0, null
    }

    function a(e, t, n) {
        if (e.itemSize !== n) return !0;
        if (!e.array) return !0;
        var r = e.array.length;
        return Array.isArray(t) && Array.isArray(t[0]) ? r !== t.length * n : r !== t.length
    }
    var s = n(0),
        c = n(54),
        l = !1;
    e.exports.attr = i, e.exports.index = r
}, function(e, t, n) {
    function r(e, t, n) {
        if (!e) throw new TypeError("must specify data as first parameter");
        if (n = 0 | +(n || 0), Array.isArray(e) && Array.isArray(e[0])) {
            var r = e[0].length,
                o = e.length * r;
            t && "string" != typeof t || (t = new(i(t || "float32"))(o + n));
            var a = t.length - n;
            if (o !== a) throw new Error("source length " + o + " (" + r + "x" + e.length + ") does not match destination length " + a);
            for (var s = 0, c = n; s < e.length; s++)
                for (var l = 0; l < r; l++) t[c++] = e[s][l]
        } else if (t && "string" != typeof t) t.set(e, n);
        else {
            var h = i(t || "float32");
            0 === n ? t = new h(e) : (t = new h(e.length + n), t.set(e, n))
        }
        return t
    }
    var i = (n(0), n(14));
    e.exports = r
}, function(e, t, n) {
    n(0);
    e.exports.pages = function(e) {
        var t = new Float32Array(4 * e.length * 1),
            n = 0;
        return e.forEach(function(e) {
            var r = e.data.page || 0;
            t[n++] = r, t[n++] = r, t[n++] = r, t[n++] = r
        }), t
    }, e.exports.uvs = function(e, t, n, r) {
        var i = new Float32Array(4 * e.length * 2),
            o = 0;
        return e.forEach(function(e) {
            var a = e.data,
                s = a.x + a.width,
                c = a.y + a.height,
                l = a.x / t,
                h = a.y / n,
                u = s / t,
                d = c / n;
            r && (h = (n - a.y) / n, d = (n - c) / n), i[o++] = l, i[o++] = h, i[o++] = l, i[o++] = d, i[o++] = u, i[o++] = d, i[o++] = u, i[o++] = h
        }), i
    }, e.exports.positions = function(e) {
        var t = new Float32Array(4 * e.length * 2),
            n = 0;
        return e.forEach(function(e) {
            var r = e.data,
                i = e.position[0] + r.xoffset,
                o = e.position[1] + r.yoffset,
                a = r.width,
                s = r.height;
            t[n++] = i, t[n++] = o, t[n++] = i, t[n++] = o + s, t[n++] = i + a, t[n++] = o + s, t[n++] = i + a, t[n++] = o
        }), t
    }
}, function(e, t, n) {
    function r(e) {
        var t = e.length / i;
        o.min[0] = e[0], o.min[1] = e[1], o.max[0] = e[0], o.max[1] = e[1];
        for (var n = 0; n < t; n++) {
            var r = e[n * i + 0],
                a = e[n * i + 1];
            o.min[0] = Math.min(r, o.min[0]), o.min[1] = Math.min(a, o.min[1]), o.max[0] = Math.max(r, o.max[0]), o.max[1] = Math.max(a, o.max[1])
        }
    }
    var i = (n(0), 2),
        o = {
            min: [0, 0],
            max: [0, 0]
        };
    e.exports.computeBox = function(e, t) {
        r(e), t.min.set(o.min[0], o.min[1], 0), t.max.set(o.max[0], o.max[1], 0)
    }, e.exports.computeSphere = function(e, t) {
        r(e);
        var n = o.min[0],
            i = o.min[1],
            a = o.max[0],
            s = o.max[1],
            c = a - n,
            l = s - i,
            h = Math.sqrt(c * c + l * l);
        t.center.set(n + c / 2, i + l / 2, 0), t.radius = h / 2
    }
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(0);
    ! function(e) {
        var t = new i.Vector3(0, 1, 0),
            n = new i.Vector3,
            r = {
                v1: n,
                v2: n,
                side: n,
                up: n,
                out: n,
                name: "nullVect"
            },
            o = function() {
                function n(e, n, o) {
                    this.verts = e.slice(0), this.verts.length > 2 && this.verts[this.verts.length - 1].distanceToSquared(this.verts[0]) < 16 ? (this.isClosed = !0, this.verts.pop()) : this.isClosed = n || !1;
                    var a = this.verts.slice(0),
                        s = this.verts.slice(0);
                    if (this.isClosed ? s.unshift(s.pop()) : (a.pop(), s.shift()), this.verts.length < 3) this.normal = t;
                    else {
                        var c = this.verts,
                            l = c[0],
                            h = c[1],
                            u = c[2];
                        this.normal = h.clone().sub(l).cross(u.clone().sub(h)).normalize().negate()
                    }
                    this.edges = a.map(function(e, t) {
                        var n = s[t],
                            r = n.clone().sub(e).normalize(),
                            i = this.normal;
                        return {
                            v1: e,
                            v2: n,
                            side: r,
                            up: i,
                            out: r.clone().cross(i),
                            name: o ? o[t] : null
                        }
                    }, this);
                    var d = this.edges.slice(0),
                        p = this.edges.slice(0);
                    this.isClosed ? d.push(d.shift()) : (d.unshift(r), p.push(r)), this.vertOutwardDirections = d.map(function(e, t) {
                        var n = p[t];
                        return e.out.clone().add(n.out)
                    });
                    var f = this.verts.reduce(function(e, t) {
                            return e.add(t)
                        }, new i.Vector3).divideScalar(this.verts.length),
                        m = this.normal,
                        g = this.edges[0].v1.clone().sub(this.edges[0].v2).normalize(),
                        v = m.clone().cross(g);
                    this.localMatrix = (new i.Matrix4).makeBasis(g, v, m), this.localMatrix.setPosition(f)
                }
                return n.prototype.move = function(t) {
                    var n = this.verts.map(function(e) {
                        return e.clone().add(t)
                    }, this);
                    return new e.Shape(n, this.isClosed, this.edges.map(function(e) {
                        return e.name
                    }))
                }, n.prototype.checkLineIntersection = function(e, t, n, r, i, o, a, s) {
                    var c, l, h, u, d, p = {
                        x: null,
                        y: null,
                        onLine1: !1,
                        onLine2: !1
                    };
                    return 0 == (c = (s - o) * (n - e) - (a - i) * (r - t)) ? p : (l = t - o, h = e - i, u = (a - i) * l - (s - o) * h, d = (n - e) * l - (r - t) * h, l = u / c, h = d / c, p.x = e + l * (n - e), p.y = t + l * (r - t), l > 0 && l < 1 && (p.onLine1 = !0), h > 0 && h < 1 && (p.onLine2 = !0), p)
                }, n.prototype.expand = function(t) {
                    var n = this,
                        r = this.edges.filter(function(e) {
                            return e.v1.distanceToManhattan(e.v2) > 1
                        }).map(function(e) {
                            var n = e.out.clone().normalize().multiplyScalar(t.x);
                            return {
                                v1: e.v1.clone().add(n),
                                v2: e.v2.clone().add(n),
                                name: e.name
                            }
                        }).map(function(e, r, o) {
                            if (!n.isClosed && (0 == r || r === o.length - 1)) return {
                                v: e.v1,
                                i: r,
                                name: e.name,
                                isDefined: !0
                            };
                            var a = o[(r || o.length) - 1],
                                s = n.checkLineIntersection(e.v1.x, e.v1.y, e.v2.x, e.v2.y, a.v1.x, a.v1.y, a.v2.x, a.v2.y);
                            return {
                                v: new i.Vector3(s.x, s.y, t.y),
                                name: e.name,
                                i: r
                            }
                        });
                    return r.unshift(r.pop()), new e.Shape(r.map(function(e) {
                        return e.v
                    }), this.isClosed, r.map(function(e) {
                        return e.name
                    }))
                }, n.prototype.joinUp = function(t) {
                    console.assert(this.edges.length === t.edges.length), console.assert(this.isClosed === t.isClosed);
                    var n = this.edges,
                        r = t.edges;
                    return n.map(function(t, n) {
                        var i = r[n],
                            o = [i.v2, t.v2, t.v1, i.v1];
                        return new e.Shape(o, !0).withName(t.name)
                    })
                }, n.prototype.withName = function(e) {
                    return this.name = e, this
                }, n.prototype.extrudePath = function(e) {
                    var t = this;
                    return e.length < 2 ? [] : e.map(function(e) {
                        return t.expand(e)
                    }, this).reduce(function(e, t, n, r) {
                        return n > 0 && (e = e.concat(r[n - 1].joinUp(t))), e
                    }, [])
                }, n.prototype.normalizeVerticesZUp = function() {
                    var t = (new i.Matrix4).getInverse(this.localMatrix),
                        n = this.verts.map(function(e) {
                            return e.applyMatrix4(t)
                        });
                    return new e.Shape(n, this.isClosed, this.edges.map(function(e) {
                        return e.name
                    }))
                }, n
            }();
        e.Shape = o
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    /*!
     * Vue.js v1.0.28
     * (c) 2016 Evan You
     * Released under the MIT License.
     */
    function r(e, t, n) {
        if (o(e, t)) return void(e[t] = n);
        if (e._isVue) return void r(e._data, t, n);
        var i = e.__ob__;
        if (!i) return void(e[t] = n);
        if (i.convert(t, n), i.dep.notify(), i.vms)
            for (var a = i.vms.length; a--;) {
                var s = i.vms[a];
                s._proxy(t), s._digest()
            }
        return n
    }

    function i(e, t) {
        if (o(e, t)) {
            delete e[t];
            var n = e.__ob__;
            if (!n) return void(e._isVue && (delete e._data[t], e._digest()));
            if (n.dep.notify(), n.vms)
                for (var r = n.vms.length; r--;) {
                    var i = n.vms[r];
                    i._unproxy(t), i._digest()
                }
        }
    }

    function o(e, t) {
        return kn.call(e, t)
    }

    function a(e) {
        return Dn.test(e)
    }

    function s(e) {
        var t = (e + "").charCodeAt(0);
        return 36 === t || 95 === t
    }

    function c(e) {
        return null == e ? "" : e.toString()
    }

    function l(e) {
        if ("string" != typeof e) return e;
        var t = Number(e);
        return isNaN(t) ? e : t
    }

    function h(e) {
        return "true" === e || "false" !== e && e
    }

    function u(e) {
        var t = e.charCodeAt(0);
        return t !== e.charCodeAt(e.length - 1) || 34 !== t && 39 !== t ? e : e.slice(1, -1)
    }

    function d(e) {
        return e.replace(Nn, p)
    }

    function p(e, t) {
        return t ? t.toUpperCase() : ""
    }

    function f(e) {
        return e.replace(Bn, "$1-$2").replace(Bn, "$1-$2").toLowerCase()
    }

    function m(e) {
        return e.replace(Un, p)
    }

    function g(e, t) {
        return function(n) {
            var r = arguments.length;
            return r ? r > 1 ? e.apply(t, arguments) : e.call(t, n) : e.call(t)
        }
    }

    function v(e, t) {
        t = t || 0;
        for (var n = e.length - t, r = new Array(n); n--;) r[n] = e[n + t];
        return r
    }

    function y(e, t) {
        for (var n = Object.keys(t), r = n.length; r--;) e[n[r]] = t[n[r]];
        return e
    }

    function b(e) {
        return null !== e && "object" == typeof e
    }

    function x(e) {
        return Fn.call(e) === zn
    }

    function w(e, t, n, r) {
        Object.defineProperty(e, t, {
            value: n,
            enumerable: !!r,
            writable: !0,
            configurable: !0
        })
    }

    function _(e, t) {
        var n, r, i, o, a, s = function s() {
            var c = Date.now() - o;
            c < t && c >= 0 ? n = setTimeout(s, t - c) : (n = null, a = e.apply(i, r), n || (i = r = null))
        };
        return function() {
            return i = this, r = arguments, o = Date.now(), n || (n = setTimeout(s, t)), a
        }
    }

    function M(e, t) {
        for (var n = e.length; n--;)
            if (e[n] === t) return n;
        return -1
    }

    function E(e) {
        var t = function t() {
            if (!t.cancelled) return e.apply(this, arguments)
        };
        return t.cancel = function() {
            t.cancelled = !0
        }, t
    }

    function T(e, t) {
        return e == t || !(!b(e) || !b(t)) && JSON.stringify(e) === JSON.stringify(t)
    }

    function S(e) {
        return /native code/.test(e.toString())
    }

    function A(e) {
        this.size = 0, this.limit = e, this.head = this.tail = void 0, this._keymap = Object.create(null)
    }

    function P() {
        return or.charCodeAt(cr + 1)
    }

    function C() {
        return or.charCodeAt(++cr)
    }

    function L() {
        return cr >= sr
    }

    function R() {
        for (; P() === wr;) C()
    }

    function I(e) {
        return e === vr || e === yr
    }

    function O(e) {
        return _r[e]
    }

    function k(e, t) {
        return Mr[e] === t
    }

    function D() {
        for (var e, t = C(); !L();)
            if ((e = C()) === xr) C();
            else if (e === t) break
    }

    function N(e) {
        for (var t = 0, n = e; !L();)
            if (e = P(), I(e)) D();
            else if (n === e && t++, k(n, e) && t--, C(), 0 === t) break
    }

    function B() {
        for (var e = cr; !L();)
            if (lr = P(), I(lr)) D();
            else if (O(lr)) N(lr);
        else if (lr === br) {
            if (C(), (lr = P()) !== br) {
                hr !== pr && hr !== gr || (hr = fr);
                break
            }
            C()
        } else {
            if (lr === wr && (hr === mr || hr === gr)) {
                R();
                break
            }
            hr === fr && (hr = mr), C()
        }
        return or.slice(e + 1, cr) || null
    }

    function U() {
        for (var e = []; !L();) e.push(F());
        return e
    }

    function F() {
        var e, t = {};
        return hr = fr, t.name = B().trim(), hr = gr, e = z(), e.length && (t.args = e), t
    }

    function z() {
        for (var e = []; !L() && hr !== fr;) {
            var t = B();
            if (!t) break;
            e.push(j(t))
        }
        return e
    }

    function j(e) {
        if (dr.test(e)) return {
            value: l(e),
            dynamic: !1
        };
        var t = u(e),
            n = t === e;
        return {
            value: n ? e : t,
            dynamic: n
        }
    }

    function H(e) {
        var t = ur.get(e);
        if (t) return t;
        or = e, ar = {}, sr = or.length, cr = -1, lr = "", hr = pr;
        var n;
        return or.indexOf("|") < 0 ? ar.expression = or.trim() : (ar.expression = B().trim(), n = U(), n.length && (ar.filters = n)), ur.put(e, ar), ar
    }

    function V(e) {
        return e.replace(Tr, "\\$&")
    }

    function G() {
        var e = V(Or.delimiters[0]),
            t = V(Or.delimiters[1]),
            n = V(Or.unsafeDelimiters[0]),
            r = V(Or.unsafeDelimiters[1]);
        Ar = new RegExp(n + "((?:.|\\n)+?)" + r + "|" + e + "((?:.|\\n)+?)" + t, "g"), Pr = new RegExp("^" + n + "((?:.|\\n)+?)" + r + "$"), Sr = new A(1e3)
    }

    function W(e) {
        Sr || G();
        var t = Sr.get(e);
        if (t) return t;
        if (!Ar.test(e)) return null;
        for (var n, r, i, o, a, s, c = [], l = Ar.lastIndex = 0; n = Ar.exec(e);) r = n.index, r > l && c.push({
            value: e.slice(l, r)
        }), i = Pr.test(n[0]), o = i ? n[1] : n[2], a = o.charCodeAt(0), s = 42 === a, o = s ? o.slice(1) : o, c.push({
            tag: !0,
            value: o.trim(),
            html: i,
            oneTime: s
        }), l = r + n[0].length;
        return l < e.length && c.push({
            value: e.slice(l)
        }), Sr.put(e, c), c
    }

    function $(e, t) {
        return e.length > 1 ? e.map(function(e) {
            return X(e, t)
        }).join("+") : X(e[0], t, !0)
    }

    function X(e, t, n) {
        return e.tag ? e.oneTime && t ? '"' + t.$eval(e.value) + '"' : q(e.value, n) : '"' + e.value + '"'
    }

    function q(e, t) {
        if (Cr.test(e)) {
            var n = H(e);
            return n.filters ? "this._applyFilters(" + n.expression + ",null," + JSON.stringify(n.filters) + ",false)" : "(" + e + ")"
        }
        return t ? e : "(" + e + ")"
    }

    function Y(e, t, n, r) {
        K(e, 1, function() {
            t.appendChild(e)
        }, n, r)
    }

    function Z(e, t, n, r) {
        K(e, 1, function() {
            ie(e, t)
        }, n, r)
    }

    function J(e, t, n) {
        K(e, -1, function() {
            ae(e)
        }, t, n)
    }

    function K(e, t, n, r, i) {
        var o = e.__v_trans;
        if (!o || !o.hooks && !Jn || !r._isCompiled || r.$parent && !r.$parent._isCompiled) return n(), void(i && i());
        o[t > 0 ? "enter" : "leave"](n, i)
    }

    function Q(e) {
        if ("string" == typeof e) {
            e = document.querySelector(e)
        }
        return e
    }

    function ee(e) {
        if (!e) return !1;
        var t = e.ownerDocument.documentElement,
            n = e.parentNode;
        return t === e || t === n || !(!n || 1 !== n.nodeType || !t.contains(n))
    }

    function te(e, t) {
        var n = e.getAttribute(t);
        return null !== n && e.removeAttribute(t), n
    }

    function ne(e, t) {
        var n = te(e, ":" + t);
        return null === n && (n = te(e, "v-bind:" + t)), n
    }

    function re(e, t) {
        return e.hasAttribute(t) || e.hasAttribute(":" + t) || e.hasAttribute("v-bind:" + t)
    }

    function ie(e, t) {
        t.parentNode.insertBefore(e, t)
    }

    function oe(e, t) {
        t.nextSibling ? ie(e, t.nextSibling) : t.parentNode.appendChild(e)
    }

    function ae(e) {
        e.parentNode.removeChild(e)
    }

    function se(e, t) {
        t.firstChild ? ie(e, t.firstChild) : t.appendChild(e)
    }

    function ce(e, t) {
        var n = e.parentNode;
        n && n.replaceChild(t, e)
    }

    function le(e, t, n, r) {
        e.addEventListener(t, n, r)
    }

    function he(e, t, n) {
        e.removeEventListener(t, n)
    }

    function ue(e) {
        var t = e.className;
        return "object" == typeof t && (t = t.baseVal || ""), t
    }

    function de(e, t) {
        Xn && !/svg$/.test(e.namespaceURI) ? e.className = t : e.setAttribute("class", t)
    }

    function pe(e, t) {
        if (e.classList) e.classList.add(t);
        else {
            var n = " " + ue(e) + " ";
            n.indexOf(" " + t + " ") < 0 && de(e, (n + t).trim())
        }
    }

    function fe(e, t) {
        if (e.classList) e.classList.remove(t);
        else {
            for (var n = " " + ue(e) + " ", r = " " + t + " "; n.indexOf(r) >= 0;) n = n.replace(r, " ");
            de(e, n.trim())
        }
        e.className || e.removeAttribute("class")
    }

    function me(e, t) {
        var n, r;
        if (ye(e) && Me(e.content) && (e = e.content), e.hasChildNodes())
            for (ge(e), r = t ? document.createDocumentFragment() : document.createElement("div"); n = e.firstChild;) r.appendChild(n);
        return r
    }

    function ge(e) {
        for (var t; t = e.firstChild, ve(t);) e.removeChild(t);
        for (; t = e.lastChild, ve(t);) e.removeChild(t)
    }

    function ve(e) {
        return e && (3 === e.nodeType && !e.data.trim() || 8 === e.nodeType)
    }

    function ye(e) {
        return e.tagName && "template" === e.tagName.toLowerCase()
    }

    function be(e, t) {
        var n = Or.debug ? document.createComment(e) : document.createTextNode(t ? " " : "");
        return n.__v_anchor = !0, n
    }

    function xe(e) {
        if (e.hasAttributes())
            for (var t = e.attributes, n = 0, r = t.length; n < r; n++) {
                var i = t[n].name;
                if (Nr.test(i)) return d(i.replace(Nr, ""))
            }
    }

    function we(e, t, n) {
        for (var r; e !== t;) r = e.nextSibling, n(e), e = r;
        n(t)
    }

    function _e(e, t, n, r, i) {
        function o() {
            if (s++, a && s >= c.length) {
                for (var e = 0; e < c.length; e++) r.appendChild(c[e]);
                i && i()
            }
        }
        var a = !1,
            s = 0,
            c = [];
        we(e, t, function(e) {
            e === t && (a = !0), c.push(e), J(e, n, o)
        })
    }

    function Me(e) {
        return e && 11 === e.nodeType
    }

    function Ee(e) {
        if (e.outerHTML) return e.outerHTML;
        var t = document.createElement("div");
        return t.appendChild(e.cloneNode(!0)), t.innerHTML
    }

    function Te(e, t) {
        var n = e.tagName.toLowerCase(),
            r = e.hasAttributes();
        if (Br.test(n) || Ur.test(n)) {
            if (r) return Se(e, t)
        } else {
            if (Oe(t, "components", n)) return {
                id: n
            };
            var i = r && Se(e, t);
            if (i) return i
        }
    }

    function Se(e, t) {
        var n = e.getAttribute("is");
        if (null != n) {
            if (Oe(t, "components", n)) return e.removeAttribute("is"), {
                id: n
            }
        } else if (null != (n = ne(e, "is"))) return {
            id: n,
            dynamic: !0
        }
    }

    function Ae(e, t) {
        var n, i, a;
        for (n in t) i = e[n], a = t[n], o(e, n) ? b(i) && b(a) && Ae(i, a) : r(e, n, a);
        return e
    }

    function Pe(e, t) {
        var n = Object.create(e || null);
        return t ? y(n, Re(t)) : n
    }

    function Ce(e) {
        if (e.components)
            for (var t, n = e.components = Re(e.components), r = Object.keys(n), i = 0, o = r.length; i < o; i++) {
                var a = r[i];
                Br.test(a) || Ur.test(a) || (t = n[a], x(t) && (n[a] = Cn.extend(t)))
            }
    }

    function Le(e) {
        var t, n, r = e.props;
        if (jn(r))
            for (e.props = {}, t = r.length; t--;) n = r[t], "string" == typeof n ? e.props[n] = null : n.name && (e.props[n.name] = n);
        else if (x(r)) {
            var i = Object.keys(r);
            for (t = i.length; t--;) "function" == typeof(n = r[i[t]]) && (r[i[t]] = {
                type: n
            })
        }
    }

    function Re(e) {
        if (jn(e)) {
            for (var t, n = {}, r = e.length; r--;) {
                t = e[r];
                var i = "function" == typeof t ? t.options && t.options.name || t.id : t.name || t.id;
                i && (n[i] = t)
            }
            return n
        }
        return e
    }

    function Ie(e, t, n) {
        function r(r) {
            var i = Fr[r] || zr;
            a[r] = i(e[r], t[r], n, r)
        }
        Ce(t), Le(t);
        var i, a = {};
        if (t.extends && (e = "function" == typeof t.extends ? Ie(e, t.extends.options, n) : Ie(e, t.extends, n)), t.mixins)
            for (var s = 0, c = t.mixins.length; s < c; s++) {
                var l = t.mixins[s],
                    h = l.prototype instanceof Cn ? l.options : l;
                e = Ie(e, h, n)
            }
        for (i in e) r(i);
        for (i in t) o(e, i) || r(i);
        return a
    }

    function Oe(e, t, n, r) {
        if ("string" == typeof n) {
            var i, o = e[t];
            return o[n] || o[i = d(n)] || o[i.charAt(0).toUpperCase() + i.slice(1)]
        }
    }

    function ke() {
        this.id = jr++, this.subs = []
    }

    function De(e) {
        Wr = !1, e(), Wr = !0
    }

    function Ne(e) {
        if (this.value = e, this.dep = new ke, w(e, "__ob__", this), jn(e)) {
            (Hn ? Be : Ue)(e, Vr, Gr), this.observeArray(e)
        } else this.walk(e)
    }

    function Be(e, t) {
        e.__proto__ = t
    }

    function Ue(e, t, n) {
        for (var r = 0, i = n.length; r < i; r++) {
            var o = n[r];
            w(e, o, t[o])
        }
    }

    function Fe(e, t) {
        if (e && "object" == typeof e) {
            var n;
            return o(e, "__ob__") && e.__ob__ instanceof Ne ? n = e.__ob__ : Wr && (jn(e) || x(e)) && Object.isExtensible(e) && !e._isVue && (n = new Ne(e)), n && t && n.addVm(t), n
        }
    }

    function ze(e, t, n) {
        var r = new ke,
            i = Object.getOwnPropertyDescriptor(e, t);
        if (!i || !1 !== i.configurable) {
            var o = i && i.get,
                a = i && i.set,
                s = Fe(n);
            Object.defineProperty(e, t, {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    var t = o ? o.call(e) : n;
                    if (ke.target && (r.depend(), s && s.dep.depend(), jn(t)))
                        for (var i, a = 0, c = t.length; a < c; a++)(i = t[a]) && i.__ob__ && i.__ob__.dep.depend();
                    return t
                },
                set: function(t) {
                    t !== (o ? o.call(e) : n) && (a ? a.call(e, t) : n = t, s = Fe(t), r.notify())
                }
            })
        }
    }

    function je(e) {
        if (void 0 === e) return "eof";
        var t = e.charCodeAt(0);
        switch (t) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
            case 48:
                return e;
            case 95:
            case 36:
                return "ident";
            case 32:
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
                return "ws"
        }
        return t >= 97 && t <= 122 || t >= 65 && t <= 90 ? "ident" : t >= 49 && t <= 57 ? "number" : "else"
    }

    function He(e) {
        var t = e.trim();
        return ("0" !== e.charAt(0) || !isNaN(e)) && (a(t) ? u(t) : "*" + t)
    }

    function Ve(e) {
        var t, n, r, i, o, a, s, c = [],
            l = -1,
            h = Qr,
            u = 0,
            d = [];
        for (d[Zr] = function() {
                void 0 !== r && (c.push(r), r = void 0)
            }, d[Yr] = function() {
                void 0 === r ? r = n : r += n
            }, d[Jr] = function() {
                d[Yr](), u++
            }, d[Kr] = function() {
                if (u > 0) u--, h = ei, d[Yr]();
                else {
                    if (u = 0, !1 === (r = He(r))) return !1;
                    d[Zr]()
                }
            }; null != h;)
            if (l++, "\\" !== (t = e[l]) || ! function() {
                    var t = e[l + 1];
                    if (h === ti && "'" === t || h === ni && '"' === t) return l++, n = "\\" + t, d[Yr](), !0
                }()) {
                if (i = je(t), s = oi[h], (o = s[i] || s.else || ii) === ii) return;
                if (h = o[0], (a = d[o[1]]) && (n = o[2], n = void 0 === n ? t : n, !1 === a())) return;
                if (h === ri) return c.raw = e, c
            }
    }

    function Ge(e) {
        var t = qr.get(e);
        return t || (t = Ve(e)) && qr.put(e, t), t
    }

    function We(e, t) {
        return et(t).get(e)
    }

    function $e(e, t, n) {
        var i = e;
        if ("string" == typeof t && (t = Ve(t)), !t || !b(e)) return !1;
        for (var o, a, s = 0, c = t.length; s < c; s++) o = e, a = t[s], "*" === a.charAt(0) && (a = et(a.slice(1)).get.call(i, i)), s < c - 1 ? (e = e[a], b(e) || (e = {}, r(o, a, e))) : jn(e) ? e.$set(a, n) : a in e ? e[a] = n : r(e, a, n);
        return !0
    }

    function Xe() {}

    function qe(e, t) {
        var n = bi.length;
        return bi[n] = t ? e.replace(pi, "\\n") : e, '"' + n + '"'
    }

    function Ye(e) {
        var t = e.charAt(0),
            n = e.slice(1);
        return li.test(n) ? e : (n = n.indexOf('"') > -1 ? n.replace(mi, Ze) : n, t + "scope." + n)
    }

    function Ze(e, t) {
        return bi[t]
    }

    function Je(e) {
        ui.test(e), bi.length = 0;
        var t = e.replace(fi, qe).replace(di, "");
        return t = (" " + t).replace(vi, Ye).replace(mi, Ze), Ke(t)
    }

    function Ke(e) {
        try {
            return new Function("scope", "return " + e + ";")
        } catch (e) {
            return Xe
        }
    }

    function Qe(e) {
        var t = Ge(e);
        if (t) return function(e, n) {
            $e(e, t, n)
        }
    }

    function et(e, t) {
        e = e.trim();
        var n = si.get(e);
        if (n) return t && !n.set && (n.set = Qe(n.exp)), n;
        var r = {
            exp: e
        };
        return r.get = tt(e) && e.indexOf("[") < 0 ? Ke("scope." + e) : Je(e), t && (r.set = Qe(e)), si.put(e, r), r
    }

    function tt(e) {
        return gi.test(e) && !yi.test(e) && "Math." !== e.slice(0, 5)
    }

    function nt() {
        wi.length = 0, _i.length = 0, Mi = {}, Ei = {}, Ti = !1
    }

    function rt() {
        for (var e = !0; e;) e = !1, it(wi), it(_i), wi.length ? e = !0 : (Gn && Or.devtools && Gn.emit("flush"), nt())
    }

    function it(e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t],
                r = n.id;
            Mi[r] = null, n.run()
        }
        e.length = 0
    }

    function ot(e) {
        var t = e.id;
        if (null == Mi[t]) {
            var n = e.user ? _i : wi;
            Mi[t] = n.length, n.push(e), Ti || (Ti = !0, nr(rt))
        }
    }

    function at(e, t, n, r) {
        r && y(this, r);
        var i = "function" == typeof t;
        if (this.vm = e, e._watchers.push(this), this.expression = t, this.cb = n, this.id = ++Si, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new rr, this.newDepIds = new rr, this.prevError = null, i) this.getter = t, this.setter = void 0;
        else {
            var o = et(t, this.twoWay);
            this.getter = o.get, this.setter = o.set
        }
        this.value = this.lazy ? void 0 : this.get(), this.queued = this.shallow = !1
    }

    function st(e, t) {
        var n = void 0,
            r = void 0;
        t || (t = Ai, t.clear());
        var i = jn(e),
            o = b(e);
        if ((i || o) && Object.isExtensible(e)) {
            if (e.__ob__) {
                var a = e.__ob__.dep.id;
                if (t.has(a)) return;
                t.add(a)
            }
            if (i)
                for (n = e.length; n--;) st(e[n], t);
            else if (o)
                for (r = Object.keys(e), n = r.length; n--;) st(e[r[n]], t)
        }
    }

    function ct(e) {
        return ye(e) && Me(e.content)
    }

    function lt(e, t) {
        var n = t ? e : e.trim(),
            r = Ci.get(n);
        if (r) return r;
        var i = document.createDocumentFragment(),
            o = e.match(Ii),
            a = Oi.test(e),
            s = ki.test(e);
        if (o || a || s) {
            var c = o && o[1],
                l = Ri[c] || Ri.efault,
                h = l[0],
                u = l[1],
                d = l[2],
                p = document.createElement("div");
            for (p.innerHTML = u + e + d; h--;) p = p.lastChild;
            for (var f; f = p.firstChild;) i.appendChild(f)
        } else i.appendChild(document.createTextNode(e));
        return t || ge(i), Ci.put(n, i), i
    }

    function ht(e) {
        if (ct(e)) return lt(e.innerHTML);
        if ("SCRIPT" === e.tagName) return lt(e.textContent);
        for (var t, n = ut(e), r = document.createDocumentFragment(); t = n.firstChild;) r.appendChild(t);
        return ge(r), r
    }

    function ut(e) {
        if (!e.querySelectorAll) return e.cloneNode();
        var t, n, r, i = e.cloneNode(!0);
        if (Di) {
            var o = i;
            if (ct(e) && (e = e.content, o = i.content), n = e.querySelectorAll("template"), n.length)
                for (r = o.querySelectorAll("template"), t = r.length; t--;) r[t].parentNode.replaceChild(ut(n[t]), r[t])
        }
        if (Ni)
            if ("TEXTAREA" === e.tagName) i.value = e.value;
            else if (n = e.querySelectorAll("textarea"), n.length)
            for (r = i.querySelectorAll("textarea"), t = r.length; t--;) r[t].value = n[t].value;
        return i
    }

    function dt(e, t, n) {
        var r, i;
        return Me(e) ? (ge(e), t ? ut(e) : e) : ("string" == typeof e ? n || "#" !== e.charAt(0) ? i = lt(e, n) : (i = Li.get(e)) || (r = document.getElementById(e.slice(1))) && (i = ht(r), Li.put(e, i)) : e.nodeType && (i = ht(e)), i && t ? ut(i) : i)
    }

    function pt(e, t, n, r, i, o) {
        this.children = [], this.childFrags = [], this.vm = t, this.scope = i, this.inserted = !1, this.parentFrag = o, o && o.childFrags.push(this), this.unlink = e(t, n, r, i, this), (this.single = 1 === n.childNodes.length && !n.childNodes[0].__v_anchor) ? (this.node = n.childNodes[0], this.before = ft, this.remove = mt) : (this.node = be("fragment-start"), this.end = be("fragment-end"), this.frag = n, se(this.node, n), n.appendChild(this.end), this.before = gt, this.remove = vt), this.node.__v_frag = this
    }

    function ft(e, t) {
        this.inserted = !0, (!1 !== t ? Z : ie)(this.node, e, this.vm), ee(this.node) && this.callHook(yt)
    }

    function mt() {
        this.inserted = !1;
        var e = ee(this.node),
            t = this;
        this.beforeRemove(), J(this.node, this.vm, function() {
            e && t.callHook(bt), t.destroy()
        })
    }

    function gt(e, t) {
        this.inserted = !0;
        var n = this.vm,
            r = !1 !== t ? Z : ie;
        we(this.node, this.end, function(t) {
            r(t, e, n)
        }), ee(this.node) && this.callHook(yt)
    }

    function vt() {
        this.inserted = !1;
        var e = this,
            t = ee(this.node);
        this.beforeRemove(), _e(this.node, this.end, this.vm, this.frag, function() {
            t && e.callHook(bt), e.destroy()
        })
    }

    function yt(e) {
        !e._isAttached && ee(e.$el) && e._callHook("attached")
    }

    function bt(e) {
        e._isAttached && !ee(e.$el) && e._callHook("detached")
    }

    function xt(e, t) {
        this.vm = e;
        var n, r = "string" == typeof t;
        r || ye(t) && !t.hasAttribute("v-if") ? n = dt(t, !0) : (n = document.createDocumentFragment(), n.appendChild(t)), this.template = n;
        var i, o = e.constructor.cid;
        if (o > 0) {
            var a = o + (r ? t : Ee(t));
            i = Fi.get(a), i || (i = Yt(n, e.$options, !0), Fi.put(a, i))
        } else i = Yt(n, e.$options, !0);
        this.linker = i
    }

    function wt(e, t, n) {
        var r = e.node.previousSibling;
        if (r) {
            for (e = r.__v_frag; !(e && e.forId === n && e.inserted || r === t);) {
                if (!(r = r.previousSibling)) return;
                e = r.__v_frag
            }
            return e
        }
    }

    function _t(e) {
        for (var t = -1, n = new Array(Math.floor(e)); ++t < e;) n[t] = t;
        return n
    }

    function Mt(e, t, n, r) {
        return r ? "$index" === r ? e : r.charAt(0).match(/\w/) ? We(n, r) : n[r] : t || n
    }

    function Et(e) {
        var t = e.node;
        if (e.end)
            for (; !t.__vue__ && t !== e.end && t.nextSibling;) t = t.nextSibling;
        return t.__vue__
    }

    function Tt(e, t, n) {
        for (var r, i, o = t ? [] : null, a = 0, s = e.options.length; a < s; a++)
            if (r = e.options[a], n ? r.hasAttribute("selected") : r.selected) {
                if (i = r.hasOwnProperty("_value") ? r._value : r.value, !t) return i;
                o.push(i)
            }
        return o
    }

    function St(e, t) {
        for (var n = e.length; n--;)
            if (T(e[n], t)) return n;
        return -1
    }

    function At(e, t) {
        var n = t.map(function(e) {
            var t = e.charCodeAt(0);
            return t > 47 && t < 58 ? parseInt(e, 10) : 1 === e.length && (t = e.toUpperCase().charCodeAt(0)) > 64 && t < 91 ? t : Zi[e]
        });
        return n = [].concat.apply([], n),
            function(t) {
                if (n.indexOf(t.keyCode) > -1) return e.call(this, t)
            }
    }

    function Pt(e) {
        return function(t) {
            return t.stopPropagation(), e.call(this, t)
        }
    }

    function Ct(e) {
        return function(t) {
            return t.preventDefault(), e.call(this, t)
        }
    }

    function Lt(e) {
        return function(t) {
            if (t.target === t.currentTarget) return e.call(this, t)
        }
    }

    function Rt(e) {
        if (to[e]) return to[e];
        var t = It(e);
        return to[e] = to[t] = t, t
    }

    function It(e) {
        e = f(e);
        var t = d(e),
            n = t.charAt(0).toUpperCase() + t.slice(1);
        no || (no = document.createElement("div"));
        var r, i = Ki.length;
        if ("filter" !== t && t in no.style) return {
            kebab: e,
            camel: t
        };
        for (; i--;)
            if ((r = Qi[i] + n) in no.style) return {
                kebab: Ki[i] + e,
                camel: r
            }
    }

    function Ot(e) {
        var t = [];
        if (jn(e))
            for (var n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                if (i)
                    if ("string" == typeof i) t.push(i);
                    else
                        for (var o in i) i[o] && t.push(o)
            } else if (b(e))
                for (var a in e) e[a] && t.push(a);
        return t
    }

    function kt(e, t, n) {
        if (t = t.trim(), -1 === t.indexOf(" ")) return void n(e, t);
        for (var r = t.split(/\s+/), i = 0, o = r.length; i < o; i++) n(e, r[i])
    }

    function Dt(e, t, n) {
        function r() {
            ++o >= i ? n() : e[o].call(t, r)
        }
        var i = e.length,
            o = 0;
        e[0].call(t, r)
    }

    function Nt(e, t, n) {
        for (var r, i, o, s, c, l, h, u = [], p = n.$options.propsData, m = Object.keys(t), g = m.length; g--;)
            if (i = m[g], r = t[i] || yo, c = d(i), bo.test(c)) {
                if (h = {
                        name: i,
                        path: c,
                        options: r,
                        mode: vo.ONE_WAY,
                        raw: null
                    }, o = f(i), null === (s = ne(e, o)) && (null !== (s = ne(e, o + ".sync")) ? h.mode = vo.TWO_WAY : null !== (s = ne(e, o + ".once")) && (h.mode = vo.ONE_TIME)), null !== s) h.raw = s, l = H(s), s = l.expression, h.filters = l.filters, a(s) && !l.filters ? h.optimizedLiteral = !0 : h.dynamic = !0, h.parentPath = s;
                else if (null !== (s = te(e, o))) h.raw = s;
                else if (p && null !== (s = p[i] || p[c])) h.raw = s;
                else;
                u.push(h)
            }
        return Bt(u)
    }

    function Bt(e) {
        return function(t, n) {
            t._props = {};
            for (var r, i, a, s, c, d = t.$options.propsData, p = e.length; p--;)
                if (r = e[p], c = r.raw, i = r.path, a = r.options, t._props[i] = r, d && o(d, i) && Ft(t, r, d[i]), null === c) Ft(t, r, void 0);
                else if (r.dynamic) r.mode === vo.ONE_TIME ? (s = (n || t._context || t).$get(r.parentPath), Ft(t, r, s)) : t._context ? t._bindDir({
                name: "prop",
                def: wo,
                prop: r
            }, null, null, n) : Ft(t, r, t.$get(r.parentPath));
            else if (r.optimizedLiteral) {
                var m = u(c);
                s = m === c ? h(l(c)) : m, Ft(t, r, s)
            } else s = a.type === Boolean && ("" === c || c === f(r.name)) || c, Ft(t, r, s)
        }
    }

    function Ut(e, t, n, r) {
        var i = t.dynamic && tt(t.parentPath),
            o = n;
        void 0 === o && (o = jt(e, t)), o = Vt(t, o, e);
        var a = o !== n;
        Ht(t, o, e) || (o = void 0), i && !a ? De(function() {
            r(o)
        }) : r(o)
    }

    function Ft(e, t, n) {
        Ut(e, t, n, function(n) {
            ze(e, t.path, n)
        })
    }

    function zt(e, t, n) {
        Ut(e, t, n, function(n) {
            e[t.path] = n
        })
    }

    function jt(e, t) {
        var n = t.options;
        if (!o(n, "default")) return n.type !== Boolean && void 0;
        var r = n.default;
        return b(r), "function" == typeof r && n.type !== Function ? r.call(e) : r
    }

    function Ht(e, t, n) {
        if (!e.options.required && (null === e.raw || null == t)) return !0;
        var r = e.options,
            i = r.type,
            o = !i,
            a = [];
        if (i) {
            jn(i) || (i = [i]);
            for (var s = 0; s < i.length && !o; s++) {
                var c = Gt(t, i[s]);
                a.push(c.expectedType), o = c.valid
            }
        }
        if (!o) return !1;
        var l = r.validator;
        return !(l && !l(t))
    }

    function Vt(e, t, n) {
        var r = e.options.coerce;
        return r && "function" == typeof r ? r(t) : t
    }

    function Gt(e, t) {
        var n, r;
        return t === String ? (r = "string", n = typeof e === r) : t === Number ? (r = "number", n = typeof e === r) : t === Boolean ? (r = "boolean", n = typeof e === r) : t === Function ? (r = "function", n = typeof e === r) : t === Object ? (r = "object", n = x(e)) : t === Array ? (r = "array", n = jn(e)) : n = e instanceof t, {
            valid: n,
            expectedType: r
        }
    }

    function Wt(e) {
        _o.push(e), Mo || (Mo = !0, nr($t))
    }

    function $t() {
        for (var e = document.documentElement.offsetHeight, t = 0; t < _o.length; t++) _o[t]();
        return _o = [], Mo = !1, e
    }

    function Xt(e, t, n, r) {
        this.id = t, this.el = e, this.enterClass = n && n.enterClass || t + "-enter", this.leaveClass = n && n.leaveClass || t + "-leave", this.hooks = n, this.vm = r, this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null, this.justEntered = !1, this.entered = this.left = !1, this.typeCache = {}, this.type = n && n.type;
        var i = this;
        ["enterNextTick", "enterDone", "leaveNextTick", "leaveDone"].forEach(function(e) {
            i[e] = g(i[e], i)
        })
    }

    function qt(e) {
        if (/svg$/.test(e.namespaceURI)) {
            var t = e.getBoundingClientRect();
            return !(t.width || t.height)
        }
        return !(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
    }

    function Yt(e, t, n) {
        var r = n || !t._asComponent ? nn(e, t) : null,
            i = r && r.terminal || xn(e) || !e.hasChildNodes() ? null : ln(e.childNodes, t);
        return function(e, t, n, o, a) {
            var s = v(t.childNodes),
                c = Zt(function() {
                    r && r(e, t, n, o, a), i && i(e, s, n, o, a)
                }, e);
            return Kt(e, c)
        }
    }

    function Zt(e, t) {
        t._directives = [];
        var n = t._directives.length;
        e();
        var r = t._directives.slice(n);
        Jt(r);
        for (var i = 0, o = r.length; i < o; i++) r[i]._bind();
        return r
    }

    function Jt(e) {
        if (0 !== e.length) {
            var t, n, r, i, o = {},
                a = 0,
                s = [];
            for (t = 0, n = e.length; t < n; t++) {
                var c = e[t],
                    l = c.descriptor.def.priority || Uo,
                    h = o[l];
                h || (h = o[l] = [], s.push(l)), h.push(c)
            }
            for (s.sort(function(e, t) {
                    return e > t ? -1 : e === t ? 0 : 1
                }), t = 0, n = s.length; t < n; t++) {
                var u = o[s[t]];
                for (r = 0, i = u.length; r < i; r++) e[a++] = u[r]
            }
        }
    }

    function Kt(e, t, n, r) {
        function i(i) {
            Qt(e, t, i), n && r && Qt(n, r)
        }
        return i.dirs = t, i
    }

    function Qt(e, t, n) {
        for (var r = t.length; r--;) t[r]._teardown()
    }

    function en(e, t, n, r) {
        var i = Nt(t, n, e),
            o = Zt(function() {
                i(e, r)
            }, e);
        return Kt(e, o)
    }

    function tn(e, t, n) {
        var r, i, o = t._containerAttrs,
            a = t._replacerAttrs;
        if (11 !== e.nodeType) t._asComponent ? (o && n && (r = gn(o, n)), a && (i = gn(a, t))) : i = gn(e.attributes, t);
        else;
        return t._containerAttrs = t._replacerAttrs = null,
            function(e, t, n) {
                var o, a = e._context;
                a && r && (o = Zt(function() {
                    r(a, t, null, n)
                }, a));
                var s = Zt(function() {
                    i && i(e, t)
                }, e);
                return Kt(e, s, a, o)
            }
    }

    function nn(e, t) {
        var n = e.nodeType;
        return 1 !== n || xn(e) ? 3 === n && e.data.trim() ? on(e, t) : null : rn(e, t)
    }

    function rn(e, t) {
        if ("TEXTAREA" === e.tagName) {
            if (null !== te(e, "v-pre")) return fn;
            var n = W(e.value);
            n && (e.setAttribute(":value", $(n)), e.value = "")
        }
        var r, i = e.hasAttributes(),
            o = i && v(e.attributes);
        return i && (r = pn(e, o, t)), r || (r = un(e, t)), r || (r = dn(e, t)), !r && i && (r = gn(o, t)), r
    }

    function on(e, t) {
        if (e._skip) return an;
        var n = W(e.wholeText);
        if (!n) return null;
        for (var r = e.nextSibling; r && 3 === r.nodeType;) r._skip = !0, r = r.nextSibling;
        for (var i, o, a = document.createDocumentFragment(), s = 0, c = n.length; s < c; s++) o = n[s], i = o.tag ? sn(o, t) : document.createTextNode(o.value), a.appendChild(i);
        return cn(n, a)
    }

    function an(e, t) {
        ae(t)
    }

    function sn(e, t) {
        function n(t) {
            if (!e.descriptor) {
                var n = H(e.value);
                e.descriptor = {
                    name: t,
                    def: fo[t],
                    expression: n.expression,
                    filters: n.filters
                }
            }
        }
        var r;
        return e.oneTime ? r = document.createTextNode(e.value) : e.html ? (r = document.createComment("v-html"), n("html")) : (r = document.createTextNode(" "), n("text")), r
    }

    function cn(e, t) {
        return function(n, r, i, o) {
            for (var a, s, l, h = t.cloneNode(!0), u = v(h.childNodes), d = 0, p = e.length; d < p; d++) a = e[d], s = a.value, a.tag && (l = u[d], a.oneTime ? (s = (o || n).$eval(s), a.html ? ce(l, dt(s, !0)) : l.data = c(s)) : n._bindDir(a.descriptor, l, i, o));
            ce(r, h)
        }
    }

    function ln(e, t) {
        for (var n, r, i, o = [], a = 0, s = e.length; a < s; a++) i = e[a], n = nn(i, t), r = n && n.terminal || "SCRIPT" === i.tagName || !i.hasChildNodes() ? null : ln(i.childNodes, t), o.push(n, r);
        return o.length ? hn(o) : null
    }

    function hn(e) {
        return function(t, n, r, i, o) {
            for (var a, s, c, l = 0, h = 0, u = e.length; l < u; h++) {
                a = n[h], s = e[l++], c = e[l++];
                var d = v(a.childNodes);
                s && s(t, a, r, i, o), c && c(t, d, r, i, o)
            }
        }
    }

    function un(e, t) {
        var n = e.tagName.toLowerCase();
        if (!Br.test(n)) {
            var r = Oe(t, "elementDirectives", n);
            return r ? mn(e, n, "", t, r) : void 0
        }
    }

    function dn(e, t) {
        var n = Te(e, t);
        if (n) {
            var r = xe(e),
                i = {
                    name: "component",
                    ref: r,
                    expression: n.id,
                    def: Io.component,
                    modifiers: {
                        literal: !n.dynamic
                    }
                },
                o = function(e, t, n, o, a) {
                    r && ze((o || e).$refs, r, null), e._bindDir(i, t, n, o, a)
                };
            return o.terminal = !0, o
        }
    }

    function pn(e, t, n) {
        if (null !== te(e, "v-pre")) return fn;
        if (e.hasAttribute("v-else")) {
            var r = e.previousElementSibling;
            if (r && r.hasAttribute("v-if")) return fn
        }
        for (var i, o, a, s, c, l, h, u, d, p, f = 0, m = t.length; f < m; f++) i = t[f], o = i.name.replace(No, ""), (c = o.match(Do)) && (d = Oe(n, "directives", c[1])) && d.terminal && (!p || (d.priority || Fo) > p.priority) && (p = d, h = i.name, s = vn(i.name), a = i.value, l = c[1], u = c[2]);
        return p ? mn(e, l, a, n, p, h, u, s) : void 0
    }

    function fn() {}

    function mn(e, t, n, r, i, o, a, s) {
        var c = H(n),
            l = {
                name: t,
                arg: a,
                expression: c.expression,
                filters: c.filters,
                raw: n,
                attr: o,
                modifiers: s,
                def: i
            };
        "for" !== t && "router-view" !== t || (l.ref = xe(e));
        var h = function(e, t, n, r, i) {
            l.ref && ze((r || e).$refs, l.ref, null), e._bindDir(l, t, n, r, i)
        };
        return h.terminal = !0, h
    }

    function gn(e, t) {
        function n(e, t, n) {
            var r = n && bn(n),
                i = !r && H(o);
            m.push({
                name: e,
                attr: a,
                raw: s,
                def: t,
                arg: l,
                modifiers: h,
                expression: i && i.expression,
                filters: i && i.filters,
                interp: n,
                hasOneTime: r
            })
        }
        for (var r, i, o, a, s, c, l, h, u, d, p, f = e.length, m = []; f--;)
            if (r = e[f], i = a = r.name, o = s = r.value, d = W(o), l = null, h = vn(i), i = i.replace(No, ""), d) o = $(d), l = i, n("bind", fo.bind, d);
            else if (Bo.test(i)) h.literal = !Oo.test(i), n("transition", Io.transition);
        else if (ko.test(i)) l = i.replace(ko, ""), n("on", fo.on);
        else if (Oo.test(i)) c = i.replace(Oo, ""), "style" === c || "class" === c ? n(c, Io[c]) : (l = c, n("bind", fo.bind));
        else if (p = i.match(Do)) {
            if (c = p[1], l = p[2], "else" === c) continue;
            u = Oe(t, "directives", c, !0), u && n(c, u)
        }
        if (m.length) return yn(m)
    }

    function vn(e) {
        var t = Object.create(null),
            n = e.match(No);
        if (n)
            for (var r = n.length; r--;) t[n[r].slice(1)] = !0;
        return t
    }

    function yn(e) {
        return function(t, n, r, i, o) {
            for (var a = e.length; a--;) t._bindDir(e[a], n, r, i, o)
        }
    }

    function bn(e) {
        for (var t = e.length; t--;)
            if (e[t].oneTime) return !0
    }

    function xn(e) {
        return "SCRIPT" === e.tagName && (!e.hasAttribute("type") || "text/javascript" === e.getAttribute("type"))
    }

    function wn(e, t) {
        return t && (t._containerAttrs = Mn(e)), ye(e) && (e = dt(e)), t && (t._asComponent && !t.template && (t.template = "<slot></slot>"), t.template && (t._content = me(e), e = _n(e, t))), Me(e) && (se(be("v-start", !0), e), e.appendChild(be("v-end", !0))), e
    }

    function _n(e, t) {
        var n = t.template,
            r = dt(n, !0);
        if (r) {
            var i = r.firstChild;
            if (!i) return r;
            var o = i.tagName && i.tagName.toLowerCase();
            return t.replace ? (document.body, r.childNodes.length > 1 || 1 !== i.nodeType || "component" === o || Oe(t, "components", o) || re(i, "is") || Oe(t, "elementDirectives", o) || i.hasAttribute("v-for") || i.hasAttribute("v-if") ? r : (t._replacerAttrs = Mn(i), En(e, i), i)) : (e.appendChild(r), e)
        }
    }

    function Mn(e) {
        if (1 === e.nodeType && e.hasAttributes()) return v(e.attributes)
    }

    function En(e, t) {
        for (var n, r, i = e.attributes, o = i.length; o--;) n = i[o].name, r = i[o].value, t.hasAttribute(n) || zo.test(n) ? "class" === n && !W(r) && (r = r.trim()) && r.split(/\s+/).forEach(function(e) {
            pe(t, e)
        }) : t.setAttribute(n, r)
    }

    function Tn(e, t) {
        if (t) {
            for (var n, r, i = e._slotContents = Object.create(null), o = 0, a = t.children.length; o < a; o++) n = t.children[o], (r = n.getAttribute("slot")) && (i[r] || (i[r] = [])).push(n);
            for (r in i) i[r] = Sn(i[r], t);
            if (t.hasChildNodes()) {
                var s = t.childNodes;
                if (1 === s.length && 3 === s[0].nodeType && !s[0].data.trim()) return;
                i.default = Sn(t.childNodes, t)
            }
        }
    }

    function Sn(e, t) {
        var n = document.createDocumentFragment();
        e = v(e);
        for (var r = 0, i = e.length; r < i; r++) {
            var o = e[r];
            !ye(o) || o.hasAttribute("v-if") || o.hasAttribute("v-for") || (t.removeChild(o), o = dt(o, !0)), n.appendChild(o)
        }
        return n
    }

    function An() {}

    function Pn(e, t, n, r, i, o) {
        this.vm = t, this.el = n, this.descriptor = e, this.name = e.name, this.expression = e.expression, this.arg = e.arg, this.modifiers = e.modifiers, this.filters = e.filters, this.literal = this.modifiers && this.modifiers.literal, this._locked = !1, this._bound = !1, this._listeners = null, this._host = r, this._scope = i, this._frag = o
    }

    function Cn(e) {
        this._init(e)
    }

    function Ln(e, t, n) {
        return n = n ? parseInt(n, 10) : 0, t = l(t), "number" == typeof t ? e.slice(n, n + t) : e
    }

    function Rn(e, t, n) {
        if (e = Xo(e), null == t) return e;
        if ("function" == typeof t) return e.filter(t);
        t = ("" + t).toLowerCase();
        for (var r, i, o, a, s = "in" === n ? 3 : 2, c = Array.prototype.concat.apply([], v(arguments, s)), l = [], h = 0, u = e.length; h < u; h++)
            if (r = e[h], o = r && r.$value || r, a = c.length) {
                for (; a--;)
                    if ("$key" === (i = c[a]) && On(r.$key, t) || On(We(o, i), t)) {
                        l.push(r);
                        break
                    }
            } else On(r, t) && l.push(r);
        return l
    }

    function In(e) {
        function t(e, t, n) {
            var i = r[n];
            return i && ("$key" !== i && (b(e) && "$value" in e && (e = e.$value), b(t) && "$value" in t && (t = t.$value)), e = b(e) ? We(e, i) : e, t = b(t) ? We(t, i) : t), e === t ? 0 : e > t ? o : -o
        }
        var n = null,
            r = void 0;
        e = Xo(e);
        var i = v(arguments, 1),
            o = i[i.length - 1];
        "number" == typeof o ? (o = o < 0 ? -1 : 1, i = i.length > 1 ? i.slice(0, -1) : i) : o = 1;
        var a = i[0];
        return a ? ("function" == typeof a ? n = function(e, t) {
            return a(e, t) * o
        } : (r = Array.prototype.concat.apply([], i), n = function(e, i, o) {
            return o = o || 0, o >= r.length - 1 ? t(e, i, o) : t(e, i, o) || n(e, i, o + 1)
        }), e.slice().sort(n)) : e
    }

    function On(e, t) {
        var n;
        if (x(e)) {
            var r = Object.keys(e);
            for (n = r.length; n--;)
                if (On(e[r[n]], t)) return !0
        } else if (jn(e)) {
            for (n = e.length; n--;)
                if (On(e[n], t)) return !0
        } else if (null != e) return e.toString().toLowerCase().indexOf(t) > -1
    }
    var kn = Object.prototype.hasOwnProperty,
        Dn = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/,
        Nn = /-(\w)/g,
        Bn = /([^-])([A-Z])/g,
        Un = /(?:^|[-_\/])(\w)/g,
        Fn = Object.prototype.toString,
        zn = "[object Object]",
        jn = Array.isArray,
        Hn = "__proto__" in {},
        Vn = "undefined" != typeof window && "[object Object]" !== Object.prototype.toString.call(window),
        Gn = Vn && window.__VUE_DEVTOOLS_GLOBAL_HOOK__,
        Wn = Vn && window.navigator.userAgent.toLowerCase(),
        $n = Wn && Wn.indexOf("trident") > 0,
        Xn = Wn && Wn.indexOf("msie 9.0") > 0,
        qn = Wn && Wn.indexOf("android") > 0,
        Yn = Wn && /iphone|ipad|ipod|ios/.test(Wn),
        Zn = void 0,
        Jn = void 0,
        Kn = void 0,
        Qn = void 0;
    if (Vn && !Xn) {
        var er = void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend,
            tr = void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend;
        Zn = er ? "WebkitTransition" : "transition", Jn = er ? "webkitTransitionEnd" : "transitionend", Kn = tr ? "WebkitAnimation" : "animation", Qn = tr ? "webkitAnimationEnd" : "animationend"
    }
    var nr = function() {
            function e() {
                n = !1;
                var e = t.slice(0);
                t.length = 0;
                for (var r = 0; r < e.length; r++) e[r]()
            }
            var t = [],
                n = !1,
                r = void 0;
            if ("undefined" != typeof Promise && S(Promise)) {
                var i = Promise.resolve(),
                    o = function() {};
                r = function() {
                    i.then(e), Yn && setTimeout(o)
                }
            } else if ("undefined" != typeof MutationObserver) {
                var a = 1,
                    s = new MutationObserver(e),
                    c = document.createTextNode(String(a));
                s.observe(c, {
                    characterData: !0
                }), r = function() {
                    a = (a + 1) % 2, c.data = String(a)
                }
            } else r = setTimeout;
            return function(i, o) {
                var a = o ? function() {
                    i.call(o)
                } : i;
                t.push(a), n || (n = !0, r(e, 0))
            }
        }(),
        rr = void 0;
    "undefined" != typeof Set && S(Set) ? rr = Set : (rr = function() {
        this.set = Object.create(null)
    }, rr.prototype.has = function(e) {
        return void 0 !== this.set[e]
    }, rr.prototype.add = function(e) {
        this.set[e] = 1
    }, rr.prototype.clear = function() {
        this.set = Object.create(null)
    });
    var ir = A.prototype;
    ir.put = function(e, t) {
        var n, r = this.get(e, !0);
        return r || (this.size === this.limit && (n = this.shift()), r = {
            key: e
        }, this._keymap[e] = r, this.tail ? (this.tail.newer = r, r.older = this.tail) : this.head = r, this.tail = r, this.size++), r.value = t, n
    }, ir.shift = function() {
        var e = this.head;
        return e && (this.head = this.head.newer, this.head.older = void 0, e.newer = e.older = void 0, this._keymap[e.key] = void 0, this.size--), e
    }, ir.get = function(e, t) {
        var n = this._keymap[e];
        if (void 0 !== n) return n === this.tail ? t ? n : n.value : (n.newer && (n === this.head && (this.head = n.newer), n.newer.older = n.older), n.older && (n.older.newer = n.newer), n.newer = void 0, n.older = this.tail, this.tail && (this.tail.newer = n), this.tail = n, t ? n : n.value)
    };
    var or, ar, sr, cr, lr, hr, ur = new A(1e3),
        dr = /^in$|^-?\d+/,
        pr = 0,
        fr = 1,
        mr = 2,
        gr = 3,
        vr = 34,
        yr = 39,
        br = 124,
        xr = 92,
        wr = 32,
        _r = {
            91: 1,
            123: 1,
            40: 1
        },
        Mr = {
            91: 93,
            123: 125,
            40: 41
        },
        Er = Object.freeze({
            parseDirective: H
        }),
        Tr = /[-.*+?^${}()|[\]\/\\]/g,
        Sr = void 0,
        Ar = void 0,
        Pr = void 0,
        Cr = /[^|]\|[^|]/,
        Lr = Object.freeze({
            compileRegex: G,
            parseText: W,
            tokensToExp: $
        }),
        Rr = ["{{", "}}"],
        Ir = ["{{{", "}}}"],
        Or = Object.defineProperties({
            debug: !1,
            silent: !1,
            async: !0,
            warnExpressionErrors: !0,
            devtools: !1,
            _delimitersChanged: !0,
            _assetTypes: ["component", "directive", "elementDirective", "filter", "transition", "partial"],
            _propBindingModes: {
                ONE_WAY: 0,
                TWO_WAY: 1,
                ONE_TIME: 2
            },
            _maxUpdateCount: 100
        }, {
            delimiters: {
                get: function() {
                    return Rr
                },
                set: function(e) {
                    Rr = e, G()
                },
                configurable: !0,
                enumerable: !0
            },
            unsafeDelimiters: {
                get: function() {
                    return Ir
                },
                set: function(e) {
                    Ir = e, G()
                },
                configurable: !0,
                enumerable: !0
            }
        }),
        kr = void 0,
        Dr = Object.freeze({
            appendWithTransition: Y,
            beforeWithTransition: Z,
            removeWithTransition: J,
            applyTransition: K
        }),
        Nr = /^v-ref:/,
        Br = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i,
        Ur = /^(slot|partial|component)$/i,
        Fr = Or.optionMergeStrategies = Object.create(null);
    Fr.data = function(e, t, n) {
        return n ? e || t ? function() {
            var r = "function" == typeof t ? t.call(n) : t,
                i = "function" == typeof e ? e.call(n) : void 0;
            return r ? Ae(r, i) : i
        } : void 0 : t ? "function" != typeof t ? e : e ? function() {
            return Ae(t.call(this), e.call(this))
        } : t : e
    }, Fr.el = function(e, t, n) {
        if (n || !t || "function" == typeof t) {
            var r = t || e;
            return n && "function" == typeof r ? r.call(n) : r
        }
    }, Fr.init = Fr.created = Fr.ready = Fr.attached = Fr.detached = Fr.beforeCompile = Fr.compiled = Fr.beforeDestroy = Fr.destroyed = Fr.activate = function(e, t) {
        return t ? e ? e.concat(t) : jn(t) ? t : [t] : e
    }, Or._assetTypes.forEach(function(e) {
        Fr[e + "s"] = Pe
    }), Fr.watch = Fr.events = function(e, t) {
        if (!t) return e;
        if (!e) return t;
        var n = {};
        y(n, e);
        for (var r in t) {
            var i = n[r],
                o = t[r];
            i && !jn(i) && (i = [i]), n[r] = i ? i.concat(o) : [o]
        }
        return n
    }, Fr.props = Fr.methods = Fr.computed = function(e, t) {
        if (!t) return e;
        if (!e) return t;
        var n = Object.create(null);
        return y(n, e), y(n, t), n
    };
    var zr = function(e, t) {
            return void 0 === t ? e : t
        },
        jr = 0;
    ke.target = null, ke.prototype.addSub = function(e) {
        this.subs.push(e)
    }, ke.prototype.removeSub = function(e) {
        this.subs.$remove(e)
    }, ke.prototype.depend = function() {
        ke.target.addDep(this)
    }, ke.prototype.notify = function() {
        for (var e = v(this.subs), t = 0, n = e.length; t < n; t++) e[t].update()
    };
    var Hr = Array.prototype,
        Vr = Object.create(Hr);
    ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(e) {
        var t = Hr[e];
        w(Vr, e, function() {
            for (var n = arguments.length, r = new Array(n); n--;) r[n] = arguments[n];
            var i, o = t.apply(this, r),
                a = this.__ob__;
            switch (e) {
                case "push":
                case "unshift":
                    i = r;
                    break;
                case "splice":
                    i = r.slice(2)
            }
            return i && a.observeArray(i), a.dep.notify(), o
        })
    }), w(Hr, "$set", function(e, t) {
        return e >= this.length && (this.length = Number(e) + 1), this.splice(e, 1, t)[0]
    }), w(Hr, "$remove", function(e) {
        if (this.length) {
            var t = M(this, e);
            return t > -1 ? this.splice(t, 1) : void 0
        }
    });
    var Gr = Object.getOwnPropertyNames(Vr),
        Wr = !0;
    Ne.prototype.walk = function(e) {
        for (var t = Object.keys(e), n = 0, r = t.length; n < r; n++) this.convert(t[n], e[t[n]])
    }, Ne.prototype.observeArray = function(e) {
        for (var t = 0, n = e.length; t < n; t++) Fe(e[t])
    }, Ne.prototype.convert = function(e, t) {
        ze(this.value, e, t)
    }, Ne.prototype.addVm = function(e) {
        (this.vms || (this.vms = [])).push(e)
    }, Ne.prototype.removeVm = function(e) {
        this.vms.$remove(e)
    };
    var $r = Object.freeze({
            defineReactive: ze,
            set: r,
            del: i,
            hasOwn: o,
            isLiteral: a,
            isReserved: s,
            _toString: c,
            toNumber: l,
            toBoolean: h,
            stripQuotes: u,
            camelize: d,
            hyphenate: f,
            classify: m,
            bind: g,
            toArray: v,
            extend: y,
            isObject: b,
            isPlainObject: x,
            def: w,
            debounce: _,
            indexOf: M,
            cancellable: E,
            looseEqual: T,
            isArray: jn,
            hasProto: Hn,
            inBrowser: Vn,
            devtools: Gn,
            isIE: $n,
            isIE9: Xn,
            isAndroid: qn,
            isIOS: Yn,
            get transitionProp() {
                return Zn
            },
            get transitionEndEvent() {
                return Jn
            },
            get animationProp() {
                return Kn
            },
            get animationEndEvent() {
                return Qn
            },
            nextTick: nr,
            get _Set() {
                return rr
            },
            query: Q,
            inDoc: ee,
            getAttr: te,
            getBindAttr: ne,
            hasBindAttr: re,
            before: ie,
            after: oe,
            remove: ae,
            prepend: se,
            replace: ce,
            on: le,
            off: he,
            setClass: de,
            addClass: pe,
            removeClass: fe,
            extractContent: me,
            trimNode: ge,
            isTemplate: ye,
            createAnchor: be,
            findRef: xe,
            mapNodeRange: we,
            removeNodeRange: _e,
            isFragment: Me,
            getOuterHTML: Ee,
            mergeOptions: Ie,
            resolveAsset: Oe,
            checkComponentAttr: Te,
            commonTagRE: Br,
            reservedTagRE: Ur,
            get warn() {
                return kr
            }
        }),
        Xr = 0,
        qr = new A(1e3),
        Yr = 0,
        Zr = 1,
        Jr = 2,
        Kr = 3,
        Qr = 0,
        ei = 4,
        ti = 5,
        ni = 6,
        ri = 7,
        ii = 8,
        oi = [];
    oi[Qr] = {
        ws: [Qr],
        ident: [3, Yr],
        "[": [ei],
        eof: [ri]
    }, oi[1] = {
        ws: [1],
        ".": [2],
        "[": [ei],
        eof: [ri]
    }, oi[2] = {
        ws: [2],
        ident: [3, Yr]
    }, oi[3] = {
        ident: [3, Yr],
        0: [3, Yr],
        number: [3, Yr],
        ws: [1, Zr],
        ".": [2, Zr],
        "[": [ei, Zr],
        eof: [ri, Zr]
    }, oi[ei] = {
        "'": [ti, Yr],
        '"': [ni, Yr],
        "[": [ei, Jr],
        "]": [1, Kr],
        eof: ii,
        else: [ei, Yr]
    }, oi[ti] = {
        "'": [ei, Yr],
        eof: ii,
        else: [ti, Yr]
    }, oi[ni] = {
        '"': [ei, Yr],
        eof: ii,
        else: [ni, Yr]
    };
    var ai = Object.freeze({
            parsePath: Ge,
            getPath: We,
            setPath: $e
        }),
        si = new A(1e3),
        ci = "Math,Date,this,true,false,null,undefined,Infinity,NaN,isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,parseInt,parseFloat",
        li = new RegExp("^(" + ci.replace(/,/g, "\\b|") + "\\b)"),
        hi = "break,case,class,catch,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,return,super,switch,throw,try,var,while,with,yield,enum,await,implements,package,protected,static,interface,private,public",
        ui = new RegExp("^(" + hi.replace(/,/g, "\\b|") + "\\b)"),
        di = /\s/g,
        pi = /\n/g,
        fi = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\"']|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g,
        mi = /"(\d+)"/g,
        gi = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/,
        vi = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g,
        yi = /^(?:true|false|null|undefined|Infinity|NaN)$/,
        bi = [],
        xi = Object.freeze({
            parseExpression: et,
            isSimplePath: tt
        }),
        wi = [],
        _i = [],
        Mi = {},
        Ei = {},
        Ti = !1,
        Si = 0;
    at.prototype.get = function() {
        this.beforeGet();
        var e, t = this.scope || this.vm;
        try {
            e = this.getter.call(t, t)
        } catch (e) {}
        return this.deep && st(e), this.preProcess && (e = this.preProcess(e)), this.filters && (e = t._applyFilters(e, null, this.filters, !1)), this.postProcess && (e = this.postProcess(e)), this.afterGet(), e
    }, at.prototype.set = function(e) {
        var t = this.scope || this.vm;
        this.filters && (e = t._applyFilters(e, this.value, this.filters, !0));
        try {
            this.setter.call(t, t, e)
        } catch (e) {}
        var n = t.$forContext;
        if (n && n.alias === this.expression) {
            if (n.filters) return;
            n._withLock(function() {
                t.$key ? n.rawValue[t.$key] = e : n.rawValue.$set(t.$index, e)
            })
        }
    }, at.prototype.beforeGet = function() {
        ke.target = this
    }, at.prototype.addDep = function(e) {
        var t = e.id;
        this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this))
    }, at.prototype.afterGet = function() {
        ke.target = null;
        for (var e = this.deps.length; e--;) {
            var t = this.deps[e];
            this.newDepIds.has(t.id) || t.removeSub(this)
        }
        var n = this.depIds;
        this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0
    }, at.prototype.update = function(e) {
        this.lazy ? this.dirty = !0 : this.sync || !Or.async ? this.run() : (this.shallow = this.queued ? !!e && this.shallow : !!e, this.queued = !0, ot(this))
    }, at.prototype.run = function() {
        if (this.active) {
            var e = this.get();
            if (e !== this.value || (b(e) || this.deep) && !this.shallow) {
                var t = this.value;
                this.value = e;
                this.prevError;
                this.cb.call(this.vm, e, t)
            }
            this.queued = this.shallow = !1
        }
    }, at.prototype.evaluate = function() {
        var e = ke.target;
        this.value = this.get(), this.dirty = !1, ke.target = e
    }, at.prototype.depend = function() {
        for (var e = this.deps.length; e--;) this.deps[e].depend()
    }, at.prototype.teardown = function() {
        if (this.active) {
            this.vm._isBeingDestroyed || this.vm._vForRemoving || this.vm._watchers.$remove(this);
            for (var e = this.deps.length; e--;) this.deps[e].removeSub(this);
            this.active = !1, this.vm = this.cb = this.value = null
        }
    };
    var Ai = new rr,
        Pi = {
            bind: function() {
                this.attr = 3 === this.el.nodeType ? "data" : "textContent"
            },
            update: function(e) {
                this.el[this.attr] = c(e)
            }
        },
        Ci = new A(1e3),
        Li = new A(1e3),
        Ri = {
            efault: [0, "", ""],
            legend: [1, "<fieldset>", "</fieldset>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"]
        };
    Ri.td = Ri.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"], Ri.option = Ri.optgroup = [1, '<select multiple="multiple">', "</select>"], Ri.thead = Ri.tbody = Ri.colgroup = Ri.caption = Ri.tfoot = [1, "<table>", "</table>"], Ri.g = Ri.defs = Ri.symbol = Ri.use = Ri.image = Ri.text = Ri.circle = Ri.ellipse = Ri.line = Ri.path = Ri.polygon = Ri.polyline = Ri.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"version="1.1">', "</svg>"];
    var Ii = /<([\w:-]+)/,
        Oi = /&#?\w+?;/,
        ki = /<!--/,
        Di = function() {
            if (Vn) {
                var e = document.createElement("div");
                return e.innerHTML = "<template>1</template>", !e.cloneNode(!0).firstChild.innerHTML
            }
            return !1
        }(),
        Ni = function() {
            if (Vn) {
                var e = document.createElement("textarea");
                return e.placeholder = "t", "t" === e.cloneNode(!0).value
            }
            return !1
        }(),
        Bi = Object.freeze({
            cloneNode: ut,
            parseTemplate: dt
        }),
        Ui = {
            bind: function() {
                8 === this.el.nodeType && (this.nodes = [], this.anchor = be("v-html"), ce(this.el, this.anchor))
            },
            update: function(e) {
                e = c(e), this.nodes ? this.swap(e) : this.el.innerHTML = e
            },
            swap: function(e) {
                for (var t = this.nodes.length; t--;) ae(this.nodes[t]);
                var n = dt(e, !0, !0);
                this.nodes = v(n.childNodes), ie(n, this.anchor)
            }
        };
    pt.prototype.callHook = function(e) {
        var t, n;
        for (t = 0, n = this.childFrags.length; t < n; t++) this.childFrags[t].callHook(e);
        for (t = 0, n = this.children.length; t < n; t++) e(this.children[t])
    }, pt.prototype.beforeRemove = function() {
        var e, t;
        for (e = 0, t = this.childFrags.length; e < t; e++) this.childFrags[e].beforeRemove(!1);
        for (e = 0, t = this.children.length; e < t; e++) this.children[e].$destroy(!1, !0);
        var n = this.unlink.dirs;
        for (e = 0, t = n.length; e < t; e++) n[e]._watcher && n[e]._watcher.teardown()
    }, pt.prototype.destroy = function() {
        this.parentFrag && this.parentFrag.childFrags.$remove(this), this.node.__v_frag = null, this.unlink()
    };
    var Fi = new A(5e3);
    xt.prototype.create = function(e, t, n) {
        var r = ut(this.template);
        return new pt(this.linker, this.vm, r, e, t, n)
    };
    var zi = 0,
        ji = {
            priority: 2200,
            terminal: !0,
            params: ["track-by", "stagger", "enter-stagger", "leave-stagger"],
            bind: function() {
                var e = this.expression.match(/(.*) (?:in|of) (.*)/);
                if (e) {
                    var t = e[1].match(/\((.*),(.*)\)/);
                    t ? (this.iterator = t[1].trim(), this.alias = t[2].trim()) : this.alias = e[1].trim(), this.expression = e[2]
                }
                if (this.alias) {
                    this.id = "__v-for__" + ++zi;
                    var n = this.el.tagName;
                    this.isOption = ("OPTION" === n || "OPTGROUP" === n) && "SELECT" === this.el.parentNode.tagName, this.start = be("v-for-start"), this.end = be("v-for-end"), ce(this.el, this.end), ie(this.start, this.end), this.cache = Object.create(null), this.factory = new xt(this.vm, this.el)
                }
            },
            update: function(e) {
                this.diff(e), this.updateRef(), this.updateModel()
            },
            diff: function(e) {
                var t, n, r, i, a, s, c = e[0],
                    l = this.fromObject = b(c) && o(c, "$key") && o(c, "$value"),
                    h = this.params.trackBy,
                    u = this.frags,
                    d = this.frags = new Array(e.length),
                    p = this.alias,
                    f = this.iterator,
                    m = this.start,
                    g = this.end,
                    v = ee(m),
                    y = !u;
                for (t = 0, n = e.length; t < n; t++) c = e[t], i = l ? c.$key : null, a = l ? c.$value : c, s = !b(a), r = !y && this.getCachedFrag(a, t, i), r ? (r.reused = !0, r.scope.$index = t, i && (r.scope.$key = i), f && (r.scope[f] = null !== i ? i : t), (h || l || s) && De(function() {
                    r.scope[p] = a
                })) : (r = this.create(a, p, t, i), r.fresh = !y), d[t] = r, y && r.before(g);
                if (!y) {
                    var x = 0,
                        w = u.length - d.length;
                    for (this.vm._vForRemoving = !0, t = 0, n = u.length; t < n; t++) r = u[t], r.reused || (this.deleteCachedFrag(r), this.remove(r, x++, w, v));
                    this.vm._vForRemoving = !1, x && (this.vm._watchers = this.vm._watchers.filter(function(e) {
                        return e.active
                    }));
                    var _, M, E, T = 0;
                    for (t = 0, n = d.length; t < n; t++) r = d[t], _ = d[t - 1], M = _ ? _.staggerCb ? _.staggerAnchor : _.end || _.node : m, r.reused && !r.staggerCb ? (E = wt(r, m, this.id)) === _ || E && wt(E, m, this.id) === _ || this.move(r, M) : this.insert(r, T++, M, v), r.reused = r.fresh = !1
                }
            },
            create: function(e, t, n, r) {
                var i = this._host,
                    o = this._scope || this.vm,
                    a = Object.create(o);
                a.$refs = Object.create(o.$refs), a.$els = Object.create(o.$els), a.$parent = o, a.$forContext = this, De(function() {
                    ze(a, t, e)
                }), ze(a, "$index", n), r ? ze(a, "$key", r) : a.$key && w(a, "$key", null), this.iterator && ze(a, this.iterator, null !== r ? r : n);
                var s = this.factory.create(i, a, this._frag);
                return s.forId = this.id, this.cacheFrag(e, s, n, r), s
            },
            updateRef: function() {
                var e = this.descriptor.ref;
                if (e) {
                    var t, n = (this._scope || this.vm).$refs;
                    this.fromObject ? (t = {}, this.frags.forEach(function(e) {
                        t[e.scope.$key] = Et(e)
                    })) : t = this.frags.map(Et), n[e] = t
                }
            },
            updateModel: function() {
                if (this.isOption) {
                    var e = this.start.parentNode,
                        t = e && e.__v_model;
                    t && t.forceUpdate()
                }
            },
            insert: function(e, t, n, r) {
                e.staggerCb && (e.staggerCb.cancel(), e.staggerCb = null);
                var i = this.getStagger(e, t, null, "enter");
                if (r && i) {
                    var o = e.staggerAnchor;
                    o || (o = e.staggerAnchor = be("stagger-anchor"), o.__v_frag = e), oe(o, n);
                    var a = e.staggerCb = E(function() {
                        e.staggerCb = null, e.before(o), ae(o)
                    });
                    setTimeout(a, i)
                } else {
                    var s = n.nextSibling;
                    s || (oe(this.end, n), s = this.end), e.before(s)
                }
            },
            remove: function(e, t, n, r) {
                if (e.staggerCb) return e.staggerCb.cancel(), void(e.staggerCb = null);
                var i = this.getStagger(e, t, n, "leave");
                if (r && i) {
                    var o = e.staggerCb = E(function() {
                        e.staggerCb = null, e.remove()
                    });
                    setTimeout(o, i)
                } else e.remove()
            },
            move: function(e, t) {
                t.nextSibling || this.end.parentNode.appendChild(this.end), e.before(t.nextSibling, !1)
            },
            cacheFrag: function(e, t, n, r) {
                var i, a = this.params.trackBy,
                    s = this.cache,
                    c = !b(e);
                r || a || c ? (i = Mt(n, r, e, a), s[i] || (s[i] = t)) : (i = this.id, o(e, i) ? null === e[i] && (e[i] = t) : Object.isExtensible(e) && w(e, i, t)), t.raw = e
            },
            getCachedFrag: function(e, t, n) {
                var r, i = this.params.trackBy,
                    o = !b(e);
                if (n || i || o) {
                    var a = Mt(t, n, e, i);
                    r = this.cache[a]
                } else r = e[this.id];
                return r && (r.reused || r.fresh), r
            },
            deleteCachedFrag: function(e) {
                var t = e.raw,
                    n = this.params.trackBy,
                    r = e.scope,
                    i = r.$index,
                    a = o(r, "$key") && r.$key,
                    s = !b(t);
                if (n || a || s) {
                    var c = Mt(i, a, t, n);
                    this.cache[c] = null
                } else t[this.id] = null, e.raw = null
            },
            getStagger: function(e, t, n, r) {
                r += "Stagger";
                var i = e.node.__v_trans,
                    o = i && i.hooks,
                    a = o && (o[r] || o.stagger);
                return a ? a.call(e, t, n) : t * parseInt(this.params[r] || this.params.stagger, 10)
            },
            _preProcess: function(e) {
                return this.rawValue = e, e
            },
            _postProcess: function(e) {
                if (jn(e)) return e;
                if (x(e)) {
                    for (var t, n = Object.keys(e), r = n.length, i = new Array(r); r--;) t = n[r], i[r] = {
                        $key: t,
                        $value: e[t]
                    };
                    return i
                }
                return "number" != typeof e || isNaN(e) || (e = _t(e)), e || []
            },
            unbind: function() {
                if (this.descriptor.ref && ((this._scope || this.vm).$refs[this.descriptor.ref] = null), this.frags)
                    for (var e, t = this.frags.length; t--;) e = this.frags[t], this.deleteCachedFrag(e), e.destroy()
            }
        },
        Hi = {
            priority: 2100,
            terminal: !0,
            bind: function() {
                var e = this.el;
                if (e.__vue__) this.invalid = !0;
                else {
                    var t = e.nextElementSibling;
                    t && null !== te(t, "v-else") && (ae(t), this.elseEl = t), this.anchor = be("v-if"), ce(e, this.anchor)
                }
            },
            update: function(e) {
                this.invalid || (e ? this.frag || this.insert() : this.remove())
            },
            insert: function() {
                this.elseFrag && (this.elseFrag.remove(), this.elseFrag = null), this.factory || (this.factory = new xt(this.vm, this.el)), this.frag = this.factory.create(this._host, this._scope, this._frag), this.frag.before(this.anchor)
            },
            remove: function() {
                this.frag && (this.frag.remove(), this.frag = null), this.elseEl && !this.elseFrag && (this.elseFactory || (this.elseFactory = new xt(this.elseEl._context || this.vm, this.elseEl)), this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag), this.elseFrag.before(this.anchor))
            },
            unbind: function() {
                this.frag && this.frag.destroy(), this.elseFrag && this.elseFrag.destroy()
            }
        },
        Vi = {
            bind: function() {
                var e = this.el.nextElementSibling;
                e && null !== te(e, "v-else") && (this.elseEl = e)
            },
            update: function(e) {
                this.apply(this.el, e), this.elseEl && this.apply(this.elseEl, !e)
            },
            apply: function(e, t) {
                function n() {
                    e.style.display = t ? "" : "none"
                }
                ee(e) ? K(e, t ? 1 : -1, n, this.vm) : n()
            }
        },
        Gi = {
            bind: function() {
                var e = this,
                    t = this.el,
                    n = "range" === t.type,
                    r = this.params.lazy,
                    i = this.params.number,
                    o = this.params.debounce,
                    a = !1;
                if (qn || n || (this.on("compositionstart", function() {
                        a = !0
                    }), this.on("compositionend", function() {
                        a = !1, r || e.listener()
                    })), this.focused = !1, n || r || (this.on("focus", function() {
                        e.focused = !0
                    }), this.on("blur", function() {
                        e.focused = !1, e._frag && !e._frag.inserted || e.rawListener()
                    })), this.listener = this.rawListener = function() {
                        if (!a && e._bound) {
                            var r = i || n ? l(t.value) : t.value;
                            e.set(r), nr(function() {
                                e._bound && !e.focused && e.update(e._watcher.value)
                            })
                        }
                    }, o && (this.listener = _(this.listener, o)), this.hasjQuery = "function" == typeof jQuery, this.hasjQuery) {
                    var s = jQuery.fn.on ? "on" : "bind";
                    jQuery(t)[s]("change", this.rawListener), r || jQuery(t)[s]("input", this.listener)
                } else this.on("change", this.rawListener), r || this.on("input", this.listener);
                !r && Xn && (this.on("cut", function() {
                    nr(e.listener)
                }), this.on("keyup", function(t) {
                    46 !== t.keyCode && 8 !== t.keyCode || e.listener()
                })), (t.hasAttribute("value") || "TEXTAREA" === t.tagName && t.value.trim()) && (this.afterBind = this.listener)
            },
            update: function(e) {
                (e = c(e)) !== this.el.value && (this.el.value = e)
            },
            unbind: function() {
                var e = this.el;
                if (this.hasjQuery) {
                    var t = jQuery.fn.off ? "off" : "unbind";
                    jQuery(e)[t]("change", this.listener), jQuery(e)[t]("input", this.listener)
                }
            }
        },
        Wi = {
            bind: function() {
                var e = this,
                    t = this.el;
                this.getValue = function() {
                    if (t.hasOwnProperty("_value")) return t._value;
                    var n = t.value;
                    return e.params.number && (n = l(n)), n
                }, this.listener = function() {
                    e.set(e.getValue())
                }, this.on("change", this.listener), t.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(e) {
                this.el.checked = T(e, this.getValue())
            }
        },
        $i = {
            bind: function() {
                var e = this,
                    t = this,
                    n = this.el;
                this.forceUpdate = function() {
                    t._watcher && t.update(t._watcher.get())
                };
                var r = this.multiple = n.hasAttribute("multiple");
                this.listener = function() {
                    var e = Tt(n, r);
                    e = t.params.number ? jn(e) ? e.map(l) : l(e) : e, t.set(e)
                }, this.on("change", this.listener);
                var i = Tt(n, r, !0);
                (r && i.length || !r && null !== i) && (this.afterBind = this.listener), this.vm.$on("hook:attached", function() {
                    nr(e.forceUpdate)
                }), ee(n) || nr(this.forceUpdate)
            },
            update: function(e) {
                var t = this.el;
                t.selectedIndex = -1;
                for (var n, r, i = this.multiple && jn(e), o = t.options, a = o.length; a--;) n = o[a], r = n.hasOwnProperty("_value") ? n._value : n.value, n.selected = i ? St(e, r) > -1 : T(e, r)
            },
            unbind: function() {
                this.vm.$off("hook:attached", this.forceUpdate)
            }
        },
        Xi = {
            bind: function() {
                function e() {
                    var e = n.checked;
                    return e && n.hasOwnProperty("_trueValue") ? n._trueValue : !e && n.hasOwnProperty("_falseValue") ? n._falseValue : e
                }
                var t = this,
                    n = this.el;
                this.getValue = function() {
                    return n.hasOwnProperty("_value") ? n._value : t.params.number ? l(n.value) : n.value
                }, this.listener = function() {
                    var r = t._watcher.get();
                    if (jn(r)) {
                        var i = t.getValue(),
                            o = M(r, i);
                        n.checked ? o < 0 && t.set(r.concat(i)) : o > -1 && t.set(r.slice(0, o).concat(r.slice(o + 1)))
                    } else t.set(e())
                }, this.on("change", this.listener), n.hasAttribute("checked") && (this.afterBind = this.listener)
            },
            update: function(e) {
                var t = this.el;
                jn(e) ? t.checked = M(e, this.getValue()) > -1 : t.hasOwnProperty("_trueValue") ? t.checked = T(e, t._trueValue) : t.checked = !!e
            }
        },
        qi = {
            text: Gi,
            radio: Wi,
            select: $i,
            checkbox: Xi
        },
        Yi = {
            priority: 800,
            twoWay: !0,
            handlers: qi,
            params: ["lazy", "number", "debounce"],
            bind: function() {
                this.checkFilters(), this.hasRead && this.hasWrite;
                var e, t = this.el,
                    n = t.tagName;
                if ("INPUT" === n) e = qi[t.type] || qi.text;
                else if ("SELECT" === n) e = qi.select;
                else {
                    if ("TEXTAREA" !== n) return;
                    e = qi.text
                }
                t.__v_model = this, e.bind.call(this), this.update = e.update, this._unbind = e.unbind
            },
            checkFilters: function() {
                var e = this.filters;
                if (e)
                    for (var t = e.length; t--;) {
                        var n = Oe(this.vm.$options, "filters", e[t].name);
                        ("function" == typeof n || n.read) && (this.hasRead = !0), n.write && (this.hasWrite = !0)
                    }
            },
            unbind: function() {
                this.el.__v_model = null, this._unbind && this._unbind()
            }
        },
        Zi = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            delete: [8, 46],
            up: 38,
            left: 37,
            right: 39,
            down: 40
        },
        Ji = {
            priority: 700,
            acceptStatement: !0,
            keyCodes: Zi,
            bind: function() {
                if ("IFRAME" === this.el.tagName && "load" !== this.arg) {
                    var e = this;
                    this.iframeBind = function() {
                        le(e.el.contentWindow, e.arg, e.handler, e.modifiers.capture)
                    }, this.on("load", this.iframeBind)
                }
            },
            update: function(e) {
                if (this.descriptor.raw || (e = function() {}), "function" == typeof e) {
                    this.modifiers.stop && (e = Pt(e)), this.modifiers.prevent && (e = Ct(e)), this.modifiers.self && (e = Lt(e));
                    var t = Object.keys(this.modifiers).filter(function(e) {
                        return "stop" !== e && "prevent" !== e && "self" !== e && "capture" !== e
                    });
                    t.length && (e = At(e, t)), this.reset(), this.handler = e, this.iframeBind ? this.iframeBind() : le(this.el, this.arg, this.handler, this.modifiers.capture)
                }
            },
            reset: function() {
                var e = this.iframeBind ? this.el.contentWindow : this.el;
                this.handler && he(e, this.arg, this.handler)
            },
            unbind: function() {
                this.reset()
            }
        },
        Ki = ["-webkit-", "-moz-", "-ms-"],
        Qi = ["Webkit", "Moz", "ms"],
        eo = /!important;?$/,
        to = Object.create(null),
        no = null,
        ro = {
            deep: !0,
            update: function(e) {
                "string" == typeof e ? this.el.style.cssText = e : jn(e) ? this.handleObject(e.reduce(y, {})) : this.handleObject(e || {})
            },
            handleObject: function(e) {
                var t, n, r = this.cache || (this.cache = {});
                for (t in r) t in e || (this.handleSingle(t, null), delete r[t]);
                for (t in e)(n = e[t]) !== r[t] && (r[t] = n, this.handleSingle(t, n))
            },
            handleSingle: function(e, t) {
                if (e = Rt(e))
                    if (null != t && (t += ""), t) {
                        var n = eo.test(t) ? "important" : "";
                        n ? (t = t.replace(eo, "").trim(), this.el.style.setProperty(e.kebab, t, n)) : this.el.style[e.camel] = t
                    } else this.el.style[e.camel] = ""
            }
        },
        io = /^xlink:/,
        oo = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/,
        ao = /^(?:value|checked|selected|muted)$/,
        so = /^(?:draggable|contenteditable|spellcheck)$/,
        co = {
            value: "_value",
            "true-value": "_trueValue",
            "false-value": "_falseValue"
        },
        lo = {
            priority: 850,
            bind: function() {
                var e = this.arg,
                    t = this.el.tagName;
                e || (this.deep = !0);
                var n = this.descriptor,
                    r = n.interp;
                if (r) {
                    n.hasOneTime && (this.expression = $(r, this._scope || this.vm)), (oo.test(e) || "name" === e && ("PARTIAL" === t || "SLOT" === t)) && (this.el.removeAttribute(e), this.invalid = !0)
                }
            },
            update: function(e) {
                if (!this.invalid) {
                    var t = this.arg;
                    this.arg ? this.handleSingle(t, e) : this.handleObject(e || {})
                }
            },
            handleObject: ro.handleObject,
            handleSingle: function(e, t) {
                var n = this.el,
                    r = this.descriptor.interp;
                if (this.modifiers.camel && (e = d(e)), !r && ao.test(e) && e in n) {
                    var i = "value" === e && null == t ? "" : t;
                    n[e] !== i && (n[e] = i)
                }
                var o = co[e];
                if (!r && o) {
                    n[o] = t;
                    var a = n.__v_model;
                    a && a.listener()
                }
                if ("value" === e && "TEXTAREA" === n.tagName) return void n.removeAttribute(e);
                so.test(e) ? n.setAttribute(e, t ? "true" : "false") : null != t && !1 !== t ? "class" === e ? (n.__v_trans && (t += " " + n.__v_trans.id + "-transition"), de(n, t)) : io.test(e) ? n.setAttributeNS("http://www.w3.org/1999/xlink", e, !0 === t ? "" : t) : n.setAttribute(e, !0 === t ? "" : t) : n.removeAttribute(e)
            }
        },
        ho = {
            priority: 1500,
            bind: function() {
                if (this.arg) {
                    var e = this.id = d(this.arg),
                        t = (this._scope || this.vm).$els;
                    o(t, e) ? t[e] = this.el : ze(t, e, this.el)
                }
            },
            unbind: function() {
                var e = (this._scope || this.vm).$els;
                e[this.id] === this.el && (e[this.id] = null)
            }
        },
        uo = {
            bind: function() {}
        },
        po = {
            bind: function() {
                var e = this.el;
                this.vm.$once("pre-hook:compiled", function() {
                    e.removeAttribute("v-cloak")
                })
            }
        },
        fo = {
            text: Pi,
            html: Ui,
            for: ji,
            if: Hi,
            show: Vi,
            model: Yi,
            on: Ji,
            bind: lo,
            el: ho,
            ref: uo,
            cloak: po
        },
        mo = {
            deep: !0,
            update: function(e) {
                e ? "string" == typeof e ? this.setClass(e.trim().split(/\s+/)) : this.setClass(Ot(e)) : this.cleanup()
            },
            setClass: function(e) {
                this.cleanup(e);
                for (var t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    r && kt(this.el, r, pe)
                }
                this.prevKeys = e
            },
            cleanup: function(e) {
                var t = this.prevKeys;
                if (t)
                    for (var n = t.length; n--;) {
                        var r = t[n];
                        (!e || e.indexOf(r) < 0) && kt(this.el, r, fe)
                    }
            }
        },
        go = {
            priority: 1500,
            params: ["keep-alive", "transition-mode", "inline-template"],
            bind: function() {
                this.el.__vue__ || (this.keepAlive = this.params.keepAlive, this.keepAlive && (this.cache = {}), this.params.inlineTemplate && (this.inlineTemplate = me(this.el, !0)), this.pendingComponentCb = this.Component = null, this.pendingRemovals = 0, this.pendingRemovalCb = null, this.anchor = be("v-component"), ce(this.el, this.anchor), this.el.removeAttribute("is"), this.el.removeAttribute(":is"), this.descriptor.ref && this.el.removeAttribute("v-ref:" + f(this.descriptor.ref)), this.literal && this.setComponent(this.expression))
            },
            update: function(e) {
                this.literal || this.setComponent(e)
            },
            setComponent: function(e, t) {
                if (this.invalidatePending(), e) {
                    var n = this;
                    this.resolveComponent(e, function() {
                        n.mountComponent(t)
                    })
                } else this.unbuild(!0), this.remove(this.childVM, t), this.childVM = null
            },
            resolveComponent: function(e, t) {
                var n = this;
                this.pendingComponentCb = E(function(r) {
                    n.ComponentName = r.options.name || ("string" == typeof e ? e : null), n.Component = r, t()
                }), this.vm._resolveComponent(e, this.pendingComponentCb)
            },
            mountComponent: function(e) {
                this.unbuild(!0);
                var t = this,
                    n = this.Component.options.activate,
                    r = this.getCached(),
                    i = this.build();
                n && !r ? (this.waitingFor = i, Dt(n, i, function() {
                    t.waitingFor === i && (t.waitingFor = null, t.transition(i, e))
                })) : (r && i._updateRef(), this.transition(i, e))
            },
            invalidatePending: function() {
                this.pendingComponentCb && (this.pendingComponentCb.cancel(), this.pendingComponentCb = null)
            },
            build: function(e) {
                var t = this.getCached();
                if (t) return t;
                if (this.Component) {
                    var n = {
                        name: this.ComponentName,
                        el: ut(this.el),
                        template: this.inlineTemplate,
                        parent: this._host || this.vm,
                        _linkerCachable: !this.inlineTemplate,
                        _ref: this.descriptor.ref,
                        _asComponent: !0,
                        _isRouterView: this._isRouterView,
                        _context: this.vm,
                        _scope: this._scope,
                        _frag: this._frag
                    };
                    e && y(n, e);
                    var r = new this.Component(n);
                    return this.keepAlive && (this.cache[this.Component.cid] = r), r
                }
            },
            getCached: function() {
                return this.keepAlive && this.cache[this.Component.cid]
            },
            unbuild: function(e) {
                this.waitingFor && (this.keepAlive || this.waitingFor.$destroy(), this.waitingFor = null);
                var t = this.childVM;
                if (!t || this.keepAlive) return void(t && (t._inactive = !0, t._updateRef(!0)));
                t.$destroy(!1, e)
            },
            remove: function(e, t) {
                var n = this.keepAlive;
                if (e) {
                    this.pendingRemovals++, this.pendingRemovalCb = t;
                    var r = this;
                    e.$remove(function() {
                        r.pendingRemovals--, n || e._cleanup(), !r.pendingRemovals && r.pendingRemovalCb && (r.pendingRemovalCb(), r.pendingRemovalCb = null)
                    })
                } else t && t()
            },
            transition: function(e, t) {
                var n = this,
                    r = this.childVM;
                switch (r && (r._inactive = !0), e._inactive = !1, this.childVM = e, n.params.transitionMode) {
                    case "in-out":
                        e.$before(n.anchor, function() {
                            n.remove(r, t)
                        });
                        break;
                    case "out-in":
                        n.remove(r, function() {
                            e.$before(n.anchor, t)
                        });
                        break;
                    default:
                        n.remove(r), e.$before(n.anchor, t)
                }
            },
            unbind: function() {
                if (this.invalidatePending(), this.unbuild(), this.cache) {
                    for (var e in this.cache) this.cache[e].$destroy();
                    this.cache = null
                }
            }
        },
        vo = Or._propBindingModes,
        yo = {},
        bo = /^[$_a-zA-Z]+[\w$]*$/,
        xo = Or._propBindingModes,
        wo = {
            bind: function() {
                var e = this.vm,
                    t = e._context,
                    n = this.descriptor.prop,
                    r = n.path,
                    i = n.parentPath,
                    o = n.mode === xo.TWO_WAY,
                    a = this.parentWatcher = new at(t, i, function(t) {
                        zt(e, n, t)
                    }, {
                        twoWay: o,
                        filters: n.filters,
                        scope: this._scope
                    });
                if (Ft(e, n, a.value), o) {
                    var s = this;
                    e.$once("pre-hook:created", function() {
                        s.childWatcher = new at(e, r, function(e) {
                            a.set(e)
                        }, {
                            sync: !0
                        })
                    })
                }
            },
            unbind: function() {
                this.parentWatcher.teardown(), this.childWatcher && this.childWatcher.teardown()
            }
        },
        _o = [],
        Mo = !1,
        Eo = "transition",
        To = "animation",
        So = Zn + "Duration",
        Ao = Kn + "Duration",
        Po = Vn && window.requestAnimationFrame,
        Co = Po ? function(e) {
            Po(function() {
                Po(e)
            })
        } : function(e) {
            setTimeout(e, 50)
        },
        Lo = Xt.prototype;
    Lo.enter = function(e, t) {
        this.cancelPending(), this.callHook("beforeEnter"), this.cb = t, pe(this.el, this.enterClass), e(), this.entered = !1, this.callHookWithCb("enter"), this.entered || (this.cancel = this.hooks && this.hooks.enterCancelled, Wt(this.enterNextTick))
    }, Lo.enterNextTick = function() {
        var e = this;
        this.justEntered = !0, Co(function() {
            e.justEntered = !1
        });
        var t = this.enterDone,
            n = this.getCssTransitionType(this.enterClass);
        this.pendingJsCb ? n === Eo && fe(this.el, this.enterClass) : n === Eo ? (fe(this.el, this.enterClass), this.setupCssCb(Jn, t)) : n === To ? this.setupCssCb(Qn, t) : t()
    }, Lo.enterDone = function() {
        this.entered = !0, this.cancel = this.pendingJsCb = null, fe(this.el, this.enterClass), this.callHook("afterEnter"), this.cb && this.cb()
    }, Lo.leave = function(e, t) {
        this.cancelPending(), this.callHook("beforeLeave"), this.op = e, this.cb = t, pe(this.el, this.leaveClass), this.left = !1, this.callHookWithCb("leave"), this.left || (this.cancel = this.hooks && this.hooks.leaveCancelled, this.op && !this.pendingJsCb && (this.justEntered ? this.leaveDone() : Wt(this.leaveNextTick)))
    }, Lo.leaveNextTick = function() {
        var e = this.getCssTransitionType(this.leaveClass);
        if (e) {
            var t = e === Eo ? Jn : Qn;
            this.setupCssCb(t, this.leaveDone)
        } else this.leaveDone()
    }, Lo.leaveDone = function() {
        this.left = !0, this.cancel = this.pendingJsCb = null, this.op(), fe(this.el, this.leaveClass), this.callHook("afterLeave"), this.cb && this.cb(), this.op = null
    }, Lo.cancelPending = function() {
        this.op = this.cb = null;
        var e = !1;
        this.pendingCssCb && (e = !0, he(this.el, this.pendingCssEvent, this.pendingCssCb), this.pendingCssEvent = this.pendingCssCb = null), this.pendingJsCb && (e = !0, this.pendingJsCb.cancel(), this.pendingJsCb = null), e && (fe(this.el, this.enterClass), fe(this.el, this.leaveClass)), this.cancel && (this.cancel.call(this.vm, this.el), this.cancel = null)
    }, Lo.callHook = function(e) {
        this.hooks && this.hooks[e] && this.hooks[e].call(this.vm, this.el)
    }, Lo.callHookWithCb = function(e) {
        var t = this.hooks && this.hooks[e];
        t && (t.length > 1 && (this.pendingJsCb = E(this[e + "Done"])), t.call(this.vm, this.el, this.pendingJsCb))
    }, Lo.getCssTransitionType = function(e) {
        if (!(!Jn || document.hidden || this.hooks && !1 === this.hooks.css || qt(this.el))) {
            var t = this.type || this.typeCache[e];
            if (t) return t;
            var n = this.el.style,
                r = window.getComputedStyle(this.el),
                i = n[So] || r[So];
            if (i && "0s" !== i) t = Eo;
            else {
                var o = n[Ao] || r[Ao];
                o && "0s" !== o && (t = To)
            }
            return t && (this.typeCache[e] = t), t
        }
    }, Lo.setupCssCb = function(e, t) {
        this.pendingCssEvent = e;
        var n = this,
            r = this.el,
            i = this.pendingCssCb = function(o) {
                o.target === r && (he(r, e, i), n.pendingCssEvent = n.pendingCssCb = null, !n.pendingJsCb && t && t())
            };
        le(r, e, i)
    };
    var Ro = {
            priority: 1100,
            update: function(e, t) {
                var n = this.el,
                    r = Oe(this.vm.$options, "transitions", e);
                e = e || "v", t = t || "v", n.__v_trans = new Xt(n, e, r, this.vm), fe(n, t + "-transition"), pe(n, e + "-transition")
            }
        },
        Io = {
            style: ro,
            class: mo,
            component: go,
            prop: wo,
            transition: Ro
        },
        Oo = /^v-bind:|^:/,
        ko = /^v-on:|^@/,
        Do = /^v-([^:]+)(?:$|:(.*)$)/,
        No = /\.[^\.]+/g,
        Bo = /^(v-bind:|:)?transition$/,
        Uo = 1e3,
        Fo = 2e3;
    fn.terminal = !0;
    var zo = /[^\w\-:\.]/,
        jo = Object.freeze({
            compile: Yt,
            compileAndLinkProps: en,
            compileRoot: tn,
            transclude: wn,
            resolveSlots: Tn
        }),
        Ho = /^v-on:|^@/;
    Pn.prototype._bind = function() {
        var e = this.name,
            t = this.descriptor;
        if (("cloak" !== e || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
            var n = t.attr || "v-" + e;
            this.el.removeAttribute(n)
        }
        var r = t.def;
        if ("function" == typeof r ? this.update = r : y(this, r), this._setupParams(), this.bind && this.bind(), this._bound = !0, this.literal) this.update && this.update(t.raw);
        else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
            var i = this;
            this.update ? this._update = function(e, t) {
                i._locked || i.update(e, t)
            } : this._update = An;
            var o = this._preProcess ? g(this._preProcess, this) : null,
                a = this._postProcess ? g(this._postProcess, this) : null,
                s = this._watcher = new at(this.vm, this.expression, this._update, {
                    filters: this.filters,
                    twoWay: this.twoWay,
                    deep: this.deep,
                    preProcess: o,
                    postProcess: a,
                    scope: this._scope
                });
            this.afterBind ? this.afterBind() : this.update && this.update(s.value)
        }
    }, Pn.prototype._setupParams = function() {
        if (this.params) {
            var e = this.params;
            this.params = Object.create(null);
            for (var t, n, r, i = e.length; i--;) t = f(e[i]), r = d(t), n = ne(this.el, t), null != n ? this._setupParamWatcher(r, n) : null != (n = te(this.el, t)) && (this.params[r] = "" === n || n)
        }
    }, Pn.prototype._setupParamWatcher = function(e, t) {
        var n = this,
            r = !1,
            i = (this._scope || this.vm).$watch(t, function(t, i) {
                if (n.params[e] = t, r) {
                    var o = n.paramWatchers && n.paramWatchers[e];
                    o && o.call(n, t, i)
                } else r = !0
            }, {
                immediate: !0,
                user: !1
            });
        (this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(i)
    }, Pn.prototype._checkStatement = function() {
        var e = this.expression;
        if (e && this.acceptStatement && !tt(e)) {
            var t = et(e).get,
                n = this._scope || this.vm,
                r = function(e) {
                    n.$event = e, t.call(n, n), n.$event = null
                };
            return this.filters && (r = n._applyFilters(r, null, this.filters)), this.update(r), !0
        }
    }, Pn.prototype.set = function(e) {
        this.twoWay && this._withLock(function() {
            this._watcher.set(e)
        })
    }, Pn.prototype._withLock = function(e) {
        var t = this;
        t._locked = !0, e.call(t), nr(function() {
            t._locked = !1
        })
    }, Pn.prototype.on = function(e, t, n) {
        le(this.el, e, t, n), (this._listeners || (this._listeners = [])).push([e, t])
    }, Pn.prototype._teardown = function() {
        if (this._bound) {
            this._bound = !1, this.unbind && this.unbind(), this._watcher && this._watcher.teardown();
            var e, t = this._listeners;
            if (t)
                for (e = t.length; e--;) he(this.el, t[e][0], t[e][1]);
            var n = this._paramUnwatchFns;
            if (n)
                for (e = n.length; e--;) n[e]();
            this.vm = this.el = this._watcher = this._listeners = null
        }
    };
    var Vo = /[^|]\|[^|]/;
    ! function(e) {
        e.prototype._init = function(e) {
            e = e || {}, this.$el = null, this.$parent = e.parent, this.$root = this.$parent ? this.$parent.$root : this, this.$children = [], this.$refs = {}, this.$els = {}, this._watchers = [], this._directives = [], this._uid = Xr++, this._isVue = !0, this._events = {}, this._eventsCount = {}, this._isFragment = !1, this._fragment = this._fragmentStart = this._fragmentEnd = null, this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = !1, this._unlinkFn = null, this._context = e._context || this.$parent, this._scope = e._scope, this._frag = e._frag, this._frag && this._frag.children.push(this), this.$parent && this.$parent.$children.push(this), e = this.$options = Ie(this.constructor.options, e, this), this._updateRef(), this._data = {}, this._callHook("init"), this._initState(), this._initEvents(), this._callHook("created"), e.el && this.$mount(e.el)
        }
    }(Cn),
    function(e) {
        function t() {}

        function n(e, t) {
            var n = new at(t, e, null, {
                lazy: !0
            });
            return function() {
                return n.dirty && n.evaluate(), ke.target && n.depend(), n.value
            }
        }
        Object.defineProperty(e.prototype, "$data", {
            get: function() {
                return this._data
            },
            set: function(e) {
                e !== this._data && this._setData(e)
            }
        }), e.prototype._initState = function() {
            this._initProps(), this._initMeta(), this._initMethods(), this._initData(), this._initComputed()
        }, e.prototype._initProps = function() {
            var e = this.$options,
                t = e.el,
                n = e.props;
            t = e.el = Q(t), this._propsUnlinkFn = t && 1 === t.nodeType && n ? en(this, t, n, this._scope) : null
        }, e.prototype._initData = function() {
            var e = this.$options.data,
                t = this._data = e ? e() : {};
            x(t) || (t = {});
            var n, r, i = this._props,
                a = Object.keys(t);
            for (n = a.length; n--;) r = a[n], i && o(i, r) || this._proxy(r);
            Fe(t, this)
        }, e.prototype._setData = function(e) {
            e = e || {};
            var t = this._data;
            this._data = e;
            var n, r, i;
            for (n = Object.keys(t), i = n.length; i--;)(r = n[i]) in e || this._unproxy(r);
            for (n = Object.keys(e), i = n.length; i--;) r = n[i], o(this, r) || this._proxy(r);
            t.__ob__.removeVm(this), Fe(e, this), this._digest()
        }, e.prototype._proxy = function(e) {
            if (!s(e)) {
                var t = this;
                Object.defineProperty(t, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return t._data[e]
                    },
                    set: function(n) {
                        t._data[e] = n
                    }
                })
            }
        }, e.prototype._unproxy = function(e) {
            s(e) || delete this[e]
        }, e.prototype._digest = function() {
            for (var e = 0, t = this._watchers.length; e < t; e++) this._watchers[e].update(!0)
        }, e.prototype._initComputed = function() {
            var e = this.$options.computed;
            if (e)
                for (var r in e) {
                    var i = e[r],
                        o = {
                            enumerable: !0,
                            configurable: !0
                        };
                    "function" == typeof i ? (o.get = n(i, this), o.set = t) : (o.get = i.get ? !1 !== i.cache ? n(i.get, this) : g(i.get, this) : t, o.set = i.set ? g(i.set, this) : t), Object.defineProperty(this, r, o)
                }
        }, e.prototype._initMethods = function() {
            var e = this.$options.methods;
            if (e)
                for (var t in e) this[t] = g(e[t], this)
        }, e.prototype._initMeta = function() {
            var e = this.$options._meta;
            if (e)
                for (var t in e) ze(this, t, e[t])
        }
    }(Cn),
    function(e) {
        function t(e, t) {
            for (var n, r, i, o = t.attributes, a = 0, s = o.length; a < s; a++) n = o[a].name, Ho.test(n) && (n = n.replace(Ho, ""), r = o[a].value, tt(r) && (r += ".apply(this, $arguments)"), i = (e._scope || e._context).$eval(r, !0), i._fromParent = !0, e.$on(n.replace(Ho), i))
        }

        function n(e, t, n) {
            if (n) {
                var i, o, a, s;
                for (o in n)
                    if (i = n[o], jn(i))
                        for (a = 0, s = i.length; a < s; a++) r(e, t, o, i[a]);
                    else r(e, t, o, i)
            }
        }

        function r(e, t, n, i, o) {
            var a = typeof i;
            if ("function" === a) e[t](n, i, o);
            else if ("string" === a) {
                var s = e.$options.methods,
                    c = s && s[i];
                c && e[t](n, c, o)
            } else i && "object" === a && r(e, t, n, i.handler, i)
        }

        function i() {
            this._isAttached || (this._isAttached = !0, this.$children.forEach(o))
        }

        function o(e) {
            !e._isAttached && ee(e.$el) && e._callHook("attached")
        }

        function a() {
            this._isAttached && (this._isAttached = !1, this.$children.forEach(s))
        }

        function s(e) {
            e._isAttached && !ee(e.$el) && e._callHook("detached")
        }
        e.prototype._initEvents = function() {
            var e = this.$options;
            e._asComponent && t(this, e.el), n(this, "$on", e.events), n(this, "$watch", e.watch)
        }, e.prototype._initDOMHooks = function() {
            this.$on("hook:attached", i), this.$on("hook:detached", a)
        }, e.prototype._callHook = function(e) {
            this.$emit("pre-hook:" + e);
            var t = this.$options[e];
            if (t)
                for (var n = 0, r = t.length; n < r; n++) t[n].call(this);
            this.$emit("hook:" + e)
        }
    }(Cn),
    function(e) {
        e.prototype._updateRef = function(e) {
            var t = this.$options._ref;
            if (t) {
                var n = (this._scope || this._context).$refs;
                e ? n[t] === this && (n[t] = null) : n[t] = this
            }
        }, e.prototype._compile = function(e) {
            var t = this.$options,
                n = e;
            if (e = wn(e, t), this._initElement(e), 1 !== e.nodeType || null === te(e, "v-pre")) {
                var r = this._context && this._context.$options,
                    i = tn(e, t, r);
                Tn(this, t._content);
                var o, a = this.constructor;
                t._linkerCachable && ((o = a.linker) || (o = a.linker = Yt(e, t)));
                var s = i(this, e, this._scope),
                    c = o ? o(this, e) : Yt(e, t)(this, e);
                this._unlinkFn = function() {
                    s(), c(!0)
                }, t.replace && ce(n, e), this._isCompiled = !0, this._callHook("compiled")
            }
        }, e.prototype._initElement = function(e) {
            Me(e) ? (this._isFragment = !0, this.$el = this._fragmentStart = e.firstChild, this._fragmentEnd = e.lastChild, 3 === this._fragmentStart.nodeType && (this._fragmentStart.data = this._fragmentEnd.data = ""), this._fragment = e) : this.$el = e, this.$el.__vue__ = this, this._callHook("beforeCompile")
        }, e.prototype._bindDir = function(e, t, n, r, i) {
            this._directives.push(new Pn(e, this, t, n, r, i))
        }, e.prototype._destroy = function(e, t) {
            if (this._isBeingDestroyed) return void(t || this._cleanup());
            var n, r, i = this,
                o = function() {
                    !n || r || t || i._cleanup()
                };
            e && this.$el && (r = !0, this.$remove(function() {
                r = !1, o()
            })), this._callHook("beforeDestroy"), this._isBeingDestroyed = !0;
            var a, s = this.$parent;
            for (s && !s._isBeingDestroyed && (s.$children.$remove(this), this._updateRef(!0)), a = this.$children.length; a--;) this.$children[a].$destroy();
            for (this._propsUnlinkFn && this._propsUnlinkFn(), this._unlinkFn && this._unlinkFn(), a = this._watchers.length; a--;) this._watchers[a].teardown();
            this.$el && (this.$el.__vue__ = null), n = !0, o()
        }, e.prototype._cleanup = function() {
            this._isDestroyed || (this._frag && this._frag.children.$remove(this), this._data && this._data.__ob__ && this._data.__ob__.removeVm(this), this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null, this._isDestroyed = !0, this._callHook("destroyed"), this.$off())
        }
    }(Cn),
    function(e) {
        e.prototype._applyFilters = function(e, t, n, r) {
            var i, o, a, s, c, l, h, u, d;
            for (l = 0, h = n.length; l < h; l++)
                if (i = n[r ? h - l - 1 : l], (o = Oe(this.$options, "filters", i.name, !0)) && "function" == typeof(o = r ? o.write : o.read || o)) {
                    if (a = r ? [e, t] : [e], c = r ? 2 : 1, i.args)
                        for (u = 0, d = i.args.length; u < d; u++) s = i.args[u], a[u + c] = s.dynamic ? this.$get(s.value) : s.value;
                    e = o.apply(this, a)
                }
            return e
        }, e.prototype._resolveComponent = function(t, n) {
            var r;
            if (r = "function" == typeof t ? t : Oe(this.$options, "components", t, !0))
                if (r.options) n(r);
                else if (r.resolved) n(r.resolved);
            else if (r.requested) r.pendingCallbacks.push(n);
            else {
                r.requested = !0;
                var i = r.pendingCallbacks = [n];
                r.call(this, function(t) {
                    x(t) && (t = e.extend(t)), r.resolved = t;
                    for (var n = 0, o = i.length; n < o; n++) i[n](t)
                }, function(e) {})
            }
        }
    }(Cn),
    function(e) {
        function t(e) {
            return JSON.parse(JSON.stringify(e))
        }
        e.prototype.$get = function(e, t) {
            var n = et(e);
            if (n) {
                if (t) {
                    var r = this;
                    return function() {
                        r.$arguments = v(arguments);
                        var e = n.get.call(r, r);
                        return r.$arguments = null, e
                    }
                }
                try {
                    return n.get.call(this, this)
                } catch (e) {}
            }
        }, e.prototype.$set = function(e, t) {
            var n = et(e, !0);
            n && n.set && n.set.call(this, this, t)
        }, e.prototype.$delete = function(e) {
            i(this._data, e)
        }, e.prototype.$watch = function(e, t, n) {
            var r, i = this;
            "string" == typeof e && (r = H(e), e = r.expression);
            var o = new at(i, e, t, {
                deep: n && n.deep,
                sync: n && n.sync,
                filters: r && r.filters,
                user: !n || !1 !== n.user
            });
            return n && n.immediate && t.call(i, o.value),
                function() {
                    o.teardown()
                }
        }, e.prototype.$eval = function(e, t) {
            if (Vo.test(e)) {
                var n = H(e),
                    r = this.$get(n.expression, t);
                return n.filters ? this._applyFilters(r, null, n.filters) : r
            }
            return this.$get(e, t)
        }, e.prototype.$interpolate = function(e) {
            var t = W(e),
                n = this;
            return t ? 1 === t.length ? n.$eval(t[0].value) + "" : t.map(function(e) {
                return e.tag ? n.$eval(e.value) : e.value
            }).join("") : e
        }, e.prototype.$log = function(e) {
            var n = e ? We(this._data, e) : this._data;
            if (n && (n = t(n)), !e) {
                var r;
                for (r in this.$options.computed) n[r] = t(this[r]);
                if (this._props)
                    for (r in this._props) n[r] = t(this[r])
            }
            console.log(n)
        }
    }(Cn),
    function(e) {
        function t(e, t, r, i, o, a) {
            t = n(t);
            var s = !ee(t),
                c = !1 === i || s ? o : a,
                l = !s && !e._isAttached && !ee(e.$el);
            return e._isFragment ? (we(e._fragmentStart, e._fragmentEnd, function(n) {
                c(n, t, e)
            }), r && r()) : c(e.$el, t, e, r), l && e._callHook("attached"), e
        }

        function n(e) {
            return "string" == typeof e ? document.querySelector(e) : e
        }

        function r(e, t, n, r) {
            t.appendChild(e), r && r()
        }

        function i(e, t, n, r) {
            ie(e, t), r && r()
        }

        function o(e, t, n) {
            ae(e), n && n()
        }
        e.prototype.$nextTick = function(e) {
            nr(e, this)
        }, e.prototype.$appendTo = function(e, n, i) {
            return t(this, e, n, i, r, Y)
        }, e.prototype.$prependTo = function(e, t, r) {
            return e = n(e), e.hasChildNodes() ? this.$before(e.firstChild, t, r) : this.$appendTo(e, t, r), this
        }, e.prototype.$before = function(e, n, r) {
            return t(this, e, n, r, i, Z)
        }, e.prototype.$after = function(e, t, r) {
            return e = n(e), e.nextSibling ? this.$before(e.nextSibling, t, r) : this.$appendTo(e.parentNode, t, r), this
        }, e.prototype.$remove = function(e, t) {
            if (!this.$el.parentNode) return e && e();
            var n = this._isAttached && ee(this.$el);
            n || (t = !1);
            var r = this,
                i = function() {
                    n && r._callHook("detached"), e && e()
                };
            return this._isFragment ? _e(this._fragmentStart, this._fragmentEnd, this, this._fragment, i) : (!1 === t ? o : J)(this.$el, this, i), this
        }
    }(Cn),
    function(e) {
        function t(e, t, r) {
            var i = e.$parent;
            if (i && r && !n.test(t))
                for (; i;) i._eventsCount[t] = (i._eventsCount[t] || 0) + r, i = i.$parent
        }
        e.prototype.$on = function(e, n) {
            return (this._events[e] || (this._events[e] = [])).push(n), t(this, e, 1), this
        }, e.prototype.$once = function(e, t) {
            function n() {
                r.$off(e, n), t.apply(this, arguments)
            }
            var r = this;
            return n.fn = t, this.$on(e, n), this
        }, e.prototype.$off = function(e, n) {
            var r;
            if (!arguments.length) {
                if (this.$parent)
                    for (e in this._events)(r = this._events[e]) && t(this, e, -r.length);
                return this._events = {}, this
            }
            if (!(r = this._events[e])) return this;
            if (1 === arguments.length) return t(this, e, -r.length), this._events[e] = null, this;
            for (var i, o = r.length; o--;)
                if ((i = r[o]) === n || i.fn === n) {
                    t(this, e, -1), r.splice(o, 1);
                    break
                }
            return this
        }, e.prototype.$emit = function(e) {
            var t = "string" == typeof e;
            e = t ? e : e.name;
            var n = this._events[e],
                r = t || !n;
            if (n) {
                n = n.length > 1 ? v(n) : n;
                var i = t && n.some(function(e) {
                    return e._fromParent
                });
                i && (r = !1);
                for (var o = v(arguments, 1), a = 0, s = n.length; a < s; a++) {
                    var c = n[a];
                    !0 !== c.apply(this, o) || i && !c._fromParent || (r = !0)
                }
            }
            return r
        }, e.prototype.$broadcast = function(e) {
            var t = "string" == typeof e;
            if (e = t ? e : e.name, this._eventsCount[e]) {
                var n = this.$children,
                    r = v(arguments);
                t && (r[0] = {
                    name: e,
                    source: this
                });
                for (var i = 0, o = n.length; i < o; i++) {
                    var a = n[i];
                    a.$emit.apply(a, r) && a.$broadcast.apply(a, r)
                }
                return this
            }
        }, e.prototype.$dispatch = function(e) {
            var t = this.$emit.apply(this, arguments);
            if (t) {
                var n = this.$parent,
                    r = v(arguments);
                for (r[0] = {
                        name: e,
                        source: this
                    }; n;) t = n.$emit.apply(n, r), n = t ? n.$parent : null;
                return this
            }
        };
        var n = /^hook:/
    }(Cn),
    function(e) {
        function t() {
            this._isAttached = !0, this._isReady = !0, this._callHook("ready")
        }
        e.prototype.$mount = function(e) {
            if (!this._isCompiled) return e = Q(e), e || (e = document.createElement("div")), this._compile(e), this._initDOMHooks(), ee(this.$el) ? (this._callHook("attached"), t.call(this)) : this.$once("hook:attached", t), this
        }, e.prototype.$destroy = function(e, t) {
            this._destroy(e, t)
        }, e.prototype.$compile = function(e, t, n, r) {
            return Yt(e, this.$options, !0)(this, e, t, n, r)
        }
    }(Cn);
    var Go = {
            priority: 2300,
            params: ["name"],
            bind: function() {
                var e = this.params.name || "default",
                    t = this.vm._slotContents && this.vm._slotContents[e];
                t && t.hasChildNodes() ? this.compile(t.cloneNode(!0), this.vm._context, this.vm) : this.fallback()
            },
            compile: function(e, t, n) {
                if (e && t) {
                    if (this.el.hasChildNodes() && 1 === e.childNodes.length && 1 === e.childNodes[0].nodeType && e.childNodes[0].hasAttribute("v-if")) {
                        var r = document.createElement("template");
                        r.setAttribute("v-else", ""), r.innerHTML = this.el.innerHTML, r._context = this.vm, e.appendChild(r)
                    }
                    var i = n ? n._scope : this._scope;
                    this.unlink = t.$compile(e, n, i, this._frag)
                }
                e ? ce(this.el, e) : ae(this.el)
            },
            fallback: function() {
                this.compile(me(this.el, !0), this.vm)
            },
            unbind: function() {
                this.unlink && this.unlink()
            }
        },
        Wo = {
            priority: 1750,
            params: ["name"],
            paramWatchers: {
                name: function(e) {
                    Hi.remove.call(this), e && this.insert(e)
                }
            },
            bind: function() {
                this.anchor = be("v-partial"), ce(this.el, this.anchor), this.insert(this.params.name)
            },
            insert: function(e) {
                var t = Oe(this.vm.$options, "partials", e, !0);
                t && (this.factory = new xt(this.vm, t), Hi.insert.call(this))
            },
            unbind: function() {
                this.frag && this.frag.destroy()
            }
        },
        $o = {
            slot: Go,
            partial: Wo
        },
        Xo = ji._postProcess,
        qo = /(\d{3})(?=\d)/g,
        Yo = {
            orderBy: In,
            filterBy: Rn,
            limitBy: Ln,
            json: {
                read: function(e, t) {
                    return "string" == typeof e ? e : JSON.stringify(e, null, arguments.length > 1 ? t : 2)
                },
                write: function(e) {
                    try {
                        return JSON.parse(e)
                    } catch (t) {
                        return e
                    }
                }
            },
            capitalize: function(e) {
                return e || 0 === e ? (e = e.toString(), e.charAt(0).toUpperCase() + e.slice(1)) : ""
            },
            uppercase: function(e) {
                return e || 0 === e ? e.toString().toUpperCase() : ""
            },
            lowercase: function(e) {
                return e || 0 === e ? e.toString().toLowerCase() : ""
            },
            currency: function(e, t, n) {
                if (e = parseFloat(e), !isFinite(e) || !e && 0 !== e) return "";
                t = null != t ? t : "$", n = null != n ? n : 2;
                var r = Math.abs(e).toFixed(n),
                    i = n ? r.slice(0, -1 - n) : r,
                    o = i.length % 3,
                    a = o > 0 ? i.slice(0, o) + (i.length > 3 ? "," : "") : "",
                    s = n ? r.slice(-1 - n) : "";
                return (e < 0 ? "-" : "") + t + a + i.slice(o).replace(qo, "$1,") + s
            },
            pluralize: function(e) {
                var t = v(arguments, 1),
                    n = t.length;
                if (n > 1) {
                    var r = e % 10 - 1;
                    return r in t ? t[r] : t[n - 1]
                }
                return t[0] + (1 === e ? "" : "s")
            },
            debounce: function(e, t) {
                if (e) return t || (t = 300), _(e, t)
            }
        };
    ! function(e) {
        function t(e) {
            return new Function("return function " + m(e) + " (options) { this._init(options) }")()
        }
        e.options = {
            directives: fo,
            elementDirectives: $o,
            filters: Yo,
            transitions: {},
            components: {},
            partials: {},
            replace: !0
        }, e.util = $r, e.config = Or, e.set = r, e.delete = i, e.nextTick = nr, e.compiler = jo, e.FragmentFactory = xt, e.internalDirectives = Io, e.parsers = {
            path: ai,
            text: Lr,
            template: Bi,
            directive: Er,
            expression: xi
        }, e.cid = 0;
        var n = 1;
        e.extend = function(e) {
            e = e || {};
            var r = this,
                i = 0 === r.cid;
            if (i && e._Ctor) return e._Ctor;
            var o = e.name || r.options.name,
                a = t(o || "VueComponent");
            return a.prototype = Object.create(r.prototype), a.prototype.constructor = a, a.cid = n++, a.options = Ie(r.options, e), a.super = r, a.extend = r.extend, Or._assetTypes.forEach(function(e) {
                a[e] = r[e]
            }), o && (a.options.components[o] = a), i && (e._Ctor = a), a
        }, e.use = function(e) {
            if (!e.installed) {
                var t = v(arguments, 1);
                return t.unshift(this), "function" == typeof e.install ? e.install.apply(e, t) : e.apply(null, t), e.installed = !0, this
            }
        }, e.mixin = function(t) {
            e.options = Ie(e.options, t)
        }, Or._assetTypes.forEach(function(t) {
            e[t] = function(n, r) {
                return r ? ("component" === t && x(r) && (r.name || (r.name = n), r = e.extend(r)), this.options[t + "s"][n] = r, r) : this.options[t + "s"][n]
            }
        }), y(e.transition, Dr)
    }(Cn), Cn.version = "1.0.28", setTimeout(function() {
        Or.devtools && Gn && Gn.emit("init", Cn)
    }, 0), e.exports = Cn
}, , , , , , function(e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n.d(t, "Brustor", function() {
        return r
    });
    var r, i = n(0),
        o = n(19),
        a = n(2),
        s = n(65);
    ! function(e) {
        window.THREE = i;
        new s.a(new a.a(o.a.config), new a.b);
        window.scene = window.env.scene
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return m
    });
    var r = n(2),
        i = n(66),
        o = n(9),
        a = n(58),
        s = (n.n(a), n(0)),
        c = n(68),
        l = (n.n(c), n(69)),
        h = n.n(l),
        u = n(15),
        d = n(70),
        p = n(71),
        f = u.a.getRalDict(),
        m = function() {
            function e(e, t) {
                var n = this;
                this.context = e;
                var c = e.config;
                c.locales && (c.locales[e.language] || (e.language.length > 2 && c.locales[e.language.substr(0, 2)] && (e.language = e.language.substr(0, 2)), c.locales[e.language] || alert("Sorry, the language " + e.language + " is not supported"))), a.use(h.a), a.config.lang = e.language, Object.keys(c.locales || {}).forEach(function(e) {
                    a.locale(e, c.locales[e])
                }), a.component("vsl-logo", {
                    data: function() {
                        return {
                            logoUrl: e.logoUrl
                        }
                    },
                  //template: '<img :src="logoUrl" class="vsl-logo"/>',
                    template: '<img src="./assets/img/logo.png" class="vsl-logo"/>'
                });
                var l, u = t.renderer,
                    m = t.env,
                    g = c.floatGuis || [],
                    v = g.map(function(e) {
                        return e.elementId
                    }),
                    y = [],
                    b = new s.Raycaster,
                    x = null,
                    w = !1,
                    _ = null;
                u.domElement.addEventListener("click", function(n) {
                    if (y.length) {
                        var r = n.clientX / window.innerWidth * 2 - 1,
                            o = -n.clientY / window.innerHeight * 2 + 1;
                        b.setFromCamera({
                            x: r,
                            y: o
                        }, u.camera);
                        var s = b.intersectObjects(y, !0);
                        if (s.length) {
                            for (var l = s[0], h = l.object; !v.some(function(e) {
                                    return e === h.name
                                });) h = h.parent;
                            w = !1, g.map(function(r) {
                                r.elementId == h.name && r.handlers.filter(function(e) {
                                    return e.event == n.type
                                }).map(function(r) {
                                    if (r.function) {
                                        var o = T.$children[0].$data,
                                            s = Object.keys(o);
                                        new Function("q", "var " + s.map(function(e) {
                                            return e + "= q." + e
                                        }).join(",") + ";" + r.function)(T.$children[0]), _ && _()
                                    }
                                    if (r.popup) {
                                        var l = new i.a.UIBuilder(t.env, e.isLoggedIn, t.dragNDrop).buildClass(r.popup, !1, t.dragNDrop, t.newBuilder).extend({
                                            data: function() {
                                                return JSON.parse(JSON.stringify(e.serverParameters || c.data))
                                            },
                                            ready: function() {
                                                this.$on("propertyupdated", function(e, t) {
                                                    T.$children[0].$set(e, t), T.propertyUpdated(e, t)
                                                })
                                            }
                                        });
                                        x && (x.$destroy(!0), x = null);
                                        var h = document.createElement("div");
                                        h.id = "popup", document.body.appendChild(h), x = new a({
                                            el: "#popup",
                                            template: "<template v-if='!closed()'><div class='popup' style='position:absolute;left:" + n.clientX + "px;top:" + n.clientY + 'px\'><i class="fa fa-close" aria-hidden="true" @click="close()" style="float:right"></i>  <mycomponent :value=\'[key]\'></mycomponent></div></template>',
                                            components: {
                                                mycomponent: l
                                            },
                                            methods: {
                                                closed: function() {
                                                    return w
                                                },
                                                close: function() {
                                                    this.$destroy(!0), x = null
                                                }
                                            }
                                        })
                                    }
                                })
                            })
                        } else x && x.close()
                    }
                }), c.locales || (c.locales = {
                    nl: {
                        step6tiltle1: "3D Configurator",
                        step6description1: "Start een nieuwe configuratie",
                        step6clickbutton: "Start"
                    },
                    en: {
                        step6tiltle1: "3D Configurator",
                        step6description1: "Start a new configuration",
                        step6clickbutton: "Start"
                    },
                    fr: {
                        step6tiltle1: "Configurateur 3D",
                        step6description1: "Lancez une nouvelle configuration",
                        step6clickbutton: "Démarrez"
                    },
                    de: {
                        step6tiltle1: "3D-Konfigurator",
                        step6description1: "Eine neue Konfiguration starten ",
                        step6clickbutton: "Start"
                    },
                    it: {
                        step6tiltle1: "Configuratore 3D",
                        step6description1: "Inizia una nuova configurazione",
                        step6clickbutton: "Inizia"
                    }
                });
                if (u.setBackgroundConfigurationKey("hof", function() {
                        c.builders.materials.filter(function(e) {
                            return e.useEnvMap
                        }).forEach(function(e) {
                            var n = t.materials[e.id];
                            n.envMap = t.materials.environmentSphere.map, n.needsUpdate = !0
                        })
                    }), !e.serverParameters || e.serverParameters.meta.allowEdit || e.serverParameters && e.serverParameters.meta.loginRequired && e.isLoggedIn) {
                    c.data.meta.loginRequired && !e.isLoggedIn && window.location.replace(e.loginUrl), e.serverParameters && (c.data = e.serverParameters);
                    var M = function(a) {
                        var c = e.serverParameters || a.data,
                            h = n;
                        c.interactive.dragAndDropGridSize = c.interactive.dragAndDropGridSize || 1;
                        var g = function() {
                                var e = new s.Mesh(new s.PlaneGeometry(3e3, 3e3, 30, 30), new s.MeshBasicMaterial);
                                e.material.color.setHex(0), e.material.wireframe = !0;
                                var t = e.clone();
                                t.position.y += 1500;
                                var n = e.clone();
                                n.rotation.x += Math.PI / 2, n.position.z += 1500, n.material = e.material.clone(), e.material.color.setHex(16777215);
                                var r = new s.Object3D;
                                return r.name = "grids", r.add(n), r.add(t), r.rotation.x = Math.PI, r
                            }(),
                            b = a.gui.map(function(n, c) {
                                return {
                                    name: "item" + c,
                                    component: new i.a.UIBuilder(t.env, e.isLoggedIn, t.dragNDrop).buildClass(n.ui, !0, t.dragNDrop, t.newBuilder).extend({
                                        data: function() {
                                            return a.data
                                        },
                                        ready: function() {
                                            var e = this;
                                            _ = this.updateMesh, l = this, this.$on("propertyupdated", function(t, n) {
                                                return e.propertyUpdated(t, n)
                                            }), this.$on("valuechanged", function(t, n) {
                                                return e.propertyUpdated(t, n)
                                            });
                                            var n = this.updateMesh();
                                            this.homography && this.homography.enabled ? u.lookFromTo(new s.Vector3(0, 0, 0), new s.Vector3(0, 0, 100)) : u.lookAtObject(n.name, 0, 0, 3 * -this.size.width), t.attachComponent();
                                            var r = function(e, t) {
                                                return Math.round(e / t) * t
                                            };
                                            t.dragNDrop.emitEvent = function(t) {
                                                t.dropped.forEach(function(t) {
                                                    t.height = r(t.height, e.interactive.dragAndDropGridSize), t.width = r(t.width, e.interactive.dragAndDropGridSize), t.position[0] = r(t.position[0], e.interactive.dragAndDropGridSize / 2), t.position[1] = r(t.position[1], e.interactive.dragAndDropGridSize / 2)
                                                }), e.$set("elements.droppedElements", t.dropped), e.$emit("propertyupdated", "elements.droppedElements", t.dropped), e.updateMesh()
                                            }
                                        },
                                        beforeDestroy: function() {
                                            t.detachComponent(), this.$off("propertyupdated"), this.$off("valuechanged")
                                        },
                                        methods: {
                                            propertyUpdated: function(e, n) {
                                                var r = /([^\.]+)(RalColorId|Roughness|Metalness)$/i.exec(e),
                                                    i = (r || /^materials\.([^\.] +).([^\.] +)$/.exec(e), r ? t.materials[r[1]] : null);
                                                if (i) switch (r[2]) {
                                                    case "RalColorId":
                                                        i.color.setHex(f.getHexColor(n));
                                                        break;
                                                    case "Roughness":
                                                        i.roughness = n;
                                                        break;
                                                    case "Metalness":
                                                        i.metalness = n;
                                                        break;
                                                    case "imageUrl":
                                                        (new s.TextureLoader).load(n, function(e) {
                                                            i.map = e, i.needsUpdate = !0
                                                        })
                                                } else {
                                                    if ("interactive.sunRotation" === e) {
                                                        var o = m.scene.getObjectByName("sun"),
                                                            a = n / 180 * Math.PI,
                                                            c = Math.sin(a),
                                                            l = Math.cos(a);
                                                        return o.position.x = c, void(o.position.z = -l)
                                                    }
                                                    var d = this.updateMesh();
                                                    "homography.enabled" === e ? n ? u.lookFromTo(new s.Vector3(0, 0, 0), new s.Vector3(0, 0, 100)) : u.lookAtObject(d.name, 0, 0, 3 * -this.size.width) : "elements.droppedElements" != e && (this.recalcDraggableElements(), h.floatGui && (h.floatGui.$emit("propertyupdated", e, n), h.floatGui.$children[0].$set(e, n), h.floatGui.$children[0].$set("vars", JSON.parse(JSON.stringify(this.vars)))))
                                                }
                                            },
                                            updateMesh: function() {
                                                var e = t.newBuilder.build(this.style.type, a.builders, this, v),
                                                    r = e.obj;
                                                r.name = "Woohoo";
                                                var i = new s.Object3D;
                                                i.add(r), i.name = "wrapped " + r.name, t.dragNDrop.dropTargets = e.dropTargets, t.dragNDrop.dropped = e.dropped, r.traverse(function(e) {
                                                    var n = e;
                                                    if (n.material && n.material !== t.materials.shadowMaterial) {
                                                        var i = n.material;
                                                        e.castShadow = !i.transparent || i.opacity > .7
                                                    }
                                                    e.receiveShadow = n.receiveShadow = "noshading" != r.name
                                                }), y = e.actionableObjects, u.addOrReplaceObject(i), u.scene.updateMatrixWorld(), t.dragNDrop.activeDropTargetIds = n.activeDropTargetIds;
                                                var o = t.newBuilder.buildDraggableElements(t.dragNDrop.activeDropTargetIds, a.builders, this, v);
                                                if (t.updateDraggableElements(o), "photo" == this.mode);
                                                else if ("homography" == this.mode || this.homography && this.homography.enabled) {
                                                    var c = .1 * window.innerWidth / window.innerHeight,
                                                        l = [{
                                                            x: -.1,
                                                            y: -c
                                                        }, {
                                                            x: .1,
                                                            y: -c
                                                        }, {
                                                            x: .1,
                                                            y: c
                                                        }, {
                                                            x: -.1,
                                                            y: c
                                                        }].map(function(e) {
                                                            return {
                                                                x: e.x + 1.5 * (this.homography.position.x - .5),
                                                                y: e.y + 1.5 * (this.homography.position.y - .5)
                                                            }
                                                        }.bind(this)),
                                                        h = r;
                                                    Object(p.a)(l, 200, 200, h.parent), h.scale.setScalar(this.homography.scale), h.parent.rotation.x += this.homography.rotation.x, h.parent.rotation.y += this.homography.rotation.y + Math.PI;
                                                    this.backgroundImage;
                                                    if (this.homography.gridsVisible) {
                                                        var d = h.getObjectByName("gridanchor") || h;
                                                        d.add(g)
                                                    }
                                                } else u.setBackgroundImage(null), r.parent.rotation.set(0, 0, 0);
                                                return r
                                            },
                                            mesh: function() {
                                                return this.updateMesh(), null
                                            },
                                            recalcDraggableElements: function() {
                                                t.dragNDrop.dropped.forEach(function(e, n) {
                                                    var r = e.localBoundingBox.clone().translate((new s.Vector2).fromArray(e.position.concat([0]))),
                                                        i = t.dragNDrop.dropTargets.filter(function(t) {
                                                            return t.dropTargetId == e.dropTargetId && t.name == e.dropTargetName
                                                        }),
                                                        a = o.a.Intersector.adjustElementPosition(r, i[0], e),
                                                        c = a.getCenter(),
                                                        l = a.getSize();
                                                    e.width = l.width, e.height = l.height, e.position = c.toArray().concat([e.position[2]]), e.localBoundingBox.min.x = -l.x / 2, e.localBoundingBox.min.y = -l.y / 2, e.localBoundingBox.max.x = l.x / 2, e.localBoundingBox.max.y = l.y / 2, e.intersectable.localBoundingBox.copy(e.localBoundingBox)
                                                });
                                                var e = t.dragNDrop.dropped.map(function(e) {
                                                    return Object.assign({}, e, {
                                                        intersectable: {
                                                            localBoundingBox: e.intersectable.localBoundingBox,
                                                            mesh: null
                                                        }
                                                    })
                                                });
                                                this.$set("elements.droppedElements", e), this.$emit("propertyupdated", "elements.droppedElements", e)
                                            }
                                        },
                                        computed: {
                                            renderer: function() {
                                                return u
                                            },
                                            backgroundImage: function() {
                                                if (!this.homography.enabled) return 0;
                                                var e = new Image;
                                                return e.onload = function() {
                                                    u.setBackgroundImage(e)
                                                }, e.src = Object(r.c)(this.homography.imageSrc || "textures/perspectivebg.jpg"), 1
                                            }
                                        },
                                        locales: a.locales
                                    }),
                                    icon: n.faIcon
                                }
                            });
                        return d.a.getSidebar().extend({
                            data: function() {
                                return {
                                    currentComponentName: b[0].name,
                                    componentInfo: b,
                                    prevButtonText: this.$t("generalbuttonprevious"),
                                    nextButtonText: this.$t("generalbuttonnext")
                                }
                            },
                            methods: {
                                propertyUpdated: function(e, t) {
                                    this.$children.length && this.$children[0].propertyUpdated(e, t)
                                }
                            },
                            watch: {
                                currentComponentName: function() {
                                    "none" != this.currentComponentName && this.vars && (this.vars.currentUI = this.currentUI)
                                }
                            },
                            components: b.reduce(function(e, t) {
                                return e[t.name] = t.component, e
                            }, {}),
                            locales: {
                                nl: {
                                    generalbuttonnext: "Volgende",
                                    generalbuttonprevious: "Vorige"
                                },
                                en: {
                                    generalbuttonnext: "next",
                                    generalbuttonprevious: "back"
                                },
                                de: {
                                    generalbuttonnext: "Weiter",
                                    generalbuttonprevious: "Zurück"
                                },
                                fr: {
                                    generalbuttonnext: "Suivant",
                                    generalbuttonprevious: "Précédent"
                                }
                            }
                        })
                    }(c);
                    this.gui = new M({
                        el: "#sidebar-container"
                    }), s.DefaultLoadingManager.onProgress = function(e, t, r) {
                        if (t == r) {
                            n.gui.$children[0].updateMesh();
                            var i = document.querySelector(".loader");
                            i && i.classList.remove("loader")
                        }
                    }
                } else {
                    if (e.serverParameters.meta.openInVR) {
                        var E = window.location.href.replace(/\/share\//gi, "/vr/");
                        window.location.replace(E)
                    }
                    this.gui = new a({
                        el: "#sidebar-container",
                        data: function() {
                            return e.serverParameters.newUrl = e.newUrl, e.serverParameters
                        },
                        ready: function() {
                            var e = this.updateMesh();
                            this.homography.enabled ? u.lookFromTo(new s.Vector3(0, 0, 0), new s.Vector3(0, 0, 100)) : u.lookAtObject(e.name, 0, 0, 3 * -this.size.width)
                        },
                        template: '<div class="share-container"><vsl-logo></vsl-logo><h5>{{$t("step6tiltle1")}}</h5><template v-if="allowNew"><p>{{{$t("step6description1")}}}</p><a class="btn btn-primary" :href="newUrl"><i class="fa fa-sign-in" aria-hidden="true"></i>{{$t("step6clickbutton")}}</a></template></div>',
                        methods: {
                            propertyUpdated: function(e, n) {
                                var r = /([^\.]+)RalColorId$/i.exec(e);
                                if (r) {
                                    var i = r[1];
                                    t.materials[i].color.setHex(f.getHexColor(n))
                                } else {
                                    if ("interactive.sunRotation" === e) {
                                        var o = m.scene.getObjectByName("sun"),
                                            a = n / 180 * Math.PI,
                                            c = Math.sin(a),
                                            l = Math.cos(a);
                                        return o.position.x = c, void(o.position.z = -l)
                                    }
                                    this.$set(e, n);
                                    var h = this.updateMesh();
                                    "homography.enabled" === e && (n ? u.lookFromTo(new s.Vector3(0, 0, 0), new s.Vector3(0, 0, 100)) : u.lookAtObject(h.name, 0, 0, 3 * -this.size.width))
                                }
                            },
                            updateMesh: function() {
                                var e = t.newBuilder.build(this.style.type, c.builders, this, v),
                                    n = e.obj;
                                n.name = "Woohoo";
                                var r = new s.Object3D;
                                if (r.add(n), r.name = "wrapped " + n.name, n.traverse(function(e) {
                                        var n = e;
                                        if (n.material && n.material !== t.materials.shadowMaterial) {
                                            var r = n.material;
                                            e.castShadow = !r.transparent || r.opacity > .7
                                        }
                                        e.receiveShadow = !0
                                    }), u.addOrReplaceObject(r), this.homography && this.homography.enabled) {
                                    var i = .1 * window.innerWidth / window.innerHeight,
                                        o = [{
                                            x: -.1,
                                            y: -i
                                        }, {
                                            x: .1,
                                            y: -i
                                        }, {
                                            x: .1,
                                            y: i
                                        }, {
                                            x: -.1,
                                            y: i
                                        }].map(function(e) {
                                            return {
                                                x: e.x + 1.5 * (this.homography.position.x - .5),
                                                y: e.y + 1.5 * (this.homography.position.y - .5)
                                            }
                                        }.bind(this)),
                                        a = n;
                                    Object(p.a)(o, 200, 200, a.parent), a.scale.setScalar(this.homography.scale), a.parent.rotation.x += this.homography.rotation.x, a.parent.rotation.y += this.homography.rotation.y + Math.PI;
                                    this.backgroundImage;
                                    u.scene.updateMatrixWorld()
                                } else u.setBackgroundImage(null), n.parent.rotation.set(0, 0, 0), u.scene.updateMatrixWorld(), u.lookAtObject(n.name, 0, 0, 3 * -this.size.width);
                                return e.obj
                            }
                        },
                        computed: {
                            renderer: function() {
                                return u
                            },
                            environment: function() {
                                return t
                            },
                            config: function() {
                                return c
                            },
                            allowNew: function() {
                                return !e.serverParameters.meta.loginRequired
                            },
                            backgroundImage: function() {
                                if (!this.homography || !this.homography.enabled) return 0;
                                var e = new Image;
                                return e.onload = function() {
                                    u.setBackgroundImage(e)
                                }, e.src = this.homography.imageSrc || Object(r.c)("textures/perspectivebg.html"), 1
                            }
                        },
                        watch: {
                            interactive: {
                                deep: !0,
                                handler: function() {
                                    this.updateMesh()
                                }
                            },
                            "homography.enabled": function(e) {
                                u.controls.enabled = !e, this.updateMesh()
                            }
                        },
                        locales: c.locales
                    }), s.DefaultLoadingManager.onProgress = function(e, t, r) {
                        if (t == r) {
                            n.gui.updateMesh();
                            var i = document.querySelector(".loader");
                            i && i.classList.remove("loader")
                        }
                    }
                }
                t.newBuilder.loadTexturesAndMaterial(c.builders, new a({
                    data: c.data
                }));
                var T = this.gui;
                if (document.body.addEventListener("keydown", function(e) {
                        if (e.altKey) switch (e.key) {
                            case "i":
                                var n = window.prompt("Please enter the URL of the design you wish to import");
                                if (n && n.match(/^http/)) {
                                    var r = new XMLHttpRequest;
                                    n = n.replace(/\/(share|vr)\//i, "https://productconfigurator.virtualsaleslab.com/designdata/"), r.onreadystatechange = function() {
                                        if (4 == this.readyState && 200 == this.status) {
                                            var e = JSON.parse(this.responseText);
                                            if (e.meta.designer != T.$children[0].$data.meta.designer) return void alert('You can not import this design because it is a design from the "' + e.meta.designer + '".');
                                            delete e.extra, delete e.contact, delete e.meta, delete e.vars, Object.assign(T.$children[0].$data, e), T.propertyUpdated()
                                        }
                                    }, r.open("GET.html", n, !0), r.send()
                                } else window.alert("No data imported");
                                break;
                            case "x":
                                var i = JSON.stringify(T.$children[0].$data, null, "\t"),
                                    o = document.createElement("a");
                                o.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(i)), o.setAttribute("download", "export.json"), o.style.display = "none", document.body.appendChild(o), o.click(), document.body.removeChild(o);
                                break;
                            case "o":
                                var a = new s.OBJExporter,
                                    c = a.parse(t.env.scene.getChildByName("Woohoo")),
                                    l = document.createElement("a"),
                                    h = new Blob([c], {
                                        type: "text/obj"
                                    });
                                l.href = URL.createObjectURL(h), l.download = "model.obj", l.click()
                        }
                    }), c.floatGui) {
                    var S = new i.a.UIBuilder(t.env, e.isLoggedIn, t.dragNDrop).buildClass(c.floatGui.ui, !1, t.dragNDrop, t.newBuilder).extend({
                        data: function() {
                            return JSON.parse(JSON.stringify(e.serverParameters || c.data))
                        },
                        ready: function() {
                            this.$on("propertyupdated", function(e, t) {
                                T.$children[0].$set(e, t), T.propertyUpdated(e, t)
                            })
                        }
                    });
                    this.floatGui = new a({
                        el: "#float-gui",
                        data: {
                            closed: !1
                        },
                        template: "<template v-if='closed'><div class='float-gui' style='min-width:1.5em;font-size:2em;padding: 0em 0.25em'><i class=\"fa fa-sun-o\" aria-hidden=\"true\" @click=\"closed=false\"></i></div></template><template v-if='!closed'><div class='float-gui'>" + '<i class="fa fa-close" aria-hidden="true" @click="closed=true" style="float:right"></i>  <mycomponent></mycomponent></div></template>',
                        components: {
                            mycomponent: S
                        }
                    })
                }
            }
            return e
        }()
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return c
    });
    var r = n(58),
        i = (n.n(r), n(0)),
        o = n(15),
        a = n(67),
        s = o.a.getRalDict();
    a.a.registerPolygonEditor(r, i);
    var c;
    ! function(e) {
        function t(e, t) {
            var r = !!n[e.elementId];
            if (r) {
                var i = JSON.stringify({
                    opts: e.opts,
                    wopts: e.windowOpts
                });
                i != o[e.elementId] && (r = !1, o[e.elementId] = i)
            }
            if (!r) {
                var a = e.intersectable.object.clone();
                a.visible = !0, a.rotation.x += Math.PI;
                var s = t.renderToPng(a, 100);
                "data:," == s && (s = t.renderToPng(a, 100)), n[e.elementId] = s
            }
            return n[e.elementId]
        }
        var n = {},
            o = {},
            a = function() {
                function e() {
                    this.components = {}
                }
                return e.prototype.clone = function() {
                    var t = new e;
                    return t.components = this.components, t
                }, e.prototype.register = function(e, t) {
                    return this.components["c-" + e] = t, this
                }, e.prototype.getVueClass = function(e, n, i, o) {
                    function a(e) {
                        return e ? Array.isArray(e) ? e.join("\n") : e : ""
                    }

                    function s(e, t) {
                        var n = a(e.templatePrefix) + '\n                        <component is="c-' + e.kind + '" \n                                    :opts="(' + t + '.opts||{})" \n                        ',
                            r = e.key;
                        return r && (n += ":value='" + r + "' key='" + r + "' \n                    @change.stop='onInput($event,\"" + r + "\")' \n                    @input.stop='onInput($event,\"" + r + "\")' \n                    @valuechanged='onValueChanged' "), n += ">\n", n += (e.children || []).map(function(e, n) {
                            return s(e, t + ".children[" + n + "]")
                        }).join("\n"), n += "</component>\n                        " + a(e.templatePostfix)
                    }
                    var c = "<div>" + e.map(function(e, t) {
                            return s(e, "guiElements[" + t + "]")
                        }).join("\n") + '\n<template v-if="draggables.length">\n    <div id="dragndrop" class="vsl-draggables" style="padding-top:4em">\n      <div class="draggable-caption" style="min-height:3em;position:absolute;top:0px">\n      <p v-if="hovered" >\n        {{hovered}}\n      </p>\n      <h5 v-else>{{$t("Zu Seitenelemente hinzufügen per Drag & Drop")}}</h5>\n      </div>\n      <div class="draggable-elements">\n    <img v-for="draggable in draggables" :src="imageFor(draggable)" \n      @mousedown="setPotentialDraggable(draggable),setHovered(draggable)"\n      @touchstart="setPotentialDraggable(draggable),setHovered(draggable)"\n      @touchmove="maybeStartTouchDrag($event)"\n      @mousemove="maybeStartDrag($event)" \n      @mouseenter="setHovered(draggable)"\n      @mouseleave="setHovered(null)"\n      @touchend="maybeTouchEnd($event),setHovered(null)"\n    />\n    </div>\n</div>\n</template>\n                ',
                        l = null,
                        h = null;
                    return r.extend({
                        computed: {
                            guiElements: function() {
                                return e
                            },
                            draggables: function() {
                                this.draggableFlag;
                                if (!n) return [];
                                var e = i.dropTargets.filter(function(e) {
                                    return i.activeDropTargetIds.indexOf(e.dropTargetId) > -1
                                }).map(function(e) {
                                    return e.dropTargetId
                                }).filter(function(e, t, n) {
                                    return n.indexOf(e) === t
                                });
                                return i.draggables.filter(function(t) {
                                    return t.allowedDropTargets.some(function(t) {
                                        return -1 !== e.indexOf(t)
                                    })
                                })
                            }
                        },
                        data: function() {
                            return {
                                draggableFlag: 1,
                                hovered: ""
                            }
                        },
                        ready: function() {
                            this.$nextTick(function() {
                                this.draggableFlag += 1
                            })
                        },
                        methods: {
                            onInput: function(e, t) {
                                var n;
                                e && e.detail && e.detail.value ? n = e.detail.value : e && e.target && (n = e.target.value, n = e.target.attributes.type && "checkbox" === e.target.attributes.type.value ? e.target.checked : parseFloat(n) == n ? parseFloat(n) : e.target.value), this.$set(t, n), this.$emit("propertyupdated", t, n), this.draggableFlag += 1
                            },
                            onValueChanged: function(e, t) {
                                this.$set(e, t), this.$emit("propertyupdated", e, t), this.draggableFlag += 1
                            },
                            imageFor: function(e) {
                                return t(e, o)
                            },
                            setPotentialDraggable: function(e) {
                                l = e.elementId
                            },
                            maybeStartDrag: function(e) {
                                e.buttons && l && (i.beginDrag(l, e), l = null), i.processMouseEvent(e)
                            },
                            maybeStartTouchDrag: function(e) {
                                var t = {
                                    buttons: 1,
                                    type: "mousemove",
                                    clientX: e.touches[0].clientX,
                                    clientY: e.touches[0].clientY,
                                    preventDefault: function() {
                                        e.preventDefault()
                                    },
                                    target: e.target
                                };
                                h = e, this.maybeStartDrag(t)
                            },
                            maybeTouchEnd: function(e) {
                                var t = {
                                    buttons: 1,
                                    type: "mouseup",
                                    clientX: h.touches[0].clientX,
                                    clientY: h.touches[0].clientY,
                                    preventDefault: function() {
                                        e.preventDefault()
                                    },
                                    target: e.target
                                };
                                i.processMouseEvent(t)
                            },
                            setHovered: function(e) {
                                this.hovered = e ? this.$t(e.id) : null
                            }
                        },
                        template: c,
                        components: this.components
                    })
                }, e
            }(),
            c = function() {
                function e(e, t, n) {
                    var o = e.renderer;
                    this.componentBuilder = new a, this.componentBuilder.register("slider", r.extend({
                        props: ["opts", "value", "key"],
                        ready: function() {
                            this.value > this.opts.max ? this.$dispatch("valuechanged", this.key, this.opts.max) : this.value < this.opts.min && this.$dispatch("valuechanged", this.key, this.opts.min)
                        },
                        template: '\n                <div class="vsl-input-container vsl-slider" :class="{\'multi-line\': opts.multiLine}">\n                <label>{{$t(opts.label)}} </label>\n                 <input v-model="value" type="range" min="{{opts.min}}" max="{{opts.max}}" step="{{opts.step}}" number @change.stop="onChange" @input.stop="onChange"/>\n                 <input v-model="value" type="number" min="{{opts.min}}" max="{{opts.max}}" step="{{opts.step}}" number @change.stop="onChange" @input.stop="onChange"/> {{opts.unit}}\n                </div>',
                        methods: {
                            onChange: function(e) {
                                var t = parseFloat(e.target.value);
                                t = Math.max(Math.min(t, this.opts.max), this.opts.min), this.$dispatch("valuechanged", this.key, t)
                            }
                        }
                    })), this.componentBuilder.register("number", r.extend({
                        props: ["opts", "value", "key"],
                        ready: function() {
                            this.value > this.opts.max ? this.$dispatch("valuechanged", this.key, this.opts.max) : this.value < this.opts.min && this.$dispatch("valuechanged", this.key, this.opts.min)
                        },
                        template: '\n                <div class="vsl-input-container vsl-slider" :class="{\'multi-line\': opts.multiLine}">\n                <label>{{$t(opts.label)}} </label>\n                 <input v-model="value" type="number" min="{{opts.min}}" max="{{opts.max}}" step="{{opts.step}}" number @change.stop="onChange" @input.stop="onChange"/> {{opts.unit}}\n                </div>',
                        methods: {
                            onChange: function(e) {
                                var t = parseFloat(e.target.value);
                                t = Math.max(Math.min(t, this.opts.max), this.opts.min), this.$dispatch("valuechanged", this.key, t)
                            }
                        }
                    })), this.componentBuilder.register("wrapper", r.extend({
                        props: ["opts"],
                        template: '\n                <div class="vsl-wrapper">\n                  <slot></slot>\n                </div>'
                    })), this.componentBuilder.register("ralcode", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            var e;
                            return e = this.opts && this.opts.codes ? this.opts.codes : s.codes, {
                                ralCodes: e,
                                colorPickerVisible: !1
                            }
                        },
                        computed: {
                            info: function() {
                                return this.getInfo(this.value)
                            },
                            isColorPickerVisible: function() {
                                return this.colorPickerVisible || this.opts.alwaysExpand
                            }
                        },
                        methods: {
                            toggleVisibility: function() {
                                this.colorPickerVisible = !this.colorPickerVisible
                            },
                            setRalCode: function(e) {
                                this.toggleVisibility(), this.value = e.target.value;
                                var t = this.$el.querySelector("input");
                                t.value = e.target.value, this.$dispatch("valuechanged", this.key, t.value)
                            },
                            getInfo: function(e) {
                                return s.getCode(e)
                            },
                            getInfoStyle: function(e) {
                                var t = s.getCode(e),
                                    n = parseInt(t.rgbHex.substring(1), 16),
                                    r = n >> 16 & 255,
                                    i = n >> 8 & 255,
                                    o = n >> 0 & 255,
                                    a = r * r + i * i + o * o < 49152;
                                return {
                                    backgroundColor: t.rgbHex,
                                    color: a ? "white" : "black"
                                }
                            }
                        },
                        template: '\n            <div class="vsl-input-container vsl-ral-picker">\n                <input type="hidden" :value.sync="value" />\n                <label>{{this.$t(opts.label)}} </label> \n                <input class="vsl-ral-main-button" type="button" :value="value" @click="toggleVisibility"\n                       :style="getInfoStyle(info.code)"  /> {{info.name}}\n                <div v-if="isColorPickerVisible" class="vsl-ral-picker-inner-container" :style="{maxHeight: opts.containerHeight}">\n                    <input type="button" v-for="ralCode in ralCodes"\n                     class="vsl-ral-color-button"\n                     :style="getInfoStyle(ralCode)"\n                     :value="ralCode" @click="setRalCode"/>\n                </div>\n            </div>'
                    })), this.componentBuilder.register("checkbox", r.extend({
                        props: ["value", "opts"],
                        template: '\n            <div class="vsl-input-container vsl-checkbox">\n              <label> <input v-model="value" type="checkbox" /> {{$t(opts.label)}} </label>\n            </div>'
                    })), this.componentBuilder.register("navigate3D", r.extend({
                        props: ["value", "opts"],
                        template: '\n            <div class="vsl-input-container vsl-navigator3d">\n                <table>\n                    <tr>\n                        <td>&nbsp;</td>\n                        <td>\n                           <a class="btn btn-primary" v-on:click=\'ortho(0,1,0)\'>Top</a>\n                        </td>\n                        <td colspan="2">\n                            <a class="btn btn-primary" v-on:click=\'perspective()\'>Perspective</a>\n                        </td>\n                    <tr/>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(1,0,0)\'>Left</a>\n                        </td>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(0,0,-1)\'>Front</a>\n                        </td>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(-1,0,0)\'>Right</a>\n                        </td>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(0,0,1)\'>Back</a>\n                        </td>\n                </table>\n            </div>',
                        methods: {
                            ortho: function(t, n, r) {
                                e.cameraCombiner.toOrthographic(), e.lookAtObject("Woohoo", 1e3 * t, 1e3 * n, 1e3 * r, function() {
                                    0 === t && 0 === r && (e.controls.minAzimuthAngle = Math.PI, e.controls.maxAzimuthAngle = Math.PI, e.controls.update(), e.controls.minAzimuthAngle = -1 / 0, e.controls.maxAzimuthAngle = 1 / 0)
                                }), e.controls.enableRotate = !1
                            },
                            perspective: function() {
                                e.cameraCombiner.toPerspective(), e.controls.enableRotate = !0
                            }
                        }
                    })), this.componentBuilder.register("textbox", r.extend({
                        props: ["value", "opts"],
                        template: '\n            <div class="vsl-input-container vsl-textbox">\n              <label v-if="opts.label"> {{$t(opts.label)}} </label>\n               <input :value.sync="value" type="textbox" :placeholder="opts.placeholder" :style="opts.style" /> \n            </div>'
                    })), this.componentBuilder.register("select", r.extend({
                        props: ["value", "opts"],
                        template: '\n            <div class="vsl-input-container vsl-select" :class="{\'multi-line\': opts.multiLine}">\n                <label> {{$t(opts.label)}} </label>\n                <select :v-model="value" :value="value">\n                    <option v-for="item in opts.items" :value="item.key">{{$t(item.label)}}</option>\n                </select>\n            </div>\n            '
                    })), this.componentBuilder.register("imagelist", r.extend({
                        props: ["value", "opts"],
                        template: '\n            <div class="vsl-input-container vsl-imagelist" >\n                <label v-for="item in opts.items"> \n                    <input type="radio" v-model="value" :value="item.key" />\n                    <img :alt="item.label||item.key" :src="opts.imagesPath+item.key+opts.imagesExtension"/>\n                    <div v-if="item.label" class="vsl-imagelist-label">{{$t(item.label)}}</div>\n                </label>\n            </div>\n            '
                    })), this.componentBuilder.register("contact", r.extend({
                        props: ["opts"],
                        data: function() {
                            return this.$parent.$data
                        },
                        template: '',
                        // template: '<div v-if="wasSubmitted"><form v-if="canOverwrite" @submit.prevent="this.submitForm($event)"><input type="submit" class="btn btn-primary" :value="$t(\'savebutton\')" /></form></div><div v-else class="contact-form"><form @submit.prevent="this.submitForm($event)"><input v-if="isUsed(\'name\')" :placeholder="$t(\'name\')" type="text" v-model="contact.name" :required="isRequired(\'name\')" /><span class="status"></span><input v-if="isUsed(\'firstName\')" :placeholder="$t(\'firstName\')" type="text" v-model="contact.firstName" :required="isRequired(\'firstName\')" /><span class="status"></span><input v-if="isUsed(\'email\')" :placeholder="$t(\'email\')" name="email" type="email" v-model="contact.email" :required="isRequired(\'email\')" /><span class="status"></span><input v-if="isUsed(\'street\')" :placeholder="$t(\'street\')" class="two-thirds" type="text" v-model="contact.street" :required="isRequired(\'street\')" /><span class="status"></span><input v-if="isUsed(\'number\')" :placeholder="$t(\'nr\')" class="one-third" type="text" v-model="contact.housenumber" :required="isRequired(\'number\')"/><span class="status"></span><input v-if="isUsed(\'zip\')" :placeholder="$t(\'zip\')" class="one-third" type="text" v-model="contact.zip" :required="isRequired(\'zip\')" /><span class="status"></span><input v-if="isUsed(\'city\')" :placeholder="$t(\'city\')" class="two-thirds" type="text" v-model="contact.city" :required="isRequired(\'city\')" /><span class="status"></span><input v-if="isUsed(\'phone\')" :placeholder="$t(\'phone\')" type="tel" v-model="contact.phone" :required="isRequired(\'phone\')" /><span class="status"></span><textarea v-if="isUsed(\'remarks\')" :placeholder="$t(\'remarks\')" v-model="contact.remarks" :required="isRequired(\'remarks\')"></textarea><p v-if="resultUrl">Saved: <a :href="resultUrl"> Link </a></p><input v-else type="submit" class="btn btn-primary" :value="$t(\'savebutton\')" /></form></div>',
                        methods: {
                            submitForm: function(t) {
                                function n(e, t, n) {
                                    t = JSON.stringify(t), i.open("POST.html", e), i.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), i.onload = n, i.send(t)
                                }
                                var r = this;
                                if (!document.body.classList.contains("saving")) {
                                    document.body.classList.add("saving");
                                    var i = new XMLHttpRequest;
                                    return this.$parent.updateMesh(), this.$set("meta.designId", id), this.$set("meta.designer", designType), this.$set("meta.urlReferrer", document.referrer), e.screenshotAsBase64EncodedJpg(function(e) {
                                        var t = {
                                                id: r.designId,
                                                json: JSON.stringify(r.$data),
                                                imageData: e.replace(/^data:image\/(png|jpg);base64,/, "")
                                            },
                                            o = postUrl.split("https://productconfigurator.virtualsaleslab.com/");
                                        o[o.length - 1] = o[o.length - 1].replace(/\-/g, "https://productconfigurator.virtualsaleslab.com/");
                                        var a = o.join("https://productconfigurator.virtualsaleslab.com/");
                                        n(postUrl, t, function(e) {
                                            if (200 != i.status) return void alert("An error occured during save. If this happens again, please send an email to info@virtualsaleslab.com");
                                            this.$emit("posted", i.responseText);
                                            var t = t;
                                            t && t("send", "event", "contactform", "submitted");
                                            var n = JSON.parse(i.responseText);
                                            a = n.url || a, this.redirectAfterPost ? window.location.assign(a) : (this.meta.wasSubmitted = !0, this.resultUrl = a), document.body.classList.remove("saving")
                                        }.bind(r))
                                    }, {
                                        resize: !0
                                    }), !1
                                }
                            },
                            isRequired: function(e) {
                                return -1 !== (this.opts.requiredFields || ["name", "email", "zip", "city", "phone"]).indexOf(e)
                            },
                            isUsed: function(e) {
                                return -1 !== (this.opts.usedFields || ["name", "email", "street", "number", "zip", "city", "phone", "remarks"]).indexOf(e)
                            }
                        },
                        computed: {
                            redirectAfterPost: function() {
                                return this.opts.redirectAfterPost
                            },
                            wasSubmitted: function() {
                                return this.meta.wasSubmitted || window.serverParameters
                            },
                            canOverwrite: function() {
                                return this.wasSubmitted && (this.meta.allowEdit || this.meta.loginRequired && t)
                            }
                        },
                        locales: {
                            en: {
                                name: "Name",
                                firstName: "First name",
                                mail: "email@domain.com",
                                street: "Street",
                                nr: "N°",
                                zip: "ZIP",
                                city: "City",
                                phone: "Phone number",
                                savebutton: "Send",
                                remarks: "Remarks"
                            },
                            nl: {
                                name: "Naam",
                                firstName: "Voornaam",
                                mail: "email@domain.com",
                                street: "Straat",
                                nr: "Nr",
                                zip: "Postcode",
                                city: "Stad",
                                phone: "Telefoonnummer",
                                savebutton: "Verzend",
                                remarks: "Opmerkingen"
                            },
                            de: {
                                name: "Name",
                                firstName: "Vorname",
                                mail: "email@domain.com",
                                street: "Strasse",
                                nr: "N°",
                                zip: "Postleitzahl",
                                city: "Stadt",
                                phone: "Telefonnummer",
                                savebutton: "Senden",
                                remarks: "Bemerkungen"
                            },
                            fr: {
                                name: "Nom",
                                firstName: "Prénom",
                                mail: "email@domain.com",
                                street: "Rue",
                                nr: "N°",
                                zip: "Code Postal",
                                city: "Localité",
                                phone: "N° de téléphone",
                                savebutton: "Envoyer",
                                remarks: "Remarques"
                            },
                            it: {
                                name: "Nome",
                                firstName: "Prenome",
                                mail: "email@domain.com",
                                street: "Strada",
                                nr: "N°",
                                zip: "ZIP",
                                city: "Città",
                                phone: "N° di telephono",
                                savebutton: "Invia",
                                remarks: "Osservazioni"
                            },
                            pt: {
                                name: "Nome",
                                firstName: "Pr. nome",
                                mail: "email@domain.com",
                                street: "Rua",
                                nr: "N°",
                                zip: "ZIP",
                                city: "Cidade",
                                phone: "N° de telefone",
                                savebutton: "Enviar",
                                remarks: "Observações"
                            },
                            ru: {
                                name: "Фамилия",
                                firstName: "Имя",
                                mail: "email@domain.com",
                                street: "Улица",
                                nr: "H.P.",
                                zip: "почтовый индекс",
                                city: "город",
                                phone: "телефон",
                                savebutton: "Отправить",
                                remarks: "замечания"
                            }
                        }
                    })), this.componentBuilder.register("button", r.extend({
                        props: ["opts"],
                        data: function() {
                            return this.$parent.$data
                        },
                        template: '\n                    <div style="color: white">\n                        <a class="btn btn-primary" v-on:click=\'executeAction($event)\'>\n                            <i class="fa {{icon}}" aria-hidden="true" style="color: white"></i>\n                            {{label}}\n                        </a>\n                    </div>',
                        computed: {
                            icon: function() {
                                return this.opts.icon || "fa-camera"
                            },
                            label: function() {
                                return this.opts.label || "Take a screenshot"
                            }
                        },
                        methods: {
                            screenshot: function() {
                                var t = this;
                                e.screenshotAsBase64EncodedJpg(function(e) {
                                    fetch(e).then(function(e) {
                                        return e.blob()
                                    }).then(function(n) {
                                        switch (t.opts.action) {
                                            case "screenshot":
                                                var r = document.createElement("a");
                                                r.href = URL.createObjectURL(n), r.download = "snapshot.html", r.click();
                                                break;
                                            case "print":
                                                var i = '<!DOCTYPE html>\n                                                <html>\n                                                <head>\n                                                  <meta charset="utf-8">\n                                                  <meta name="viewport" content="width=device-width">\n                                                  <title>Snapshot</title>\n                                                </head>\n                                                <body>\n                                                    <img src="' + e + '" style="width: 100%; height: 100%">\n                                                </body>\n                                                </html>',
                                                    o = document.createElement("iframe");
                                                document.body.appendChild(o), o.contentWindow.document.open(), o.contentWindow.document.write(i), o.contentWindow.document.close(), o.onload = function() {
                                                    o.contentWindow.document.execCommand("print", !1, null) || (o.contentWindow.focus(), o.contentWindow.print()), document.body.removeChild(o)
                                                }
                                        }
                                    })
                                })
                            },
                            executeAction: function(e) {
                                var t = this;
                                switch (this.opts.action) {
                                    case "screenshot":
                                    case "print":
                                        this.screenshot();
                                        break;
                                    case "fn":
                                        if (!this.opts.fn) return void alert("No fn defined in opts");
                                        var n = {
                                                event: e
                                            },
                                            r = ["event"];
                                        Object.keys(this.$parent.$data).forEach(function(e) {
                                            n[e] = t.$parent.$data[e], r.push(e)
                                        }), r = r.map(function(e) {
                                            return e + "=__pars__['" + e + "']"
                                        });
                                        var i = " var " + r.join(",") + ";" + this.opts.fn + ";",
                                            o = new Function("__pars__", i);
                                        console.log(i), o(n)
                                }
                            }
                        }
                    })), this.componentBuilder.register("polygon", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            return {
                                currentKeyIndex: 0
                            }
                        },
                        template: '\n            <div class="vsl-input-container vsl-polygon">\n                <vsl-polygon-editor \n                    :vertices="currentVertices" :key="currentKey" \n                    :view-box="opts.viewBox || 500 500 -500 -500" \n                    @change="onChange"\n                    :otherpolygons="otherPolygons"\n                    :readonly="opts.readOnly"\n                    >\n                </vsl-polygon-editor>\n                <template v-if="allKeys.length>1">\n                    <label> {{$t(opts.label)}} </label>\n                    <select v-model="currentKeyIndex" @change.stop @input.stop>\n                        <option v-for="k in allKeys" :value="$index">{{k}}</option>\n                    </select>\n                </template>\n            </div>\n            ',
                        methods: {
                            onChange: function(e) {
                                this.$dispatch("change", e)
                            }
                        },
                        computed: {
                            allKeys: function() {
                                return [this.key].concat(this.opts.otherpolygonkeys || [])
                            },
                            allPolygons: function() {
                                var e = this,
                                    t = (this.opts.otherpolygonkeys || []).map(function(t) {
                                        return e.$parent.$get(t)
                                    });
                                return [this.value].concat(t)
                            },
                            currentKey: function() {
                                return this.allKeys[this.currentKeyIndex]
                            },
                            otherPolygons: function() {
                                var e = this;
                                return this.allPolygons.filter(function(t, n) {
                                    return n !== e.currentKeyIndex
                                })
                            },
                            currentVertices: function() {
                                return this.allPolygons[this.currentKeyIndex]
                            }
                        }
                    })), this.componentBuilder.register("floorplan", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            return {
                                currentPolyIndex: 0,
                                newPolygonLabel: "",
                                newPolygonLayer: "",
                                vertices: [],
                                otherPolygons: [],
                                hiddenLayers: []
                            }
                        },
                        template: '\n            <div class="vsl-input-container vsl-polygon">\n                <vsl-polygon-editor \n                    :vertices="vertices" :key="key+\'[\'+currentPolyIndex+\'].vertices\'" \n                    :view-box="opts.viewBox || 500 500 -500 -500" \n                    :otherpolygons="otherPolygons"\n                    @change.stop\n                    @valuechanged.stop\n                    >\n                </vsl-polygon-editor>\n                <div class="input-line">\n                <h4>Rooms</h4>\n                    <table class="rooms">\n                        <thead>\n                           <tr>\n                                <th>{{opts.floorLabel ||\'Floor\'}}</th>\n                                <th>{{opts.roomLabel ||\'Room name\'}}</th>\n                                <th><i class="fa fa-pencil" aria-hidden="true"></i></th>\n                                <th><i class="fa fa-trash-o" aria-hidden="true"></i></th>\n                           </tr>\n                        </thead>\n                        <tbody>\n                        <tr v-for="room in value" :class="{selected: currentPolyIndex == room.index}">\n                            <td><input type="text" list="roomlayers" v-model="room.layer" @change.stop="cleanupData()" @input.stop /></td>\n                            <td><input type="text" v-model="room.label" @change.stop="cleanupData()" @input.stop  /></td>\n                            <td><a href="#" @click.stop="selectRoom(room.index)"><i class="fa fa-pencil" aria-hidden="true"></i></a></td>\n                            <td><a href="#" @click.stop="removeRoom(room.index)"><i class="fa fa-trash-o" aria-hidden="true"></i></a></td>\n                        </tr>\n                        <tr>\n                          <td><input type="text" list="roomlayers" class="new-polygon-layer" v-model="newPolygonLayer" :placeholder="(opts.floorLabel ||\'Floor\') + \' 1\'" @change.stop @input.stop /></td>\n                          <td><input type="text" v-model="newPolygonLabel" :placeholder="(opts.roomLabel || \'Room name\') + \'1\'" @change.stop @input.stop  /></td>\n                          <td><a href="#" @click.stop="addPolygon"><i class="fa fa-plus" aria-hidden="true"></i></a></td>\n                          <td><a href="#" @click.stop="resetAdd"><i class="fa fa-trash" aria-hidden="true"></i></a></td>\n                        </tr>\n                        </tbody>\n                    </table>\n                    <datalist id="roomlayers">\n                        <option v-for="layer in layers" :value="layer">\n                    </datalist>\n                    <template v-if="layers.length">\n                        <h4>Floors</h4>\n                        <table class="rooms">\n                            <thead>\n                                <tr>\n                                    <th>Layer</th>\n                                    <th><i class="fa fa-eye" aria-hidden="true"></i></th>\n                                    <th><i class="fa fa-trash-o" aria-hidden="true"></i></th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                                <tr v-for="layer in layers" :class="{selected: currentPoly().layer == layer}">\n                                    <td><input type="text" list="roomlayers" :value="layer" @change.stop="changeLayer(layer,$event)" @input.stop /></td>\n                                    <td><a href="#" @click.stop="toggleLayerVisibility(layer)">\n                                            <i v-if="hiddenLayers.indexOf(layer)==-1" class="fa fa-eye" aria-hidden="true"></i>\n                                            <i v-else class="fa fa-eye-slash" aria-hidden="true"></i>\n                                            </a></td>\n                                    <td><a href="#" @click.stop="removeLayer(layer)"><i class="fa fa-trash-o" aria-hidden="true"></i></a></td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </template>\n                </div>\n            </div>\n            ',
                        methods: {
                            onChange: function(e) {
                                this.currentPoly().vertices = this.vertices, this.$dispatch("valuechanged", this.key, this.value)
                            },
                            toggleLayerVisibility: function(e) {
                                var t = this.hiddenLayers.indexOf(e);
                                t > -1 ? this.hiddenLayers.splice(t, 1) : this.hiddenLayers.push(e), this.setCurrentPoly()
                            },
                            changeLayer: function(e, t) {
                                this.value.forEach(function(n) {
                                    n.layer == e && (n.layer = t.target.value)
                                }), this.cleanupData()
                            },
                            removeLayer: function(e, t) {
                                for (var n = this.value.length - 1; n >= 0; n--) this.value[n].layer === e && this.removeRoom(n);
                                this.cleanupData()
                            },
                            resetAdd: function() {
                                this.newPolygonLayer = "", this.newPolygonLabel = ""
                            },
                            addPolygon: function(e) {
                                var t = this,
                                    n = {
                                        index: this.value.length,
                                        layer: this.newPolygonLayer,
                                        label: this.newPolygonLabel,
                                        vertices: [
                                            [50, 350],
                                            [50, 50],
                                            [350, 50],
                                            [350, 350]
                                        ]
                                    };
                                this.value.push(n), this.cleanupData(), this.currentPolyIndex = n.index, this.vertices = n.vertices, this.$dispatch("valuechanged", this.key, this.value), this.newPolygonLabel = "", this.newPolygonLayer = "", r.nextTick(function() {
                                    t.$el.querySelector(".zoom-button").click(), t.$el.querySelector(".new-polygon-layer").focus()
                                }), this.setCurrentPoly()
                            },
                            setCurrentPoly: function(e) {
                                var t = this;
                                this.vertices = this.currentPoly().vertices, this.otherPolygons = this.value.filter(function(e) {
                                    return e.index !== t.currentPolyIndex && -1 === t.hiddenLayers.indexOf(e.layer)
                                }).map(function(e) {
                                    return e.vertices
                                })
                            },
                            currentPoly: function() {
                                var e = this,
                                    t = this.value.filter(function(t) {
                                        return t.index === e.currentPolyIndex
                                    })[0];
                                return t = t || {
                                    index: this.currentPolyIndex,
                                    label: "unknown",
                                    layer: "unknown",
                                    vertices: []
                                }
                            },
                            selectRoom: function(e) {
                                this.currentPolyIndex = e, this.setCurrentPoly()
                            },
                            removeRoom: function(e) {
                                this.value.splice(e, 1), this.value.forEach(function(e, t) {
                                    return e.index = t
                                }), this.currentPolyIndex = Math.max(this.currentPolyIndex, 0), this.setCurrentPoly()
                            },
                            cleanupData: function() {
                                this.value.sort(function(e, t) {
                                    return e.layer + "////" + e.label > t.layer + "////" + t.label
                                }), this.value.forEach(function(e, t) {
                                    return e.index = t
                                })
                            }
                        },
                        computed: {
                            allKeys: function() {
                                return this.value.map(function(e) {
                                    return e.index
                                })
                            },
                            currentKey: function() {
                                return this.currentPolyIndex
                            },
                            layers: function() {
                                return this.value.map(function(e) {
                                    return e.layer
                                }).filter(function(e, t, n) {
                                    return n.indexOf(e) === t
                                })
                            }
                        },
                        watch: {
                            vertices: function(e, t) {
                                this.currentPoly().vertices = e, this.$dispatch("valuechanged", this.key, this.value)
                            }
                        },
                        ready: function() {
                            var e = this;
                            this.setCurrentPoly(), r.nextTick(function() {
                                e.$el.querySelector(".zoom-button").click(), e.$el.querySelector(".new-polygon-layer").focus()
                            })
                        }
                    })), this.componentBuilder.register("imagesuploader", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            return {
                                currentImageIndex: this.value.length - 1,
                                isLoading: !1,
                                prevMouseEvent: null,
                                eventListeners: [],
                                groundMesh: null
                            }
                        },
                        template: '\n            <div class="vsl-input-container vsl-images-uploader">\n                <div class="input-line">\n                    <h4>Pictures</h4>\n                    <div v-if="isLoading">Loading...</div>\n                    <div v-else><input type="file" multiple v-el:file-input @change.stop="addFile" @input.stop accept="image/*" /></div>\n\n                    <div class="piclist">\n                        <template  v-if="currentPic">\n                            <select :value="currentImageIndex" v-model="currentImageIndex" @change.stop @input.stop="selectPic($event.target.value)" style="width:15em" >\n                                <option v-for="pic in value" :value="pic.index">{{pic.label}}</option>\n                            </select>\n                            <div class="pano-preview" @click.stop="selectPic(currentPic.index)" :style="picStyle(currentPic)" \n                                    @mousedown.stop="prevMouseEvent=$event"\n                                    @mousemove="changeRotation(currentPic,$event)"\n                                    @mouseup="commitRotation(currentPic,$event)"\n                                    @mouseleave="commitRotation(currentPic,$event)"\n                            >\n                            <div style="width:1px;height:15em;position:absolute;left:50%;border:1px dashed purple;pointer-events: none;"></div>\n                            </div>\n                            <input type="text" v-model="value[currentImageIndex].label" @change.stop="reOrder" @input.stop/>\n                            <a href="#" @click.stop="removePic(currentPic.index)"><i class="fa fa-trash-o" aria-hidden="true"></i></a>\n                            <a href="#" @click.stop="lookFromPic(currentPic)"><i class="fa fa-eye" aria-hidden="true"></i></a>\n                            <label>Floor</label>\n                            <input type="range" min="0" max="4" step="1" v-model="value[currentImageIndex].position[2]"  number @input.stop="changePosition" @change.stop style="width:6em"/>\n                            <input type="number" min="0" max="4" step="1" v-model="value[currentImageIndex].position[2]"  number @input.stop="changePosition" @change.stop/>\n                            <br/>\n                            <label>Cam height</label>\n                            <input type="range" min="100" max="300" step="5" v-model="value[currentImageIndex].camHeight" :value="value[currentImageIndex].camHeight" number @input.stop="changeCamHeight" @change.stop style="width:6em"/>\n                            <input type="number" min="100" max="300" step="5" v-model="value[currentImageIndex].camHeight" :value="value[currentImageIndex].camHeight" number @input.stop="changeCamHeight" @change.stop/>\n                        </template>\n                    </div>\n                </div>\n            </div>\n            ',
                        attached: function() {
                            e.renderer.domElement.addEventListener("mousedown", this.rayCastMouseDown), e.renderer.domElement.addEventListener("mousemove", this.rayCastMouseMove), e.renderer.domElement.addEventListener("mouseup", this.rayCastMouseUp), e.renderer.domElement.addEventListener("mouseleave", this.rayCastMouseUp);
                            var t = new i.PlaneBufferGeometry(1e4, 1e4),
                                n = new i.Mesh(t);
                            n.rotation.x -= Math.PI / 2, n.position.y -= 180, n.visible = !1, e.scene.add(n);
                            var r = new i.TorusBufferGeometry(100, 5, 10, 15),
                                o = new i.Mesh(r);
                            o.rotation.x = -Math.PI / 2, o.visible = !1, e.scene.add(o), this.groundMesh = n, this.cursorMesh = o, this.draggingIndex = -1
                        },
                        detached: function() {
                            e.renderer.domElement.removeEventListener("mousedown", this.rayCastMouseDown), e.renderer.domElement.removeEventListener("mousemove", this.rayCastMouseMove), e.renderer.domElement.removeEventListener("mouseup", this.rayCastMouseUp), e.renderer.domElement.removeEventListener("mouseleave", this.rayCastMouseUp), e.scene.remove(this.groundMesh), e.scene.remove(this.cursorMesh)
                        },
                        methods: {
                            rayCastPositionOnPlane: function(t) {
                                var n = new i.Raycaster,
                                    r = new i.Vector2;
                                r.x = t.clientX / o.domElement.clientWidth * 2 - 1, r.y = -t.clientY / o.domElement.clientHeight * 2 + 1, n.setFromCamera(r, e.camera), this.groundMesh.visible = !0;
                                var a = n.intersectObject(this.groundMesh);
                                if (this.groundMesh.visible = !1, !a.length) return null;
                                var s = this.groundMesh.worldToLocal(a[0].point.clone());
                                if (s.y *= -1, this.draggingIndex > -1) return {
                                    newIndex: this.draggingIndex,
                                    local: s
                                };
                                var c = this.value.reduce(function(e, t) {
                                    var n = (new i.Vector3).fromArray(t.position),
                                        r = n.distanceToSquared(s);
                                    return r >= e.distanceSQ ? e : {
                                        index: t.index,
                                        distanceSQ: r
                                    }
                                }, {
                                    index: -1,
                                    distanceSQ: 1e4
                                }).index;
                                return c > -1 || this.cursorMesh.scale.setScalar(1), {
                                    newIndex: c,
                                    local: s
                                }
                            },
                            rayCastMouseDown: function(t) {
                                var n = new i.Raycaster,
                                    r = new i.Vector2;
                                r.x = t.clientX / e.renderer.domElement.clientWidth * 2 - 1, r.y = -t.clientY / e.renderer.domElement.clientHeight * 2 + 1, n.setFromCamera(r, e.camera);
                                var o, a = e.scene.getObjectByName("panos"),
                                    s = n.intersectObjects(a.children.map(function(e) {
                                        return e.children[1]
                                    }));
                                if (s.length) {
                                    this.cursorMesh.visible = !0, this.cursorMesh.position.copy(s[0].point), this.cursorMesh.position.y = -170;
                                    var c = e.camera.localToWorld(new i.Vector3(0, 0, 0));
                                    if (o = s[0].object.localToWorld(new i.Vector3(0, 0, 0)), c.distanceToSquared(o) < 1e4) {
                                        var l = a.children.indexOf(s[0].object.parent);
                                        this.lookFromPic(this.value[l]), s.shift()
                                    }
                                }
                                if (s.length) {
                                    this.currentImageIndex = a.children.indexOf(s[0].object.parent), o = s[0].object.localToWorld(new i.Vector3(0, 0, 0)), this.groundMesh.position.y = o.y;
                                    var h = this.rayCastPositionOnPlane(t);
                                    if (h) {
                                        e.controls.enabled = !1, this.draggingIndex = this.currentImageIndex;
                                        var u = e.scene.getObjectByName("panos").children[this.currentImageIndex].position;
                                        u.x = h.local.x, u.y = h.local.y, t.preventDefault()
                                    }
                                }
                            },
                            rayCastMouseMove: function(t) {
                                var n = this.rayCastPositionOnPlane(t);
                                if (n && this.draggingIndex > -1) {
                                    var r = e.scene.getObjectByName("panos").children[this.currentImageIndex].position;
                                    r.x = n.local.x, r.y = n.local.y, this.cursorMesh.position.x = n.local.x, this.cursorMesh.position.z = n.local.y, t.preventDefault()
                                }
                            },
                            rayCastMouseUp: function(t) {
                                if (-1 !== this.draggingIndex) {
                                    e.controls.enabled = !0, this.draggingIndex = -1;
                                    var n = e.scene.getObjectByName("panos").children[this.currentImageIndex].position;
                                    this.currentPic.position[0] = n.x, this.currentPic.position[1] = n.y, this.changePosition()
                                }
                            },
                            addFile: function(e) {
                                var t = this.$els.fileInput,
                                    n = t.files.length;
                                this.isLoading = !0;
                                for (var r = 0; r < t.files.length; r++) ! function(e, t, r) {
                                    if (e.type.match(/image.*/)) {
                                        var i = e.name,
                                            o = new FormData;
                                        o.append("id", id), o.append("image", e, e.name);
                                        var a = new XMLHttpRequest;
                                        a.open("POST.html", postImageUrl), a.onload = function(e) {
                                            if (200 === a.status) {
                                                var r = JSON.parse(a.responseText),
                                                    o = {
                                                        label: i,
                                                        url: r.url,
                                                        index: t.value.length,
                                                        rotation: 0,
                                                        position: [0, 0, 0],
                                                        camHeight: 145
                                                    };
                                                Object.assign(o, t.opts.defaultFileOpts || {}), t.value.push(o), t.currentImageIndex = o.index, 0 === --n && (t.reOrder(), t.resetAdd(), t.isLoading = !1, t.$dispatch("valuechanged", t.key, t.value))
                                            } else alert("Unable to send the file " + i + " to the server; please try again")
                                        }, a.send(o)
                                    }
                                }(t.files[r], this, t.files.length)
                            },
                            lookFromPic: function(t) {
                                var n = e.scene.getObjectByName("panos").children[t.index].children[0].localToWorld(new i.Vector3(0, 0, 0));
                                e.controls.object.position.set(n.x, n.y, n.z - 10), e.controls.target.set(n.x, n.y, n.z), e.controls.update()
                            },
                            changeRotation: function(e, t) {
                                if (t.buttons) {
                                    this.prevMouseEvent = this.prevMouseEvent || t;
                                    var n = t.clientX - this.prevMouseEvent.clientX;
                                    n /= 2 * t.target.clientWidth, e.rotation += n, e.rotation < 1 && (e.rotation += 1), e.rotation > 1 && (e.rotation -= 1), t.preventDefault(), this.prevMouseEvent = t
                                }
                            },
                            commitRotation: function(e, t) {
                                this.prevMouseEvent = null, this.$dispatch("valuechanged", this.key + "[" + e.index + "].rotation", e.rotation), t.preventDefault()
                            },
                            changePosition: function() {
                                this.$dispatch("valuechanged", this.key + "[" + this.currentImageIndex + "].position", this.currentPic.position)
                            },
                            changeCamHeight: function() {
                                this.$dispatch("valuechanged", this.key + "[" + this.currentImageIndex + "].camHeight", this.currentPic.camHeight)
                            },
                            resetAdd: function() {
                                r.nextTick(function() {
                                    this.$els.fileInput.value = ""
                                }.bind(this))
                            },
                            selectPic: function(e) {
                                this.currentImageIndex = e, this.cursorMesh.position.x = this.value[e].position[0], this.cursorMesh.position.z = this.value[e].position[1]
                            },
                            removePic: function(e) {
                                this.value.splice(e, 1), this.value.forEach(function(e, t) {
                                    e.index = t
                                }), this.currentImageIndex = Math.min(this.value.length - 1, this.currentImageIndex), this.$dispatch("valuechanged", this.key, this.value), this.cursorMesh.visible = !1
                            },
                            picStyle: function(e) {
                                return {
                                    backgroundImage: 'url("' + e.url + '")',
                                    backgroundSize: "cover",
                                    backgroundPositionX: 30 * e.rotation + "em",
                                    width: "15em",
                                    height: "15em"
                                }
                            },
                            reOrder: function() {
                                var e = this.currentPic;
                                this.value.sort(function(e, t) {
                                    return e.label > t.label
                                }), this.value.forEach(function(e, t) {
                                    e.index = t
                                }), this.currentImageIndex = e.index, this.$dispatch("valuechanged", this.key, this.value)
                            }
                        },
                        computed: {
                            currentPic: function() {
                                return this.currentImageIndex < 0 ? null : this.value[this.currentImageIndex]
                            }
                        }
                    })), this.componentBuilder.register("backgroundpic", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            var e = this.$parent.$data,
                                t = e.homography || {
                                    position: {
                                        x: .5,
                                        y: .5
                                    },
                                    rotation: {
                                        x: 0,
                                        y: 0
                                    },
                                    scale: .4,
                                    imageSrc: null
                                };
                            return e.homography = t, e.homography.available = !0, e.homography.enabled = !0, {
                                homography: t,
                                originalHomographyJSON: JSON.stringify(t)
                            }
                        },
						// Input name change
                        template: '<template v-if="allowPicture"><input name="imgUploader" id="uploader" type="file" @change="readFile" class="hidden" accept="image/*"/><label for="uploader" class="btn btn-primary">Foto auswählen</label></template><div class="homography-container"><div class="btn-group vsl-perspective-scaler"> <a href="#" class="btn btn-primary" @click.prevent="scalePlane(0.97)">  <i class="fa fa-compress" aria-hidden="true"></i></a> <a href="#" class="btn btn-primary" @click.prevent="resetPlane()">  <i class="fa fa-refresh" aria-hidden="true"></i></a> <a href="#" class="btn btn-primary" @click.prevent="scalePlane(1/0.97)">  <i class="fa fa-expand" aria-hidden="true"></i></a></div><div style="width:50vw;position:fixed;bottom:4em;left:25vw;background-color:white;height:3em;border-radius:2px" >\n                <i class="fa fa-arrow-left" style="position:fixed;left:25.5vw;bottom:5em"/>\n                <input type="range" style="position:fixed;width:46vw;left:27vw;bottom:5em" :value="homography.rotation.y" \n                    @input="updateRotation({y:parseFloat($event.target.value),x:homography.rotation.x})" :min="-Math.PI / 2" :max="Math.PI / 2" step="0.01" \n                    @mouseenter="homography.gridsVisible = true" @mouseleave="homography.gridsVisible = false"/>\n                <i class="fa fa-arrow-right" style="position:fixed;right:25.5vw;bottom:5em"/>\n                </div><div style="width:3em;position:fixed;top:25vh;right:1em;background-color:white;height:50vh;border-radius:2px" >\n                <i class="fa fa-arrow-up" style="position:fixed;right:2em;top:25.1vh"/>\n                <input type="range" :value="homography.rotation.x" @input="updateRotation({x:parseFloat($event.target.value),y:homography.rotation.y})" :min="-Math.PI / 2" :max="Math.PI / 2" step="0.01" \n                    style="width:46vh;position:fixed;right:2.5em;transform-origin: 100% 50%;transform:rotate(-90deg)"  @mouseenter="homography.gridsVisible = true" @mouseleave="homography.gridsVisible = false"/>\n                <i class="fa fa-arrow-down" style="position:fixed;right:2em;bottom:25.1vh"/>\n                </div>',
                        ready: function() {
                            this.$dispatch("valuechanged", "homography.enabled", !0)
                        },
                        attached: function() {
                            o.domElement.addEventListener("mousemove", this.onMouseMove), o.domElement.addEventListener("mousedown", this.onMouseDown), o.domElement.addEventListener("mouseup", this.onMouseUp), o.domElement.addEventListener("mouseleave", this.onMouseUp), o.domElement.addEventListener("touchmove", this.onTouchMove), o.domElement.addEventListener("touchstart", this.onMouseDown), o.domElement.addEventListener("touchend", this.onMouseUp), o.domElement.style.cursor = "move"
                        },
                        detached: function() {
                            o.domElement.removeEventListener("mousemove", this.onMouseMove), o.domElement.removeEventListener("mousedown", this.onMouseDown), o.domElement.removeEventListener("mouseup", this.onMouseUp), o.domElement.removeEventListener("mouseleave", this.onMouseUp), o.domElement.removeEventListener("touchmove", this.onTouchMove), o.domElement.removeEventListener("touchstart", this.onMouseDown), o.domElement.removeEventListener("touchend", this.onMouseUp), o.domElement.style.cursor = null
                        },
                        methods: {
                            onMouseMove: function(e) {
                                if (this.homography.enabled && e.buttons) {
                                    var t = e.target;
                                    this.updatePosition({
                                        x: e.clientX / t.clientWidth / 2 + .25,
                                        y: e.clientY / t.clientHeight / 2 + .25
                                    })
                                }
                            },
                            onMouseDown: function(e) {
                                this.homography.enabled && (this.homography.gridsVisible = !0, this.$dispatch("valuechanged", "homography", this.homography), e.preventDefault())
                            },
                            onMouseUp: function(e) {
                                this.homography.enabled && (this.homography.gridsVisible = !1, this.$dispatch("valuechanged", "homography", this.homography), e.preventDefault())
                            },
                            onTouchMove: function(e) {
                                if (this.homography.enabled && e.touches.length) {
                                    var t = e.target,
                                        n = e.touches[0];
                                    this.updatePosition({
                                        x: n.clientX / t.clientWidth / 2 + .25,
                                        y: n.clientY / t.clientHeight / 2 + .25
                                    })
                                }
                            },
							// readFile: function(e) {
							// 	var files = e.target.files || e.dataTransfer.files;
							// 	this.createImage(files[0]);
							// },
							// My function
							createImage(file) {
								var image = new Image();
								var reader = new FileReader();
								var vm = this;

								reader.onload = (e) => {
									vm.image = e.target.result;
									vm.$dispatch("valuechanged", "homography.imageSrc", vm.image)
								};
								reader.readAsDataURL(file);
							},
							// MyFunction END
                            // Was here 		   
                            readFile: function(e) {
                                var t = this,
                                    n = e.target.files[0];
                                if (n.type.match(/image.*/)) {
                                    var r = n.name,
                                        i = new FormData;
                                    i.append("id", id), i.append("image", n, r);
                                    var o = new XMLHttpRequest;
                                    o.open("POST", postImageUrl), o.onload = function(e) {
                                        if (200 === o.status) {
											console.log(o.responseText)		;				   
                                            var n = JSON.parse(o.responseText),
                                                i = n.url;
                                            t.$dispatch("valuechanged", "homography.imageSrc", i)
                                        } else {
										var n = JSON.parse(o.responseText),
										i = n.url;
										t.$dispatch("valuechanged", "homography.imageSrc", r)
									}
									
									//alert("Unable to send the file " + r + " to the server; please try again")
                                    }, o.send(i)
                                }
                            },
                            updatePosition: function(e) {
                                this.homography.position.x = e.x, this.homography.position.y = e.y, this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            updateRotation: function(e) {
                                this.homography.rotation.x = e.x, this.homography.rotation.y = e.y, this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            updateScale: function(e) {
                                this.homography.scale = e, this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            startDrag: function() {
                                this.homography.gridsVisible = !0, this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            stopDrag: function() {
                                this.homography.gridsVisible = !1, this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            scalePlane: function(e) {
                                this.updateScale(this.homography.scale * e), this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            resetPlane: function() {
                                var e = JSON.parse(this.originalHomographyJSON);
                                e.enabled = !0, e.imageSrc = this.homography.imageSrc, Object.assign(this.homography, e), this.$dispatch("valuechanged", "homography", this.homography)
                            },
                            movePlane: function(e, t) {
                                this.updatePosition({
                                    x: this.homography.position.x + e,
                                    y: this.homography.position.y + t
                                })
                            }
                        },
                        watch: {},
                        computed: {
                            allowPicture: function() {
                                return "always" === this.$parent.meta.allowPicture || this.$parent.meta.wasSubmitted
                            }
                        }
                    })), this.componentBuilder.register("positioner", r.extend({
                        props: ["value", "opts", "key"],
                        data: function() {
                            return {}
                        },
                        template: '\n                    <div class="vsl-input-container vsl-positioner">\n                      <template v-if="element">\n                       <h4>Positie {{element.elementId}}</h4>\n                       <table>\n                         <tbody>\n                            <tr>\n                                <td>\n                                   <input  type="number" :min="0" :max="bboxSize.y-size.y" step="1" number \n                                      :value="Math.round(bboxSize.y/2-position.y-size.y/2)"\n                                      @change.stop="setY(-$event.target.value+bboxSize.y/2-size.y/2)" @input.stop="" /> \n                                </td>\n                                <td rowspan="5" colspan="3" style="border: 1px solid black;position: relative">\n                                    <div style="position:absolute;top:33.33%;left:33.33%;width:33.33%;height:33.33%;border: 1px dashed gray" />\n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>\n                                   <input :value="size.y" type="number" id="height" :min="minSize.y" :max="maxSize.y" step="1" number\n                                      @change.stop="setHeight($event.target.value)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>\n                                    <input type="number" :min="0" :max="bboxSize.y-size.y" step="1" number\n                                      :value="Math.round(bboxSize.y/2+position.y-size.y/2)" \n                                      @change.stop="setY($event.target.value-bboxSize.y/2+size.y/2)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>&nbsp;</td>\n                                <td>\n                                    <input type="number" :min="0" :max="bboxSize.x-size.x" step="1" number \n                                        :value="Math.round(bboxSize.x/2+position.x-size.x/2)"\n                                      @change.stop="setX($event.target.value-bboxSize.x/2+size.x/2)" @input.stop="" /> \n                                </td>\n                                <td>\n                                   <input :value="size.x" type="number" :min="minSize.x" :max="maxSize.x" step="1" number\n                                      @change.stop="setWidth($event.target.value)" @input.stop="" /> \n                                </td>\n                                <td>\n                                   <input type="number" :min="0" :max="bboxSize.x-size.x" step="1" number \n                                        :value="Math.round(bboxSize.x/2-position.x-size.x/2)" \n                                        @change.stop="setX(-$event.target.value+bboxSize.x/2-size.x/2)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                         </tbody>\n                        </table>\n                        <template v-if="element.float">\n                            <label>Rotatie</label>\n                            <input type="range" min="0" max="360" v-model="rotation" @change.stop @input.stop step="5"/>\n                        </template>\n                        </template>\n                    </div>',
                        computed: {
                            element: function() {
                                if (this.value && this.value.length) {
                                    var e = this.value[this.value.length - 1];
                                    if (n.activeDropTargetIds.some(function(t) {
                                            return t === e.dropTargetId
                                        })) return e
                                }
                                return null
                            },
                            position: function() {
                                return (new i.Vector2).fromArray(this.element.position)
                            },
                            size: function() {
                                return new i.Vector2(this.element.width, this.element.height)
                            },
                            bbox: function() {
                                var e = this,
                                    t = n.dropTargets.filter(function(t) {
                                        return t.name === e.element.dropTargetName
                                    })[0],
                                    r = (t.grid || []).filter(function(t) {
                                        return t.containsPoint(e.position)
                                    });
                                return r.length ? r[0] : t.localBoundingBox
                            },
                            bboxSize: function() {
                                return this.bbox.getSize()
                            },
                            bboxCenter: function() {
                                return this.bbox.getCenter()
                            },
                            minSize: function() {
                                return {
                                    x: this.element.minWidth > 0 ? this.element.minWidth : this.bboxSize.width - this.element.minWidth,
                                    y: this.element.minHeight > 0 ? this.element.minHeight : this.bboxSize.height - this.element.minHeight
                                }
                            },
                            maxSize: function() {
                                return {
                                    x: Math.min(this.bboxSize.width - 1, this.element.maxWidth > 0 ? this.element.maxWidth : this.bboxSize.width - this.element.maxWidth),
                                    y: Math.min(this.bboxSize.height - 1, this.element.maxHeight > 0 ? this.element.maxHeight : this.bboxSize.height - this.element.maxHeight)
                                }
                            },
                            rotation: {
                                get: function() {
                                    return Math.round(180 * this.element.rotation[2] / Math.PI)
                                },
                                set: function(e) {
                                    e = e / 180 * Math.PI, this.element.rotation[2] = e, this.$dispatch("valuechanged", this.key + "[" + (this.value.length - 1) + "].rotation[2]", e)
                                }
                            }
                        },
                        methods: {
                            setY: function(e) {
                                e += this.bboxCenter.y, this.element.position[1] = e, this.$dispatch("valuechanged", this.key + "[" + (this.value.length - 1) + "].position[1]", e)
                            },
                            setHeight: function(e) {
                                this.element.height = e, this.$dispatch("valuechanged", this.key + "[" + (this.value.length - 1) + "].height", e)
                            },
                            setX: function(e) {
                                e += this.bboxCenter.x, this.element.position[0] = e, this.$dispatch("valuechanged", this.key + "[" + (this.value.length - 1) + "].position[0]", e)
                            },
                            setWidth: function(e) {
                                this.element.width = e, this.$dispatch("valuechanged", this.key + "[" + (this.value.length - 1) + "].width", e)
                            }
                        }
                    }))
                }
                return e.prototype.buildClass = function(e, t, n, r) {
                    return this.componentBuilder.getVueClass(e, t, n, r)
                }, e
            }();
        e.UIBuilder = c
    }(c || (c = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r;
    ! function(e) {
        function t(e, t) {
            var n = e.extend({
                props: ["vertices", "key", "otherpolygons", "styles", "readonly"],
                data: function() {
                    return {
                        itemsToMove: [],
                        currentlyActiveIndices: [],
                        mouseDownPoint: [0, 0],
                        snapToGrid: !0,
                        gridSize: 10,
                        guidelinesVisible: !1,
                        viewBoxCenter: [0, 0],
                        viewBoxScale: 1,
                        viewBox: "0 0 0 0"
                    }
                },
                template: '\n  <div :style="{cursor:currentlyActiveIndices.length?\'move\':\'\'}">\n  <svg v-el:svg class="vsl-polygon-editor" v-el="svg"  :view-box.camel="viewBox" preserveAspectRatio="xMinYMax meet"\n    @mousedown.prevent="onMouseDown" @mousemove.prevent="onMouseMove" @mouseup.prevent="onMouseUp"\n    @mousewheel.stop="onMouseWheel"\n    @mouseenter="guidelinesVisible=true" @mouseleave="guidelinesVisible=false"\n    style="z-index:-100"\n  >\n        <style type="text/css" >\n           <![CDATA[\n              text {\n                    font-size: {{14*viewBoxScale}}px;\n              }\n\n             line,polygon {\n              fill:none; \n              stroke-width:{{2*viewBoxScale}}px;\n             }\n\n              {{css}}   \n\n           ]]>\n        </style>\n      <defs>\n      <path v-for="edge in edges"\n      \t\t:id="\'edge\'+$index"\n          :d="edgePath(edge)"\n      />\n    </defs>\n    <template v-if="otherpolygons">\n        <polygon v-for="p in otherpolygons" :points="polygonPoints(p)" class="other" />\n    </template>\n    <template v-if="guidelinesVisible">\n        <line :x1="mouseDownPoint[0]-1000*viewBoxScale" :y1="mouseDownPoint[1]" \n              :x2="mouseDownPoint[0]+1000*viewBoxScale" :y2="mouseDownPoint[1]" \n              class="guideline" />\n        <line :x1="mouseDownPoint[0]" :y1="mouseDownPoint[1]-1000*viewBoxScale"\n              :x2="mouseDownPoint[0]" :y2="mouseDownPoint[1]+1000*viewBoxScale"\n              class="guideline" />\n        <line :x1="mouseDownPoint[0]-1000*viewBoxScale" :y1="mouseDownPoint[1]-1000*viewBoxScale" \n              :x2="mouseDownPoint[0]+1000*viewBoxScale" :y2="mouseDownPoint[1]+1000*viewBoxScale" \n              class="guideline" />\n        <line :x1="mouseDownPoint[0]+1000*viewBoxScale" :y1="mouseDownPoint[1]-1000*viewBoxScale"\n              :x2="mouseDownPoint[0]-1000*viewBoxScale" :y2="mouseDownPoint[1]+1000*viewBoxScale"\n              class="guideline" />\n    </template>\n    <ellipse v-for="vert in vertices"\n    \t\t\t\t:cx="vert[0]" :cy="vert[1]"\n            :rx="4*viewBoxScale" :ry="4*viewBoxScale" :style="pointStyle($index)"\n            />\n    <ellipse v-if="centerPoint"\n    \t\t\t\t:cx="centerPoint[0]" :cy="centerPoint[1]"\n            :rx="4*viewBoxScale" :ry="4*viewBoxScale" style="fill:darkblue"\n            />\n  \t\t<polygon :points="polygonPoints(vertices)" class="current" />\n      <polygon :points="activePolygonPoints" class="current active" />\n      <text v-for="edge in edges" :dy="-10*viewBoxScale">\n      \t\t<textpath xlink:href="#edge{{$index}}"\n          \ttext-anchor="middle"\n            startOffset="50%"\n            >\n         {{Math.round(Math.sqrt(distanceSquared(edge.v1,edge.v2)))}}\n         </textpath>\n      </text>\n  </svg>\n    <div class="vsl-input-container vsl-select" v-if="!readonly">\n        <label>Snap grid</label>\n        <select v-model="gridSize" @change.stop @input.stop number>\n            <option value="5" >50</option>\n            <option value="10" >100</option>\n            <option value="25" >250</option>\n            <option value="50" >500</option>\n            <option value="100" >1000</option>\n            <option value="250" >2500</option>\n        </select>mm\n    </div>\n    <div class="vsl-input-container vsl-select">\n        <label>Zoom</label>\n        <input type="range" v-model="viewBoxScale" @change.stop @input.stop="setViewBox()"  number :min="0.1" :max="4" :step="0.1"/>\n        <a href="#" class="zoom-button" @click.stop="zoomToFit()"><i class="fa fa-home" aria-hidden="true" style="cursor:pointer"></i></a>\n    </div>\n   </div>\n    ',
                computed: {
                    activePolygonPoints: function() {
                        var e = this;
                        return this.currentlyActiveIndices.length < 2 ? "" : this.currentlyActiveIndices.map(function(t) {
                            return e.vertices[t]
                        }).map(function(e) {
                            return e[0] + "," + e[1]
                        }).join(" ")
                    },
                    css: function() {
                        var e = {
                            ".current": "fill:none;stroke: black",
                            ".other": "fill: none;stroke: gray;",
                            ".active": "stroke:darkblue",
                            ".guideline": "stroke:rgb(0,0,255);stroke-dasharray: " + 5 * this.viewBoxScale + ";"
                        };
                        return Object.assign(e, this.styles || {}), Object.keys(e).map(function(t) {
                            return t + " { " + e[t] + " }"
                        }).join("\n")
                    },
                    edges: function() {
                        return (this.vertices || []).map(function(e, t, n) {
                            return {
                                v1: e,
                                v2: n[(t + 1) % n.length],
                                i1: t,
                                i2: (t + 1) % n.length
                            }
                        })
                    },
                    centerPoint: function() {
                        if (2 == this.currentlyActiveIndices.length) {
                            var e = this.vertices[this.currentlyActiveIndices[0]],
                                t = this.vertices[this.currentlyActiveIndices[1]];
                            return this.divVertexByScalar(this.addVertex(e, t), 2)
                        }
                    },
                    maxGrabDistanceInPixels: function() {
                        return this.snapToGrid ? this.gridSize : 15
                    }
                },
                methods: {
                    polygonPoints: function(e) {
                        return e = e || [], e.vertices && (e = e.vertices), (e || []).map(function(e) {
                            return e[0] + "," + e[1]
                        }).join(" ")
                    },
                    polygonBB: function(e) {
                        return e = e || [], e.vertices && (e = e.vertices), (new t.Box2).setFromPoints(e.map(function(e) {
                            return (new t.Vector2).fromArray(e)
                        }))
                    },
                    pointStyle: function(e) {
                        return {
                            fill: this.currentlyActiveIndices.indexOf(e) >= 0 ? "darkblue" : "gray",
                            stroke: "none"
                        }
                    },
                    edgePath: function(e) {
                        var t = e.v1,
                            n = e.v2;
                        if (t[0] > n[0]) {
                            var r = t;
                            t = n, n = r
                        }
                        return "M " + t[0] + " " + t[1] + " L " + n[0] + " " + n[1]
                    },
                    mouseEventToSVGPoint: function(e) {
                        var t = this.$els.svg,
                            n = t.createSVGPoint();
                        return n.x = e.clientX, n.y = e.clientY, n = n.matrixTransform(t.getScreenCTM().inverse()), this.snapToGrid && (n.x = Math.round(n.x / this.gridSize) * this.gridSize, n.y = Math.round(n.y / this.gridSize) * this.gridSize), [n.x, n.y]
                    },
                    square: function(e) {
                        return e * e
                    },
                    addVertex: function(e, t) {
                        return [e[0] + t[0], e[1] + t[1]]
                    },
                    subVertex: function(e, t) {
                        return [e[0] - t[0], e[1] - t[1]]
                    },
                    mulVertex: function(e, t) {
                        return [e[0] + t[0], e[1] + t[1]]
                    },
                    divVertexByScalar: function(e, t) {
                        return [e[0] / t, e[1] / t]
                    },
                    mulVertexByScalar: function(e, t) {
                        return [e[0] * t, e[1] * t]
                    },
                    dotVertex: function(e, t) {
                        return e[0] * t[0] + e[1] * t[1]
                    },
                    distanceSquared: function(e, t) {
                        var n = this.subVertex(e, t);
                        return this.square(n[0]) + this.square(n[1])
                    },
                    distanceToEdgeSquared: function(e, t) {
                        var n = this.distanceSquared(e.v1, e.v2);
                        if (n <= 1) return this.distanceSquared(e.v1, t);
                        var r = this.subVertex(t, e.v1),
                            i = this.subVertex(e.v2, e.v1),
                            o = this.dotVertex(r, i) / n,
                            a = Math.max(0, Math.min(1, o)),
                            s = this.mulVertexByScalar(i, a),
                            c = this.addVertex(e.v1, s);
                        return this.distanceSquared(c, t)
                    },
                    isInsidePolygon: function(e) {
                        var t = e[0],
                            n = e[1];
                        return this.edges.reduce(function(e, r) {
                            var i = r.v1[0],
                                o = r.v1[1],
                                a = r.v2[0],
                                s = r.v2[1],
                                c = o > n != s > n && t < (a - i) * (n - o) / (s - o) + i;
                            return e ? !c : c
                        }, !1)
                    },
                    nearbyIndex: function(e, t, n) {
                        if (t = t || [], !t.length) return -1;
                        var r = t.reduce(function(t, r, i) {
                            var o = n(r, e);
                            return o < t.distanceSquared ? {
                                index: i,
                                distanceSquared: o
                            } : t
                        }, {
                            index: -1,
                            distanceSquared: 1e4
                        });
                        return r.distanceSquared > this.square(this.maxGrabDistanceInPixels) ? -1 : r.index
                    },
                    relevantVertexIndices: function(e) {
                        var t = this,
                            n = this.nearbyIndex(e, this.vertices, function(e, n) {
                                return t.distanceSquared(e, n)
                            });
                        if (n >= 0) return [n];
                        var r = this.nearbyIndex(e, this.edges, function(e, n) {
                            return t.distanceToEdgeSquared(e, n)
                        });
                        if (r >= 0) {
                            var i = this.edges[r];
                            return [i.i1, i.i2]
                        }
                        return this.isInsidePolygon(e) ? this.vertices.map(function(e, t) {
                            return t
                        }) : []
                    },
                    onMouseDown: function(e) {
                        if (!this.readonly && this.vertices && this.vertices.length) {
                            var t = this.mouseEventToSVGPoint(e);
                            if (this.itemsToMove = this.relevantVertexIndices(t), this.centerPoint && this.distanceSquared(this.centerPoint, t) < this.square(this.maxGrabDistanceInPixels)) {
                                var n = this.itemsToMove[0],
                                    r = n + 1;
                                this.vertices.splice(n + 1, 0, this.centerPoint), this.itemsToMove = [r]
                            }
                            1 === this.itemsToMove.length && this.vertices.$set(this.itemsToMove[0], t), this.currentlyActiveIndices = this.itemsToMove
                        }
                    },
                    onMouseMove: function(e) {
                        var t = this;
                        if (this.vertices && this.vertices.length) {
                            var n = this.mouseEventToSVGPoint(e),
                                r = this.subVertex(n, this.mouseDownPoint);
                            if (this.mouseDownPoint = n, this.itemsToMove.length && !this.readonly) {
                                this.itemsToMove.forEach(function(e) {
                                    var n = t.vertices[e];
                                    n = t.addVertex(n, r), t.vertices.$set(e, n)
                                });
                                var i = JSON.parse(JSON.stringify(this.vertices));
                                this.$dispatch("valuechanged", this.key, i)
                            } else this.currentlyActiveIndices = this.relevantVertexIndices(n), e.buttons && (this.viewBoxCenter[0] -= r[0], this.viewBoxCenter[1] -= r[1], this.mouseDownPoint[0] -= r[0], this.mouseDownPoint[1] -= r[1], this.setViewBox())
                        }
                    },
                    onMouseUp: function(e) {
                        var t = this;
                        this.vertices && this.vertices.length && (this.itemsToMove.length > 0 && this.itemsToMove.length <= 2 && this.vertices.length > 3 && this.itemsToMove.forEach(function(e) {
                            var n = t.vertices[e],
                                r = [(e + 1) % t.vertices.length, (e - 1 + t.vertices.length) % t.vertices.length];
                            t.vertices = t.vertices.filter(function(e, i) {
                                return r.indexOf(i) < 0 || t.distanceSquared(e, n) > t.square(t.maxGrabDistanceInPixels)
                            })
                        }), this.itemsToMove = [], this.currentlyActiveIndices = [], this.mouseCursor = "")
                    },
                    onMouseWheel: function(e) {
                        var t = e.wheelDelta > 0 ? .1 : -.1;
                        this.viewBoxScale = Math.min(4, Math.max(.1, this.viewBoxScale - t)), this.setViewBox()
                    },
                    setViewBox: function() {
                        var e = this.$els.svg;
                        if (e) {
                            var n = (new t.Vector2).fromArray(this.viewBoxCenter),
                                r = new t.Vector2(e.clientWidth * this.viewBoxScale, e.clientHeight * this.viewBoxScale),
                                i = (new t.Box2).setFromCenterAndSize(n, r);
                            this.viewBox = [i.min.x, i.min.y, r.x, r.y].join(" ")
                        }
                    },
                    zoomToFit: function() {
                        var e = this,
                            t = this.polygonBB(this.vertices);
                        this.otherpolygons.forEach(function(n) {
                            return t = t.union(e.polygonBB(n))
                        }), t.expandByScalar(100);
                        var n = t.getSize(),
                            r = this.$els.svg;
                        this.viewBoxScale = Math.max(n.x / r.clientWidth, n.y / r.clientHeight), this.viewBoxCenter = t.getCenter().toArray(), this.setViewBox()
                    }
                },
                ready: function() {
                    this.zoomToFit()
                }
            });
            e.component("vsl-polygon-editor", n)
        }
        e.registerPolygonEditor = t
    }(r || (r = {}))
}, function(e, t, n) {
    var r = n(0);
    r.OBJExporter = function() {}, r.OBJExporter.prototype = {
        constructor: r.OBJExporter,
        parse: function(e) {
            var t, n, i, o, a, s = "",
                c = 0,
                l = 0,
                h = 0,
                u = new r.Vector3,
                d = new r.Vector3,
                p = new r.Vector2,
                f = [],
                m = function(e) {
                    var i = 0,
                        m = 0,
                        g = 0,
                        v = e.geometry,
                        y = new r.Matrix3;
                    if (v instanceof r.Geometry && (v = (new r.BufferGeometry).setFromObject(e)), v instanceof r.BufferGeometry) {
                        var b = v.getAttribute("position"),
                            x = v.getAttribute("normal"),
                            w = v.getAttribute("uv"),
                            _ = v.getIndex();
                        if (s += "o " + e.name + "\n", e.material && e.material.name && (s += "usemtl " + e.material.name + "\n"), void 0 !== b)
                            for (t = 0, o = b.count; t < o; t++, i++) u.x = b.getX(t), u.y = b.getY(t), u.z = b.getZ(t), u.applyMatrix4(e.matrixWorld), s += "v " + u.x + " " + u.y + " " + u.z + "\n";
                        if (void 0 !== w)
                            for (t = 0, o = w.count; t < o; t++, g++) p.x = w.getX(t), p.y = w.getY(t), s += "vt " + p.x + " " + p.y + "\n";
                        if (void 0 !== x)
                            for (y.getNormalMatrix(e.matrixWorld), t = 0, o = x.count; t < o; t++, m++) d.x = x.getX(t), d.y = x.getY(t), d.z = x.getZ(t), d.applyMatrix3(y), s += "vn " + d.x + " " + d.y + " " + d.z + "\n";
                        if (null !== _)
                            for (t = 0, o = _.count; t < o; t += 3) {
                                for (a = 0; a < 3; a++) n = _.getX(t + a) + 1, f[a] = c + n + "/" + (w ? l + n : "") + "/" + (h + n);
                                s += "f " + f.join(" ") + "\n"
                            } else
                                for (t = 0, o = b.count; t < o; t += 3) {
                                    for (a = 0; a < 3; a++) n = t + a + 1, f[a] = c + n + "/" + (w ? l + n : "") + "/" + (h + n);
                                    s += "f " + f.join(" ") + "\n"
                                }
                    } else console.warn("THREE.OBJExporter.parseMesh(): geometry type unsupported", v);
                    c += i, l += g, h += m
                },
                g = function(e) {
                    var a = 0,
                        l = e.geometry,
                        h = e.type;
                    if (l instanceof r.Geometry && (l = (new r.BufferGeometry).setFromObject(e)), l instanceof r.BufferGeometry) {
                        var d = l.getAttribute("position");
                        l.getIndex();
                        if (s += "o " + e.name + "\n", void 0 !== d)
                            for (t = 0, o = d.count; t < o; t++, a++) u.x = d.getX(t), u.y = d.getY(t), u.z = d.getZ(t), u.applyMatrix4(e.matrixWorld), s += "v " + u.x + " " + u.y + " " + u.z + "\n";
                        if ("Line" === h) {
                            for (s += "l ", n = 1, o = d.count; n <= o; n++) s += c + n + " ";
                            s += "\n"
                        }
                        if ("LineSegments" === h)
                            for (n = 1, i = n + 1, o = d.count; n < o; n += 2, i = n + 1) s += "l " + (c + n) + " " + (c + i) + "\n"
                    } else console.warn("THREE.OBJExporter.parseLine(): geometry type unsupported", l);
                    c += a
                };
            return e.traverse(function(e) {
                e instanceof r.Mesh && m(e), e instanceof r.Line && g(e)
            }), s
        }
    }
}, function(e, t, n) {
    /*!
     * vue-i18n v3.1.1
     * (c) 2016 kazuya kawaguchi
     * Released under the MIT License.
     */
    ! function(t, n) {
        e.exports = n()
    }(0, function() {
        "use strict";

        function e(e, t) {
            window.console && (console.warn("[vue-i18n] " + e), t && console.warn(t.stack))
        }

        function t(e, t) {
            return _.call(e, t)
        }

        function n(e) {
            if (null === e || void 0 === e) return !0;
            if (Array.isArray(e)) {
                if (e.length > 0) return !1;
                if (0 === e.length) return !0
            } else if (w.Vue.util.isPlainObject(e))
                for (var n in e)
                    if (t(e, n)) return !1;
            return !0
        }

        function r(e) {
            if (!M) {
                var t = e.$watch("__watcher__", function(e) {});
                M = e._watchers[0].constructor, t()
            }
            return M
        }

        function i(e) {
            return E || (E = e._data.__ob__.dep.constructor), E
        }

        function o(e) {
            return e && "function" == typeof e.then
        }

        function a(e) {
            if (void 0 === e) return "eof";
            var t = e.charCodeAt(0);
            switch (t) {
                case 91:
                case 93:
                case 46:
                case 34:
                case 39:
                case 48:
                    return e;
                case 95:
                case 36:
                    return "ident";
                case 32:
                case 9:
                case 10:
                case 13:
                case 160:
                case 65279:
                case 8232:
                case 8233:
                    return "ws"
            }
            return t >= 97 && 122 >= t || t >= 65 && 90 >= t ? "ident" : t >= 49 && 57 >= t ? "number" : "else"
        }

        function s(e) {
            var t = T.Vue.util,
                n = t.isLiteral,
                r = t.stripQuotes,
                i = e.trim();
            return ("0" !== e.charAt(0) || !isNaN(e)) && (n(i) ? r(i) : "*" + i)
        }

        function c(e) {
            var t = [],
                n = -1,
                r = R,
                i = 0,
                o = void 0,
                c = void 0,
                l = void 0,
                h = void 0,
                u = void 0,
                d = void 0,
                p = void 0,
                f = [];
            for (f[P] = function() {
                    void 0 !== l && (t.push(l), l = void 0)
                }, f[A] = function() {
                    void 0 === l ? l = c : l += c
                }, f[C] = function() {
                    f[A](), i++
                }, f[L] = function() {
                    if (i > 0) i--, r = I, f[A]();
                    else {
                        if (i = 0, !1 === (l = s(l))) return !1;
                        f[P]()
                    }
                }; null != r;)
                if (n++, "\\" !== (o = e[n]) || ! function() {
                        var t = e[n + 1];
                        return r === O && "'" === t || r === k && '"' === t ? (n++, c = "\\" + t, f[A](), !0) : void 0
                    }()) {
                    if (h = a(o), p = B[r], (u = p[h] || p.else || N) === N) return;
                    if (r = u[0], (d = f[u[1]]) && (c = u[2], c = void 0 === c ? o : c, !1 === d())) return;
                    if (r === D) return t.raw = e, t
                }
        }

        function l(e) {
            var t = S[e];
            return t || (t = c(e)) && (S[e] = t), t
        }

        function h(e, t) {
            if (!(0, T.Vue.util.isObject)(e)) return null;
            var r = l(t);
            if (n(r)) return null;
            for (var i = e, o = r.length, a = 0; o > a;) {
                var s = i[r[a]];
                if (void 0 === s) {
                    i = null;
                    break
                }
                i = s, a++
            }
            return i
        }

        function u(t) {
            t.locale = function(t, n, r) {
                return void 0 === n ? U[t] : void(null === n ? (U[t] = void 0, delete U[t]) : d(t, n, function(n) {
                    n ? (U[t] = n, r && r()) : e("failed set `" + t + "` locale")
                }))
            }
        }

        function d(e, t, n) {
            var r = this;
            "object" === (void 0 === t ? "undefined" : x.typeof(t)) ? n(t): function() {
                var e = t.call(r);
                "function" == typeof e ? e.resolved ? n(e.resolved) : e.requested ? e.pendingCallbacks.push(n) : function() {
                    e.requested = !0;
                    var t = e.pendingCallbacks = [n];
                    e(function(n) {
                        e.resolved = n;
                        for (var r = 0, i = t.length; i > r; r++) t[r](n)
                    }, function() {
                        n()
                    })
                }() : o(e) && e.then(function(e) {
                    n(e)
                }, function() {
                    n()
                }).catch(function(e) {
                    console.error(e), n()
                })
            }()
        }

        function p(e, t) {
            var n = e.prototype._init;
            e.prototype._init = function(e) {
                var r = this;
                e = e || {};
                var i = e._parent || e.parent || this,
                    o = i.$lang;
                this.$lang = o || t, this._langUnwatch = this.$lang.$watch("lang", function(e, t) {
                    f(r)
                }), n.call(this, e)
            };
            var r = e.prototype._destroy;
            e.prototype._destroy = function() {
                this._langUnwatch && (this._langUnwatch(), this._langUnwatch = null), this.$lang = null, r.apply(this, arguments)
            }
        }

        function f(e) {
            for (var t = e._watchers.length; t--;) e._watchers[t].update(!0)
        }

        function m(e, t) {
            var n = r(t),
                o = i(t);
            Object.defineProperty(e.config, "lang", {
                enumerable: !0,
                configurable: !0,
                get: function(e, t) {
                    var r = new n(t, e, null, {
                        lazy: !0
                    });
                    return function() {
                        return r.dirty && r.evaluate(), o.target && r.depend(), r.value
                    }
                }(function() {
                    return t.lang
                }, t),
                set: e.util.bind(function(e) {
                    t.lang = e
                }, t)
            })
        }

        function g(e) {
            for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; t > r; r++) n[r - 1] = arguments[r];
            return 1 === n.length && "object" === x.typeof(n[0]) && (n = n[0]), n && n.hasOwnProperty || (n = {}), e.replace(F, function(t, r, i, o) {
                var a = void 0;
                return "{" === e[o - 1] && "}" === e[o + t.length] ? i : (a = n.hasOwnProperty(i) ? n[i] : null, null === a || void 0 === a ? "" : a)
            })
        }

        function v(e) {
            function t() {
                for (var t = arguments.length, n = Array(t), r = 0; t > r; r++) n[r] = arguments[r];
                var i = e.config.lang;
                return 1 === n.length ? a(n[0]) || o(n[0]) ? n = n[0] : "string" == typeof n[0] && (i = n[0]) : 2 === n.length && ("string" == typeof n[0] && (i = n[0]), (a(n[1]) || o(n[1])) && (n = n[1])), {
                    lang: i,
                    params: n
                }
            }

            function n(e, t, n) {
                if (!e) return null;
                var r = h(e, t) || e[t];
                return r ? n ? g(r, n) : r : null
            }

            function r(e) {
                return e
            }
            var i = e.util,
                o = i.isArray,
                a = i.isObject;
            return e.t = function(i) {
                for (var o = arguments.length, a = Array(o > 1 ? o - 1 : 0), s = 1; o > s; s++) a[s - 1] = arguments[s];
                if (!i) return "";
                var c = t.apply(void 0, a),
                    l = c.lang,
                    h = c.params;
                return n(e.locale(l), i, h) || r(i)
            }, e.prototype.$t = function(i) {
                if (!i) return "";
                for (var o = arguments.length, a = Array(o > 1 ? o - 1 : 0), s = 1; o > s; s++) a[s - 1] = arguments[s];
                var c = t.apply(void 0, a),
                    l = c.lang,
                    h = c.params;
                return n(this.$options.locales && this.$options.locales[l], i, h) || n(e.locale(l), i, h) || r(i)
            }, e
        }

        function y(e) {
            var t = (arguments.length <= 1 || void 0 === arguments[1] || arguments[1], "en");
            T.Vue = w.Vue = e, b(e, t), u(e), p(e, z), m(e, z), v(e)
        }

        function b(e, t) {
            var n = e.config.silent;
            e.config.silent = !0, z || (z = new e({
                data: {
                    lang: t
                }
            })), e.config.silent = n
        }
        var x = {};
        x.typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e
        };
        var w = {},
            _ = Object.prototype.hasOwnProperty,
            M = void 0,
            E = void 0,
            T = {},
            S = Object.create(null),
            A = 0,
            P = 1,
            C = 2,
            L = 3,
            R = 0,
            I = 4,
            O = 5,
            k = 6,
            D = 7,
            N = 8,
            B = [];
        B[R] = {
            ws: [R],
            ident: [3, A],
            "[": [I],
            eof: [D]
        }, B[1] = {
            ws: [1],
            ".": [2],
            "[": [I],
            eof: [D]
        }, B[2] = {
            ws: [2],
            ident: [3, A]
        }, B[3] = {
            ident: [3, A],
            0: [3, A],
            number: [3, A],
            ws: [1, P],
            ".": [2, P],
            "[": [I, P],
            eof: [D, P]
        }, B[I] = {
            "'": [O, A],
            '"': [k, A],
            "[": [I, C],
            "]": [1, L],
            eof: N,
            else: [I, A]
        }, B[O] = {
            "'": [I, A],
            eof: N,
            else: [O, A]
        }, B[k] = {
            '"': [I, A],
            eof: N,
            else: [k, A]
        };
        var U = Object.create(null),
            F = /(%|)\{([0-9a-zA-Z]+)\}/g,
            z = void 0;
        return y.version = "3.1.1", "undefined" != typeof window && window.Vue && window.Vue.use(y), y
    })
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r, i = n(58);
    n.n(i);
    ! function(e) {
        function t() {
            return i.extend({
                template: `<div class="sidebar-container" :class="{collapsed: isCollapsed}" >
                                <div class="sidebar-icon-container">
                                <div v-for="ci in componentInfo" class="sidebar-icons">    
                                    <label class="sidebar-icon">       
                                    <input type="radio" name="sidebar-menu" :value="ci.name" v-model="currentComponentName" @click="isCollapsed=false"/>       
                                    <i class="fa " :class="ci.icon" aria-hidden="true"></i>    
                                    </label>    
                                </div>
                                </div>
                                <div v-show="!isCollapsed" class="sidebar-item" transition="expand" style="min-height: 60vh">
                                <label class="sidebar-close">        
                                <input type="checkbox" v-model="isCollapsed"/>        
                                <i class="fa fa-close" aria-hidden="true"></i>    
                                </label>      
                                <component :is="currentComponentName" >     
                                </component>
                                <div class="emailForm">    
                                    <form @submit=checkForm v-show="isEmailSendTab" style="width:310px;top:-20px;position:relative;">
                                        
                                        <label for="name" v-model="name">Name</label><br>
                                        <input type="text" name="name" id="name" v-model="name"><br>
                                        <label for="email" v-model="email">Email</label><br>
                                        <input type="email" name="email" id="email" v-model="email" min="0"><br>
                                        <label for="city" v-model="city">Stadt</label><br>
                                        <input type="text" name="city" id="city" v-model="city" min="0"><br>
                                        <label for="phone" v-model="phone">Telefon</label><br>
                                        <input type="text" name="phone" id="phone" v-model="phone" min="0"><br><br>
                                        <input type="submit" class="btn btn-primary" value="Senden"/>
                                    </form>   
                                    <div v-show="isEmailSendTab" style="margin-bottom:15px; color:{{messageColor}}"><h2>{{messageTitle}}</h2>{{message}}</div>
                                    <a href="#" id="download" :class="{\'disabled\': isEmailSendTab || isFourthStep || isThirdStep || isSecondStep || isFirstStep}" style="width: 250px !important;" class="btn btn-primary btn-custom" ></a> 
                                    <a href="#" :class="{\'disabled\':isFirstStep}" @click.prevent="go(-1)" class="btn btn-primary">          
                                    <i class="fa fa-step-backward" aria-hidden="true"></i>          
                                    {{prevButtonText}}       
                                    </a>       
                                    <a href="#" :class="{\'disabled\':isLastStep}" @click.prevent="go(1)" class="btn btn-primary">          
                                    {{nextButtonText}}          
                                    <i class="fa fa-step-forward" aria-hidden="true"></i>      
                                    </a>     
                                </div>

                                </div>
                            </div>`,
                data: function() {
                    return {
                        componentInfo: [],
                        currentComponentName: "none",
                        nextButtonText: "Next",
                        prevButtonText: "Previous",
                        isCollapsed: !1,
                        name: '',
                        email: '',
                        city: '',
                        phone: '',
                        message: '',
                        messageColor: '',
                        messageTitle: ''
                    }
                },
                computed: {
                    componentNames: function() {
                        return this.componentInfo.map(function(e) {
                            return e.name
                        })
                    },
                    isFirstStep: function() {
                        return this.componentInfo[0].name === this.currentComponentName
                    },
                    isSecondStep: function() {
                        return this.componentInfo[1].name === this.currentComponentName
                    },
                    isThirdStep: function() {
                        return this.componentInfo[2].name === this.currentComponentName
                    },
                    isFourthStep: function() {
                        return this.componentInfo[3].name === this.currentComponentName
                    },
                    isLastStep: function() {
                        return this.componentInfo[this.componentInfo.length - 1].name === this.currentComponentName
                    },
                    isEmailSendTab: function() {
                        return this.componentInfo[this.componentInfo.length - 2].name === this.currentComponentName
                    },
                },
                ready: function() {
                    var e = window.location.hash,
                        t = (e || "").match(/\d+/);
                    if (t) {
                        var n = parseInt(t[0]) - 1;
                        n > 0 && n <= this.componentNames.length && (this.currentComponentName = this.componentNames[n])
                    }
                },
                methods: {
                    go: function(e) {
                        var t = this.componentNames,
                            n = t.indexOf(this.currentComponentName),
                            r = n + e;
                        if (!(r < 0 || r >= t.length)) {
                            this.currentComponentName = t[r], window.location.hash = "" + (r + 1);
                            var i = i;
                            i && i("send", "pageview", {
                                page: location.pathname + "?tab=" + (r + 1)
                            })
                        }
                    },
                    bindMethod: function(fn, context) {
                        return function() {
                            fn.apply(context, arguments);
                        };
                    },
                    checkForm:function(e) {
                       e.preventDefault();
                       var data = newBuilder.previousDraggableInput;
                       var dataSearch = data.search("sideLeft$$$$sideRight$$$$sideFront$$$$sideBack");
                       if (dataSearch > 0) {
                          data.replace("sideLeft$$$$sideRight$$$$sideFront$$$$sideBack","");
                       }
                       var externalData = JSON.parse(data);
                       var wallmaterial = "";
                       var wallmaterialcolor = "";
                       if(externalData.style.wallMaterialId == "brick") {
                          wallmaterial = "Backstein";
                          wallmaterialcolor = "/";
                       }
                       else {
                          wallmaterial = "Beton";
                          wallmaterialcolor = externalData.style.wallStuccoRalColorId;
                       }
                       var drop = [];
                       var element = [];
                       var dots = [];
                       for (var i = 0; i<4; i++) {
                          if (typeof externalData.elements.droppedElements[i] !== 'undefined') {
                             drop.push(externalData.elements.droppedElements[i].dropTargetId);
                             element.push(externalData.elements.droppedElements[i].elementId);
                             dots.push(':');
                          }
                          else {
                             drop.push('');
                             element.push('');
                             dots.push('');
                          }
                       }
                       
                       var c = renderer.env;
                       c.myAnimate();
                       var creds = {
                        email: this.$data.email,
                        city: this.$data.city,
                        name: this.$data.name,
                        phone: this.$data.phone,
                        basisfarbe: externalData.style.baseColorRAL,
                        lamellen: externalData.style.roofColorRAL,
                        markisen: externalData.style.screenColorRAL,
                        breite: externalData.size.width,
                        hohe: externalData.size.height,
                        tiefe: externalData.size.depth,
                        height: externalData.size.height,
                        width: externalData.size.width,
                        vorn: externalData.wallHeights.front,
                        hinten: externalData.wallHeights.back,
                        links: externalData.wallHeights.left,
                        rechts: externalData.wallHeights.right,
                        wand: wallmaterial,
                        ral: wallmaterialcolor,
                        drop1: drop[0],
                        element1: element[0],
                        drop2: drop[1],
                        element2: element[1],
                        drop3: drop[2],
                        element3: element[2],
                        drop4: drop[3],
                        element4: element[3],
                        dots1: dots[0],
                        dots2: dots[1],
                        dots3: dots[2],
                        dots4: dots[3]
                       };
                       
                       var basisfarbe1 = document.getElementsByTagName('input')[7].value;
                       var imgData = c.renderer.domElement.toDataURL('image/jpeg', 0.2);
                       
                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "/api/test/", true);
                        xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                        xhr.send(JSON.stringify({creds: creds, data: imgData }));
                        xhr.onreadystatechange = this.bindMethod(function () {
                            if(xhr.readyState === 4 && xhr.status === 200) {
                                this.$data.messageTitle = 'Vielen Dank'
                                this.$data.message = 'Wir werden Sie schnellstmöglich kontaktieren.',
                                this.$data.messageColor = 'green';
                            } else if(xhr.status === 400) {
                                console.log(this);
                                this.$data.message = 'Es tut uns leid, es gab einen Fehler beim Senden. Bitte überprüfen Sie Ihre Daten!',
                                this.$data.messageColor = 'red';
                            }
                        }, this)
                    }
                }
            })
        }
        e.getSidebar = t
    }(r || (r = {}))
}, function(e, t, n) {
    "use strict";
    n.d(t, "a", function() {
        return r
    });
    var r = function() {
        function e(e, t, r, i) {
            e = e.map(function(e) {
                return {
                    x: e.x * window.innerWidth / 2,
                    y: e.y * window.innerHeight / 2
                }
            });
            var o = new n.Posit(480, t, r),
                a = o.pose(e),
                s = a.bestRotation,
                c = a.bestTranslation;
            i.rotation.x = Math.asin(-s[1][2]), i.rotation.y = -Math.atan2(s[0][2], s[2][2]), i.rotation.z = Math.atan2(s[1][0], s[1][1]) + Math.PI, i.position.x = -c[0], i.position.y = -c[1], i.position.z = c[2]
        }
        var t = t || {};
        t.svdcmp = function(e, n, r, i, o) {
            var a, s, c, l, h, u, d, p, f, m, g, v, y, b, x, w = 0,
                _ = 0,
                M = 0,
                E = [];
            for (s = 0; s < r; ++s) {
                if (d = s + 1, E[s] = M * _, _ = v = M = 0, s < n) {
                    for (u = s; u < n; ++u) M += Math.abs(e[u][s]);
                    if (0 !== M) {
                        for (u = s; u < n; ++u) e[u][s] /= M, v += e[u][s] * e[u][s];
                        for (m = e[s][s], _ = -t.sign(Math.sqrt(v), m), g = m * _ - v, e[s][s] = m - _, l = d; l < r; ++l) {
                            for (v = 0, u = s; u < n; ++u) v += e[u][s] * e[u][l];
                            for (m = v / g, u = s; u < n; ++u) e[u][l] += m * e[u][s]
                        }
                        for (u = s; u < n; ++u) e[u][s] *= M
                    }
                }
                if (i[s] = M * _, _ = v = M = 0, s < n && s !== r - 1) {
                    for (u = d; u < r; ++u) M += Math.abs(e[s][u]);
                    if (0 !== M) {
                        for (u = d; u < r; ++u) e[s][u] /= M, v += e[s][u] * e[s][u];
                        for (m = e[s][d], _ = -t.sign(Math.sqrt(v), m), g = m * _ - v, e[s][d] = m - _, u = d; u < r; ++u) E[u] = e[s][u] / g;
                        for (l = d; l < n; ++l) {
                            for (v = 0, u = d; u < r; ++u) v += e[l][u] * e[s][u];
                            for (u = d; u < r; ++u) e[l][u] += v * E[u]
                        }
                        for (u = d; u < r; ++u) e[s][u] *= M
                    }
                }
                w = Math.max(w, Math.abs(i[s]) + Math.abs(E[s]))
            }
            for (s = r - 1; s >= 0; --s) {
                if (s < r - 1) {
                    if (0 !== _) {
                        for (l = d; l < r; ++l) o[l][s] = e[s][l] / e[s][d] / _;
                        for (l = d; l < r; ++l) {
                            for (v = 0, u = d; u < r; ++u) v += e[s][u] * o[u][l];
                            for (u = d; u < r; ++u) o[u][l] += v * o[u][s]
                        }
                    }
                    for (l = d; l < r; ++l) o[s][l] = o[l][s] = 0
                }
                o[s][s] = 1, _ = E[s], d = s
            }
            for (s = Math.min(r, n) - 1; s >= 0; --s) {
                for (d = s + 1, _ = i[s], l = d; l < r; ++l) e[s][l] = 0;
                if (0 !== _) {
                    for (_ = 1 / _, l = d; l < r; ++l) {
                        for (v = 0, u = d; u < n; ++u) v += e[u][s] * e[u][l];
                        for (m = v / e[s][s] * _, u = s; u < n; ++u) e[u][l] += m * e[u][s]
                    }
                    for (l = s; l < n; ++l) e[l][s] *= _
                } else
                    for (l = s; l < n; ++l) e[l][s] = 0;
                ++e[s][s]
            }
            for (u = r - 1; u >= 0; --u)
                for (c = 1; c <= 30; ++c) {
                    for (a = !0, d = u; d >= 0; --d) {
                        if (p = d - 1, Math.abs(E[d]) + w === w) {
                            a = !1;
                            break
                        }
                        if (Math.abs(i[p]) + w === w) break
                    }
                    if (a)
                        for (f = 0, v = 1, s = d; s <= u && (m = v * E[s], Math.abs(m) + w !== w); ++s)
                            for (_ = i[s], g = t.pythag(m, _), i[s] = g, g = 1 / g, f = _ * g, v = -m * g, l = 1; l <= n; ++l) b = e[l][p], x = e[l][s], e[l][p] = b * f + x * v, e[l][s] = x * f - b * v;
                    if (x = i[u], d === u) {
                        if (x < 0)
                            for (i[u] = -x, l = 0; l < r; ++l) o[l][u] = -o[l][u];
                        break
                    }
                    if (30 === c) return !1;
                    for (y = i[d], p = u - 1, b = i[p], _ = E[p], g = E[u], m = ((b - x) * (b + x) + (_ - g) * (_ + g)) / (2 * g * b), _ = t.pythag(m, 1), m = ((y - x) * (y + x) + g * (b / (m + t.sign(_, m)) - g)) / y, f = v = 1, l = d; l <= p; ++l) {
                        for (s = l + 1, _ = E[s], b = i[s], g = v * _, _ *= f, x = t.pythag(m, g), E[l] = x, f = m / x, v = g / x, m = y * f + _ * v, _ = _ * f - y * v, g = b * v, b *= f, h = 0; h < r; ++h) y = o[h][l], x = o[h][s], o[h][l] = y * f + x * v, o[h][s] = x * f - y * v;
                        for (x = t.pythag(m, g), i[l] = x, 0 !== x && (x = 1 / x, f = m * x, v = g * x), m = f * _ + v * b, y = f * b - v * _, h = 0; h < n; ++h) b = e[h][l], x = e[h][s], e[h][l] = b * f + x * v, e[h][s] = x * f - b * v
                    }
                    E[d] = 0, E[u] = m, i[u] = y
                }
            return !0
        }, t.pythag = function(e, t) {
            var n, r = Math.abs(e),
                i = Math.abs(t);
            return r > i ? (n = i / r, r * Math.sqrt(1 + n * n)) : 0 === i ? 0 : (n = r / i, i * Math.sqrt(1 + n * n))
        }, t.sign = function(e, t) {
            return t >= 0 ? Math.abs(e) : -Math.abs(e)
        };
        var n = n || {};
        return n.Posit = function(e, t, n) {
            t.length ? this.objectPoints = t : this.objectPoints = this.buildModel(t, n), this.focalLength = e, this.objectVectors = [], this.objectNormal = [], this.objectMatrix = [
                [],
                [],
                []
            ], this.init()
        }, n.Posit.prototype.buildModel = function(e, t) {
            t || (t = e);
            var n = e / 2,
                r = t / 2;
            return [
                [-n, r, 0],
                [n, r, 0],
                [n, -r, 0],
                [-n, -r, 0]
            ]
        }, n.Posit.prototype.init = function() {
            var e, t = this.objectPoints.length,
                r = [],
                i = [],
                o = 0,
                a = 2;
            for (e = 0; e < t; ++e) this.objectVectors[e] = [this.objectPoints[e][0] - this.objectPoints[0][0], this.objectPoints[e][1] - this.objectPoints[0][1], this.objectPoints[e][2] - this.objectPoints[0][2]], r[e] = [this.objectVectors[e][0], this.objectVectors[e][1], this.objectVectors[e][2]];
            for (; 0 === o;) i[0] = this.objectVectors[1][1] * this.objectVectors[a][2] - this.objectVectors[1][2] * this.objectVectors[a][1], i[1] = this.objectVectors[1][2] * this.objectVectors[a][0] - this.objectVectors[1][0] * this.objectVectors[a][2], i[2] = this.objectVectors[1][0] * this.objectVectors[a][1] - this.objectVectors[1][1] * this.objectVectors[a][0], o = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]), ++a;
            for (e = 0; e < 3; ++e) this.objectNormal[e] = i[e] / o;
            n.pseudoInverse(r, t, this.objectMatrix)
        }, n.Posit.prototype.pose = function(e) {
            var t, r, i, o, a, s, c = [
                    [],
                    [],
                    []
                ],
                l = [
                    [],
                    [],
                    []
                ],
                h = [],
                u = [
                    [],
                    [],
                    []
                ],
                d = [
                    [],
                    [],
                    []
                ],
                p = [],
                f = [];
            for (this.pos(e, c, l, h), i = this.isValid(c, h), t = i ? this.iterate(e, c, h, u, p) : {
                    euclidean: -1,
                    pixels: -1,
                    maximum: -1
                }, o = this.isValid(l, h), r = o ? this.iterate(e, l, h, d, f) : {
                    euclidean: -1,
                    pixels: -1,
                    maximum: -1
                }, a = 0; a < 3; ++a)
                for (s = 0; s < 3; ++s) i && (p[a] -= u[a][s] * this.objectPoints[0][s]), o && (f[a] -= d[a][s] * this.objectPoints[0][s]);
            return t.euclidean < r.euclidean ? new n.Pose(t.pixels, u, p, r.pixels, d, f) : new n.Pose(r.pixels, d, f, t.pixels, u, p)
        }, n.Posit.prototype.pos = function(e, t, n, r) {
            var i, o, a, s, c, l, h, u, d, p, f = this.objectPoints.length,
                m = [],
                g = [],
                v = [],
                y = [],
                b = [],
                x = [],
                w = [],
                _ = [];
            for (d = 0; d < f; ++d) m[d] = [e[d].x - e[0].x, e[d].y - e[0].y];
            for (d = 0; d < 3; ++d)
                for (g[d] = 0, v[d] = 0, p = 0; p < f; ++p) g[d] += this.objectMatrix[d][p] * m[p][0], v[d] += this.objectMatrix[d][p] * m[p][1];
            for (i = g[0] * g[0] + g[1] * g[1] + g[2] * g[2], o = v[0] * v[0] + v[1] * v[1] + v[2] * v[2], a = g[0] * v[0] + g[1] * v[1] + g[2] * v[2], s = (o - i) * (o - i) + a * a * 4, c = o - i >= 0 ? (o - i + Math.sqrt(s)) / 2 : (o - i - Math.sqrt(s)) / 2, c >= 0 ? (l = Math.sqrt(c), h = 0 === l ? 0 : -a / l) : (l = Math.sqrt(-a * a / c), h = 0 === l ? Math.sqrt(i - o) : -a / l), d = 0; d < 3; ++d) y[d] = g[d] + l * this.objectNormal[d], b[d] = v[d] + h * this.objectNormal[d];
            for (u = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]), d = 0; d < 3; ++d) x[d] = y[d] / u, w[d] = b[d] / u;
            for (_[0] = x[1] * w[2] - x[2] * w[1], _[1] = x[2] * w[0] - x[0] * w[2], _[2] = x[0] * w[1] - x[1] * w[0], d = 0; d < 3; ++d) t[0][d] = x[d], t[1][d] = w[d], t[2][d] = _[d];
            for (d = 0; d < 3; ++d) y[d] = g[d] - l * this.objectNormal[d], b[d] = v[d] - h * this.objectNormal[d];
            for (d = 0; d < 3; ++d) x[d] = y[d] / u, w[d] = b[d] / u;
            for (_[0] = x[1] * w[2] - x[2] * w[1], _[1] = x[2] * w[0] - x[0] * w[2], _[2] = x[0] * w[1] - x[1] * w[0], d = 0; d < 3; ++d) n[0][d] = x[d], n[1][d] = w[d], n[2][d] = _[d];
            r[0] = e[0].x / u, r[1] = e[0].y / u, r[2] = this.focalLength / u
        }, n.Posit.prototype.isValid = function(e, t) {
            for (var n, r = this.objectPoints.length, i = 1 / 0, o = 0; o < r; ++o)(n = t[2] + (e[2][0] * this.objectVectors[o][0] + e[2][1] * this.objectVectors[o][1] + e[2][2] * this.objectVectors[o][2])) < i && (i = n);
            return i >= 0
        }, n.Posit.prototype.iterate = function(e, t, n, r, i) {
            var o, a, s, c, l, h, u, d, p, f = this.objectPoints.length,
                m = [],
                g = [],
                v = [
                    [],
                    [],
                    []
                ],
                y = [
                    [],
                    [],
                    []
                ],
                b = [],
                x = [],
                w = !1,
                _ = 0;
            for (d = 0; d < f; ++d) m[d] = {
                x: e[d].x,
                y: e[d].y
            };
            for (d = 0; d < 3; ++d) {
                for (p = 0; p < 3; ++p) r[d][p] = t[d][p];
                i[d] = n[d]
            }
            for (d = 0; d < f; ++d) {
                for (s = 0, p = 0; p < 3; ++p) s += this.objectVectors[d][p] * r[2][p] / i[2];
                g[d] = {
                    x: (1 + s) * e[d].x,
                    y: (1 + s) * e[d].y
                }
            }
            for (a = 0, d = 0; d < f; ++d) a += Math.abs(g[d].x - m[d].x), a += Math.abs(g[d].y - m[d].y);
            for (d = 0; d < 3; ++d) b[d] = i[d] - (r[d][0] * this.objectPoints[0][0] + r[d][1] * this.objectPoints[0][1] + r[d][2] * this.objectPoints[0][2]);
            for (c = l = this.error(e, r, b), w = 0 === l.pixels || a < .01; _++ < 1e3 && !w;) {
                for (d = 0; d < f; ++d) m[d].x = g[d].x, m[d].y = g[d].y;
                for (this.pos(g, v, y, i), d = 0; d < 3; ++d) b[d] = i[d] - (v[d][0] * this.objectPoints[0][0] + v[d][1] * this.objectPoints[0][1] + v[d][2] * this.objectPoints[0][2]), x[d] = i[d] - (y[d][0] * this.objectPoints[0][0] + y[d][1] * this.objectPoints[0][1] + y[d][2] * this.objectPoints[0][2]);
                if (l = this.error(e, v, b), h = this.error(e, y, x), l.euclidean >= 0 && h.euclidean >= 0)
                    if (h.euclidean < l.euclidean)
                        for (c = h, d = 0; d < 3; ++d)
                            for (p = 0; p < 3; ++p) r[d][p] = y[d][p];
                    else
                        for (c = l, d = 0; d < 3; ++d)
                            for (p = 0; p < 3; ++p) r[d][p] = v[d][p];
                if (l.euclidean < 0 && h.euclidean >= 0)
                    for (c = h, d = 0; d < 3; ++d)
                        for (p = 0; p < 3; ++p) r[d][p] = y[d][p];
                if (h.euclidean < 0 && l.euclidean >= 0)
                    for (c = l, d = 0; d < 3; ++d)
                        for (p = 0; p < 3; ++p) r[d][p] = v[d][p];
                for (d = 0; d < f; ++d) {
                    for (s = 0, p = 0; p < 3; ++p) s += this.objectVectors[d][p] * r[2][p] / i[2];
                    g[d].x = (1 + s) * e[d].x, g[d].y = (1 + s) * e[d].y
                }
                for (o = a, a = 0, d = 0; d < f; ++d) a += Math.abs(g[d].x - m[d].x), a += Math.abs(g[d].y - m[d].y);
                u = Math.abs(a - o), w = 0 === c.pixels || u < .01
            }
            return c
        }, n.Posit.prototype.error = function(e, t, n) {
            var r, i, o, a = this.objectPoints.length,
                s = [],
                c = [],
                l = [],
                h = 0,
                u = 0,
                d = 0;
            if (!this.isValid(t, n)) return {
                euclidean: -1,
                pixels: -1,
                maximum: -1
            };
            for (r = 0; r < a; ++r)
                for (s[r] = [], i = 0; i < 3; ++i) s[r][i] = n[i];
            for (r = 0; r < a; ++r)
                for (i = 0; i < 3; ++i)
                    for (o = 0; o < 3; ++o) s[r][i] += t[i][o] * this.objectPoints[r][o];
            for (r = 0; r < a; ++r)
                for (c[r] = [], i = 0; i < 2; ++i) c[r][i] = this.focalLength * s[r][i] / s[r][2];
            for (r = 0; r < a; ++r) l[r] = [c[r][0] - e[r].x, c[r][1] - e[r].y];
            for (r = 0; r < a; ++r) h += Math.sqrt(l[r][0] * l[r][0] + l[r][1] * l[r][1]), u += Math.abs(Math.round(c[r][0]) - Math.round(e[r].x)) + Math.abs(Math.round(c[r][1]) - Math.round(e[r].y)), Math.abs(l[r][0]) > d && (d = Math.abs(l[r][0])), Math.abs(l[r][1]) > d && (d = Math.abs(l[r][1]));
            return {
                euclidean: h / a,
                pixels: u,
                maximum: d
            }
        }, n.pseudoInverse = function(e, n, r) {
            var i, o, a, s = [],
                c = [
                    [],
                    [],
                    []
                ],
                l = [
                    [],
                    [],
                    []
                ],
                h = 0,
                u = 0;
            for (t.svdcmp(e, n, 3, s, c), i = 0; i < 3; ++i) s[i] > h && (h = s[i]);
            for (h *= .01, i = 0; i < 3; ++i) s[i] < h && (s[i] = 0);
            for (o = 0; o < 3; ++o)
                if (0 === s[o])
                    for (++u, a = o; a < 2; ++a) {
                        for (i = 0; i < n; ++i) e[i][a] = e[i][a + 1];
                        for (i = 0; i < 3; ++i) c[i][a] = c[i][a + 1]
                    }
                for (o = 0; o < 2; ++o) 0 === s[o] && (s[o] = s[o + 1]);
            for (i = 0; i < 3; ++i)
                for (o = 0; o < 3 - u; ++o) l[i][o] = c[i][o] / s[o];
            for (i = 0; i < 3; ++i)
                for (o = 0; o < n; ++o)
                    for (r[i][o] = 0, a = 0; a < 3 - u; ++a) r[i][o] += l[i][a] * e[o][a]
        }, n.Pose = function(e, t, n, r, i, o) {
            this.bestError = e, this.bestRotation = t, this.bestTranslation = n, this.alternativeError = r, this.alternativeRotation = i, this.alternativeTranslation = o
        }, e
    }()
}]);